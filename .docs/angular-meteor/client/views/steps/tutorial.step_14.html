<template name="tutorial.step_14.html">
  <div>
    <a href="https://github.com/Urigo/angular-meteor/edit/master/.docs/angular-meteor/client/views/steps/tutorial.step_14.html"
       class="btn btn-default btn-lg improve-button">
      <i class="glyphicon glyphicon-edit">&nbsp;</i>Improve this doc
    </a>
    <ul class="btn-group tutorial-nav">
      <a href="/tutorial/step_13"><li class="btn btn-primary"><i class="glyphicon glyphicon-step-backward"></i> Previous</li></a>
      <a href="http://socially-step14.meteor.com/"><li class="btn btn-primary"><i class="glyphicon glyphicon-play"></i> Live Demo</li></a>
      <a href="https://github.com/Urigo/meteor-angular-socially/compare/step_13...step_14"><li class="btn btn-primary"><i class="glyphicon glyphicon-search"></i> Code Diff</li></a>
      <a href="/tutorial/step_15"><li class="btn btn-primary">Next <i class="glyphicon glyphicon-step-forward"></i></li></a>
    </ul>

    <div class="col-md-8">
      <h1>Step 14 - Meteor methods with promises</h1>
    </div>
    <div class="video-tutorial col-md-4">
      <iframe width="300" height="169" src="//www.youtube.com/embed/qNUjZjfaYt8?list=PLhCf3AUOg4PgQoY_A6xWDQ70yaNtPYtZd" frameborder="0" allowfullscreen></iframe>
    </div>

    <do-nothing class="col-md-12">
      {{#markdown}}


In this step we will learn how to use Meteor methods and how angular-meteor enhances them with the support of promises.

Meteor methods are a way to perform more complex logic then the allow method does.
The Meteor methods are responsible for checking permissions, just like the allow method does.

In our case, we will create an invite method that invites a user to a party.

Paste the following code into the end of parties.js file in the model directory:


      Meteor.methods({
        invite: function (partyId, userId) {
          check(partyId, String);
          check(userId, String);
          var party = Parties.findOne(partyId);
            if (!party)
              throw new Meteor.Error(404, "No such party");
            if (party.owner !== this.userId)
              throw new Meteor.Error(404, "No such party");
            if (party.public)
              throw new Meteor.Error(400,
                "That party is public. No need to invite people.");

          if (userId !== party.owner && ! _.contains(party.invited, userId)) {
            Parties.update(partyId, { $addToSet: { invited: userId } });

            var from = contactEmail(Meteor.users.findOne(this.userId));
            var to = contactEmail(Meteor.users.findOne(userId));

            if (Meteor.isServer && to) {
              // This code only runs on the server. If you didn't want clients
              // to be able to see it, you could move it to a separate file.
              Email.send({
                from: "noreply@socially.com",
                to: to,
                replyTo: from || undefined,
                subject: "PARTY: " + party.title,
                text:
                  "Hey, I just invited you to '" + party.title + "' on Socially." +
                  "\n\nCome check it out: " + Meteor.absoluteUrl() + "\n"
              });
            }
          }
        }
      });

      var contactEmail = function (user) {
        if (user.emails && user.emails.length)
          return user.emails[0].address;
        if (user.services && user.services.facebook && user.services.facebook.email)
          return user.services.facebook.email;
        return null;
      };

Let's look at the code.

First, all Meteor methods are defined inside Meteor.methods({}); object.

Each property of that object is a method and the name of that property in the name of the method. in our case - invite.

Then the value of the property is the function we call. in our case it takes 2 parameters - the party id and the invited user id.

First, we check validation with the the [check](http://docs.meteor.com/#check_package) function.

the rest of the code is pretty much self explanatory, but important thing to notice is the Email function that sends email to the invited client.
This function can't be called from the client side so we have to put it inside an isServer statement.

Don't forget to add the email package to your project in the command line:

    meteor add email



Now let's call that method from the client.

Add a scope method called invite:

    $scope.invite = function(user){
      $meteor.call('invite', $scope.party._id, user._id).then(
        function(data){
          console.log('success inviting', data);
        },
        function(err){
          console.log('failed', err);
        }
      );
    };

* Parameter 1 - Meteor method name
* Parameter 2 and 3 - The Meteor method's arguments
* Return value - A promise

The promise we resolve with 'then' which defines 2 parameters:

* Parameter 1 - A function that handles success
* Parameter 2 - A function that handles failure

Now let's add a button to invite each user we want. Edit the users lists in the partyDetails template to look like this:

    <ul>
      Users to invite:
      <li ng-repeat="user in users | uninvited:party">
        <div>{{dstache}} user | displayName }}</div>
        <button ng-click="invite(user)">Invite</button>
      </li>
    </ul>

Now that we have the invite function working, we also want to publish the parties to the invited users.
Let's add that permission to the publish parties method (and the Counts!):

      {$and:[
        {invited: this.userId},
        {invited: {$exists: true}}
      ]}

And the full publish method:

    Meteor.publish("parties", function (options, searchString) {
      if (searchString == null)
        searchString = '';
      Counts.publish(this, 'numberOfParties', Parties.find({
        'name' : { '$regex' : '.*' + searchString || '' + '.*', '$options' : 'i' },
        $or:[
          {$and:[
            {"public": true},
            {"public": {$exists: true}}
          ]},
          {$and:[
            {owner: this.userId},
            {owner: {$exists: true}}
          ]},
          {$and:[
            {invited: this.userId},
            {invited: {$exists: true}}
          ]}
      ]}));
      return Parties.find({
        'name' : { '$regex' : '.*' + searchString || '' + '.*', '$options' : 'i' },
        $or:[
          {$and:[
            {"public": true},
            {"public": {$exists: true}}
          ]},
          {$and:[
            {owner: this.userId},
            {owner: {$exists: true}}
          ]},
          {$and:[
            {invited: this.userId},
            {invited: {$exists: true}}
          ]}
        ]} ,options);
    });

Great!

Now test the app.  create a private party with user1.  then invite user2. log in as user2 and see if he can see the party in his own parties list.


Now let's add the RSVP functionality so invited users can respond to invitations.

First let's add a Meteor.method to parties.js in the model folder (remember to place it as a property inside the Meteor.methods object):

     rsvp: function (partyId, rsvp) {
       check(partyId, String);
       check(rsvp, String);
       if (! this.userId)
         throw new Meteor.Error(403, "You must be logged in to RSVP");
       if (! _.contains(['yes', 'no', 'maybe'], rsvp))
         throw new Meteor.Error(400, "Invalid RSVP");
       var party = Parties.findOne(partyId);
       if (! party)
         throw new Meteor.Error(404, "No such party");
       if (! party.public && party.owner !== this.userId &&
           !_.contains(party.invited, this.userId))
         // private, but let's not tell this to the user
         throw new Meteor.Error(403, "No such party");

       var rsvpIndex = _.indexOf(_.pluck(party.rsvps, 'user'), this.userId);
       if (rsvpIndex !== -1) {
       // update existing rsvp entry

         if (Meteor.isServer) {
           // update the appropriate rsvp entry with $
           Parties.update(
             {_id: partyId, "rsvps.user": this.userId},
             {$set: {"rsvps.$.rsvp": rsvp}});
         } else {
           // minimongo doesn't yet support $ in modifier. as a temporary
           // workaround, make a modifier that uses an index. this is
           // safe on the client since there's only one thread.
           var modifier = {$set: {}};
           modifier.$set["rsvps." + rsvpIndex + ".rsvp"] = rsvp;
           Parties.update(partyId, modifier);
         }
       // Possible improvement: send email to the other people that are
       // coming to the party.
       } else {
         // add new rsvp entry
         Parties.update(partyId,
           {$push: {rsvps: {user: this.userId, rsvp: rsvp}}});
       }
     }

The function gets the party's id and the response ('yes', 'maybe' or 'no').

Like the invite method, first we check for all kinds of validations, then we do the wanted logic.

Now let's call that function from the partiesList.
Add an rsvp scope function to the partiesListCtrl in partiesList.js:

    $scope.rsvp = function(partyId, rsvp){
      $meteor.call('rsvp', partyId, rsvp).then(
        function(data){
          console.log('success responding', data);
        },
        function(err){
          console.log('failed', err);
        }
      );
    };

and let's add action buttons to call the right rsvp in the HTML.

Add this code into `parties-list.ng.html` inside the parties list itself (inside the ng-repeat):

    <div>
      <input type="button" value="I'm going!" ng-click="rsvp(party._id, 'yes')">
      <input type="button" value="Maybe" ng-click="rsvp(party._id, 'maybe')">
      <input type="button" value="No" ng-click="rsvp(party._id, 'no')">
    </div>


Now let's display for each party who is coming.

Just after the code you just added (still inside the parties ng-repeat) add the following code:

    <div>
      Who is coming:
      Yes - {{dstache}} (party.rsvps | filter:{rsvp:'yes'}).length }}
      Maybe - {{dstache}} (party.rsvps | filter:{rsvp:'maybe'}).length }}
      No - {{dstache}} (party.rsvps | filter:{rsvp:'no'}).length }}
      <div ng-repeat="rsvp in party.rsvps | filter:{rsvp:'yes'}">
        {{dstache}} getUserById(rsvp.user) | displayName }} - {{dstache}} rsvp.rsvp }}
      </div>
      <div ng-repeat="rsvp in party.rsvps | filter:{rsvp:'maybe'}">
        {{dstache}} getUserById(rsvp.user) | displayName }} - {{dstache}} rsvp.rsvp }}
      </div>
      <div ng-repeat="rsvp in party.rsvps | filter:{rsvp:'no'}">
        {{dstache}} getUserById(rsvp.user) | displayName }} - {{dstache}} rsvp.rsvp }}
      </div>
    </div>

First, take a look at the use of filter with length to find how many people responded with each response type.

then, look at using ng-repeat inside an ng-repeat - ng-repeat on revps inside party from the parties ng-repeat.

Now let's add a list of the users who haven't responded yet just below the code we just added:

    <ul>
      Users who not responded:
      <li ng-repeat="invitedUser in outstandingInvitations(party)">
        {{dstache}} invitedUser | displayName }}
      </li>
    </ul>

Again, an ng-repeat inside an ng-repeat.  this time we are calling a function the will give us back all the users who haven't responded to that specific party.
add that function inside the partiesListCtrl in the partiesList.js file:

    $scope.outstandingInvitations = function (party) {

      return _.filter($scope.users, function (user) {
        return (_.contains(party.invited, user._id) &&
          !_.findWhere(party.rsvps, {user: user._id}));
      });
    };

here we are using underscore's _.filter, _.contains and _.findWhere to extract the users who are invited to the party but are not exist in the rsvps array.

Notice we are doing this check on $scope.users but we haven't initialized it yet in this controller. so add this code as well:

Change

    $meteor.subscribe('users');

With:

    $scope.users = $meteor.collection(Meteor.users, false).subscribe('users');



# Summary

Run the application.

Looks like we have all the functionality we need but there is a lot of mess in the display.
There are stuff that there is no need for them to show up if the user is not authorized to see or if they are empty.

So in the next chapter we are going to learn about a few simple but very useful AngularJS directive to help us conditionally add or remove DOM.

{{/markdown}}
    </do-nothing>
<div class="col-md-12">
    <ul class="btn-group tutorial-nav">
      <a href="/tutorial/step_13"><li class="btn btn-primary"><i class="glyphicon glyphicon-step-backward"></i> Previous</li></a>
      <a href="http://socially-step14.meteor.com/"><li class="btn btn-primary"><i class="glyphicon glyphicon-play"></i> Live Demo</li></a>
      <a href="https://github.com/Urigo/meteor-angular-socially/compare/step_13...step_14"><li class="btn btn-primary"><i class="glyphicon glyphicon-search"></i> Code Diff</li></a>
      <a href="/tutorial/step_15"><li class="btn btn-primary">Next <i class="glyphicon glyphicon-step-forward"></i></li></a>
    </ul>
    </div>
  </div>
</template>


