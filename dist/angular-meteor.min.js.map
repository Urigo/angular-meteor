{"version":3,"sources":["webpack:///dist/angular-meteor.min.js","webpack:///webpack/bootstrap 39a73188e98df3db7f81","webpack:///./src/angular-meteor.js","webpack:///./src/lib/get-updates.js","webpack:///./src/lib/diff-array.js","webpack:///./src/modules/angular-meteor-ironrouter.js","webpack:///./src/modules/angular-meteor-utils.js","webpack:///./src/modules/angular-meteor-subscribe.js","webpack:///./src/modules/angular-meteor-collection.js","webpack:///./src/modules/angular-meteor-object.js","webpack:///./src/modules/angular-meteor-user.js","webpack:///./src/modules/angular-meteor-methods.js","webpack:///./src/modules/angular-meteor-session.js","webpack:///./src/modules/angular-meteor-camera.js","webpack:///./src/modules/angular-meteor-stopper.js","webpack:///./src/modules/utils.js","webpack:///./src/modules/mixer.js","webpack:///./src/modules/scope.js","webpack:///./src/modules/core.js","webpack:///./src/modules/view-model.js","webpack:///./src/modules/reactive.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Object","defineProperty","value","_utils","_mixer","_scope","_core","_viewModel","_reactive","_module","angular","constant","suppressWarnings","run","Mixer","Core","ViewModel","Reactive","$Mixer","$$Core","$$ViewModel","$$Reactive","mixin","service","$meteorCollection","$meteorCollectionFS","$meteorObject","$meteorMethods","$meteorSession","$meteorSubscribe","$meteorUtils","$meteorCamera","$meteorUser","_this","this","collection","collectionFS","object","subscribe","session","autorun","getCollectionByName","getPicture","forEach","method","utils","rip","obj","level","_","reduce","clone","v","k","isObject","toPaths","keys","getKeyPaths","values","getDeepValues","map","isEmpty","isArray","subKey","flatten","arr","push","setFilled","assert","result","msg","throwErr","Error","getDifference","src","dst","isShallow","compare","srcKeys","dstKeys","chain","concat","uniq","without","diff","srcValue","dstValue","isDate","getTime","valueDiff","getUpdates","paths","set","createSet","unset","createUnset","pull","createPull","updates","undefinedKeys","getUndefinedKeys","omit","pick","arrKeyPaths","split","match","compact","filter","isUndefined","factory","diffArray","lastSeqArray","seqArray","callbacks","preventNestedDiff","diffFn","Package","minimongo","LocalCollection","_diffQueryOrderedChanges","DiffSequence","diffQueryOrderedChanges","oldObjIds","newObjIds","posOld","posNew","posCur","lengthCur","length","each","doc","i","_id","idStringify","addedBefore","before","position","pos","addedAt","movedBefore","prevPosition","movedTo","removed","removedAt","idString","has","idParse","newItem","oldItem","changedAt","_idStringify","MongoID","_idParse","shallow","deepCopyChanges","setDiff","$set","deepKey","setDeep","deepCopyRemovals","unsetDiff","$unset","unsetDeep","getChanges","newCollection","oldCollection","diffMethod","changes","added","changed","item","index","selector","modifier","fromIndex","toIndex","initialKeys","initial","lastKey","last","subObj","nextKey","isNumStr","parseInt","isHash","deepObj","getDeep","splice","getPrototypeOf","prototype","str","$compile","$document","$rootScope","Router","isLoaded","onAfterAction","req","res","next","Tracker","afterFlush","$$phase","$apply","_typeof","Symbol","iterator","constructor","angularMeteorUtils","$q","$timeout","$angularMeteorSettings","self","scope","fn","console","warn","comp","firstRun","noop","$on","stop","stripDollarPrefixedKeys","data","Date","File","EJSON","toJSONValue","$type","FS","out","charAt","fulfill","deferred","boundError","boundResult","err","reject","resolve","promissor","defer","args","toArray","arguments","apply","promise","promiseAll","promises","allPromise","all","string","Mongo","Collection","get","findIndexById","foundDoc","find","colDoc","equals","indexOf","$meteorAutorun","angularMeteorSubscribe","_subscribe","subscription","lastArg","isFunction","onStop","_onStop","pop","onReady","$$state","status","Array","slice","Meteor","angularMeteorCollection","AngularMeteorCollection","curDefFunc","diffArrayFunc","autoClientSave","_serverBackup","_diffArrayFunc","_hObserve","_hNewCurAutorun","_hDataAutorun","isDefined","$$collection","cursor","name","extend","_startCurAutorun","onInvalidate","_stopCursor","_setAutoClientSave","_updateCursor","save","docs","useUnsetModifier","_upsertDoc","createFulfill","partial","docId","isExist","findOne","update","action","insert","_updateDiff","callback","setters","$pull","prop","puller","_updateParallel","done","after","affectedDocsNum","remove","keyOrDocs","keyOrDoc","pluck","check","Match","OneOf","String","ObjectID","key","_removeDoc","_stopObserving","observe","atIndex","_setServerUpdateMode","oldDoc","removedIndex","fetch","_serverMode","_unsetServerUpdateMode","_hUnsetTimeout","_unsetAutoClientSave","cancel","_saveChanges","_hRegAutoBind","$watch","nItems","oItems","addedDocs","reverse","descriptor","removedDocs","reactiveFunc","TypeError","bind","$meteorStopper","scopeProto","angularMeteorObject","AngularMeteorObject","options","helpers","_helpers","create","collectionExtension","$$options","$$id","_getId","$$internalProps","getRawObject","copy","custom","mods","when","reset","keepClientProps","clientProps","docKeys","docExtension","intersection","serverProps","removedKeys","difference","unregisterAutoDestroy","unregisterAutoBind","autorunComputation","fields","reactive","transform","isString","auto","_auto","_setAutos","angularMeteorUser","pack","Accounts","waitForUser","loggingIn","user","requireUser","requireValidUser","validatorFn","then","valid","loginWithPassword","createUser","changePassword","forgotPassword","resetPassword","verifyEmail","logout","logoutOtherClients","loginWithFacebook","loginWithTwitter","loginWithGoogle","loginWithGithub","loginWithMeteorDeveloperAccount","loginWithMeetup","loginWithWeibo","ScopeProto","currentUser","angularMeteorMethods","angularMeteorSession","$parse","model","getter","setter","assign","Session","angularMeteorCamera","MeteorCamera","angularMeteorStopper","$meteorEntity","meteorEntity","$$scope","isCursor","Cursor","isScope","areSiblings","obj1","obj2","context","tap","bindFn","bindObj","_len","_key","bound","_toConsumableArray","arr2","from","_mixins","union","_mixout","_construct","_extend","_ref","undefined","Scope","$new","isolate","parent","firstChild","$$ChildScope","__proto__","$$utils","$bindToContext","computation","$$autoStop","cb","_Meteor","ready","subscriptionId","callMethod","_Meteor2","applyMethod","_Meteor3","_len2","_key2","stoppable","$$throttledDigest","isDigestable","$$destroyed","$root","$digest","$$defer","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","enumerable","configurable","writable","protoProps","staticProps","vm","$$vm","viewModel","proto","boundProto","_this2","_attached","_vm","$$dependencies","Dependency","$$setFnHelper","getReactively","isDeep","isBoolean","$$reactivateEntity","getCollectionReactively","$watchCollection","watcher","watcherArgs","$$watchEntity","depend","getVal","initialVal","val","oldVal","hasChanged","$$changed","_this3","nonreactive","observation","$$handleCursor","$$handleNonCursor","$$setValHelper","_this4","watch","newVal","_this5","jsondiffpatch","patch","$$depend"],"mappings":"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","file":"dist/angular-meteor.min.js","sourcesContent":["/*! angular-meteor v1.3.7-beta.1 */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(9);\n\t\n\t__webpack_require__(10);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\tvar _utils = __webpack_require__(13);\n\t\n\tvar _mixer = __webpack_require__(14);\n\t\n\tvar _scope = __webpack_require__(15);\n\t\n\tvar _core = __webpack_require__(16);\n\t\n\tvar _viewModel = __webpack_require__(17);\n\t\n\tvar _reactive = __webpack_require__(18);\n\t\n\t// new\n\t\n\t// legacy\n\t// lib\n\t\n\t\n\tvar _module = 'angular-meteor';\n\texports.default = _module;\n\t\n\t\n\tangular.module(_module, [\n\t// new\n\t_utils.module, _mixer.module, _scope.module, _core.module, _viewModel.module, _reactive.module,\n\t\n\t// legacy\n\t'angular-meteor.ironrouter', 'angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'angular-meteor.object', 'angular-meteor.user', 'angular-meteor.methods', 'angular-meteor.session', 'angular-meteor.camera']).constant('$angularMeteorSettings', {\n\t  suppressWarnings: false\n\t}).run([_mixer.Mixer, _core.Core, _viewModel.ViewModel, _reactive.Reactive, function ($Mixer, $$Core, $$ViewModel, $$Reactive) {\n\t  // Load all mixins\n\t  $Mixer.mixin($$Core).mixin($$ViewModel).mixin($$Reactive);\n\t}])\n\t\n\t// legacy\n\t// Putting all services under $meteor service for syntactic sugar\n\t.service('$meteor', ['$meteorCollection', '$meteorCollectionFS', '$meteorObject', '$meteorMethods', '$meteorSession', '$meteorSubscribe', '$meteorUtils', '$meteorCamera', '$meteorUser', function ($meteorCollection, $meteorCollectionFS, $meteorObject, $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils, $meteorCamera, $meteorUser) {\n\t  var _this = this;\n\t\n\t  this.collection = $meteorCollection;\n\t  this.collectionFS = $meteorCollectionFS;\n\t  this.object = $meteorObject;\n\t  this.subscribe = $meteorSubscribe.subscribe;\n\t  this.call = $meteorMethods.call;\n\t  this.session = $meteorSession;\n\t  this.autorun = $meteorUtils.autorun;\n\t  this.getCollectionByName = $meteorUtils.getCollectionByName;\n\t  this.getPicture = $meteorCamera.getPicture;\n\t\n\t  // $meteorUser\n\t  ['loginWithPassword', 'requireUser', 'requireValidUser', 'waitForUser', 'createUser', 'changePassword', 'forgotPassword', 'resetPassword', 'verifyEmail', 'loginWithMeteorDeveloperAccount', 'loginWithFacebook', 'loginWithGithub', 'loginWithGoogle', 'loginWithMeetup', 'loginWithTwitter', 'loginWithWeibo', 'logout', 'logoutOtherClients'].forEach(function (method) {\n\t    _this[method] = $meteorUser[method];\n\t  });\n\t}]);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _\r\n\t */\n\t\n\t'use strict';\n\t\n\t// https://github.com/DAB0mB/get-updates\n\t\n\t(function () {\n\t  var module = angular.module('getUpdates', []);\n\t\n\t  var utils = function () {\n\t    var rip = function rip(obj, level) {\n\t      if (level < 1) return {};\n\t\n\t      return _.reduce(obj, function (clone, v, k) {\n\t        v = _.isObject(v) ? rip(v, --level) : v;\n\t        clone[k] = v;\n\t        return clone;\n\t      }, {});\n\t    };\n\t\n\t    var toPaths = function toPaths(obj) {\n\t      var keys = getKeyPaths(obj);\n\t      var values = getDeepValues(obj);\n\t      return _.object(keys, values);\n\t    };\n\t\n\t    var getKeyPaths = function getKeyPaths(obj) {\n\t      var keys = _.keys(obj).map(function (k) {\n\t        var v = obj[k];\n\t        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\n\t\n\t        return getKeyPaths(v).map(function (subKey) {\n\t          return k + '.' + subKey;\n\t        });\n\t      });\n\t\n\t      return _.flatten(keys);\n\t    };\n\t\n\t    var getDeepValues = function getDeepValues(obj, arr) {\n\t      arr = arr || [];\n\t\n\t      _.values(obj).forEach(function (v) {\n\t        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) arr.push(v);else getDeepValues(v, arr);\n\t      });\n\t\n\t      return arr;\n\t    };\n\t\n\t    var flatten = function flatten(arr) {\n\t      return arr.reduce(function (flattened, v, i) {\n\t        if (_.isArray(v) && !_.isEmpty(v)) flattened.push.apply(flattened, flatten(v));else flattened.push(v);\n\t\n\t        return flattened;\n\t      }, []);\n\t    };\n\t\n\t    var setFilled = function setFilled(obj, k, v) {\n\t      if (!_.isEmpty(v)) obj[k] = v;\n\t    };\n\t\n\t    var assert = function assert(result, msg) {\n\t      if (!result) throwErr(msg);\n\t    };\n\t\n\t    var throwErr = function throwErr(msg) {\n\t      throw Error('get-updates error - ' + msg);\n\t    };\n\t\n\t    return {\n\t      rip: rip,\n\t      toPaths: toPaths,\n\t      getKeyPaths: getKeyPaths,\n\t      getDeepValues: getDeepValues,\n\t      setFilled: setFilled,\n\t      assert: assert,\n\t      throwErr: throwErr\n\t    };\n\t  }();\n\t\n\t  var getDifference = function () {\n\t    var getDifference = function getDifference(src, dst, isShallow) {\n\t      var level;\n\t\n\t      if (isShallow > 1) level = isShallow;else if (isShallow) level = 1;\n\t\n\t      if (level) {\n\t        src = utils.rip(src, level);\n\t        dst = utils.rip(dst, level);\n\t      }\n\t\n\t      return compare(src, dst);\n\t    };\n\t\n\t    var compare = function compare(src, dst) {\n\t      var srcKeys = _.keys(src);\n\t      var dstKeys = _.keys(dst);\n\t\n\t      var keys = _.chain([]).concat(srcKeys).concat(dstKeys).uniq().without('$$hashKey').value();\n\t\n\t      return keys.reduce(function (diff, k) {\n\t        var srcValue = src[k];\n\t        var dstValue = dst[k];\n\t\n\t        if (_.isDate(srcValue) && _.isDate(dstValue)) {\n\t          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n\t        }\n\t\n\t        if (_.isObject(srcValue) && _.isObject(dstValue)) {\n\t          var valueDiff = getDifference(srcValue, dstValue);\n\t          utils.setFilled(diff, k, valueDiff);\n\t        } else if (srcValue !== dstValue) {\n\t          diff[k] = dstValue;\n\t        }\n\t\n\t        return diff;\n\t      }, {});\n\t    };\n\t\n\t    return getDifference;\n\t  }();\n\t\n\t  var getUpdates = function () {\n\t    var getUpdates = function getUpdates(src, dst, isShallow) {\n\t      utils.assert(_.isObject(src), 'first argument must be an object');\n\t      utils.assert(_.isObject(dst), 'second argument must be an object');\n\t\n\t      var diff = getDifference(src, dst, isShallow);\n\t      var paths = utils.toPaths(diff);\n\t\n\t      var set = createSet(paths);\n\t      var unset = createUnset(paths);\n\t      var pull = createPull(unset);\n\t\n\t      var updates = {};\n\t      utils.setFilled(updates, '$set', set);\n\t      utils.setFilled(updates, '$unset', unset);\n\t      utils.setFilled(updates, '$pull', pull);\n\t\n\t      return updates;\n\t    };\n\t\n\t    var createSet = function createSet(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      return _.omit(paths, undefinedKeys);\n\t    };\n\t\n\t    var createUnset = function createUnset(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      var unset = _.pick(paths, undefinedKeys);\n\t\n\t      return _.reduce(unset, function (result, v, k) {\n\t        result[k] = true;\n\t        return result;\n\t      }, {});\n\t    };\n\t\n\t    var createPull = function createPull(unset) {\n\t      var arrKeyPaths = _.keys(unset).map(function (k) {\n\t        var split = k.match(/(.*)\\.\\d+$/);\n\t        return split && split[1];\n\t      });\n\t\n\t      return _.compact(arrKeyPaths).reduce(function (pull, k) {\n\t        pull[k] = null;\n\t        return pull;\n\t      }, {});\n\t    };\n\t\n\t    var getUndefinedKeys = function getUndefinedKeys(obj) {\n\t      return _.keys(obj).filter(function (k) {\n\t        var v = obj[k];\n\t        return _.isUndefined(v);\n\t      });\n\t    };\n\t\n\t    return getUpdates;\n\t  }();\n\t\n\t  module.value('getUpdates', getUpdates);\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Package\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar _module = angular.module('diffArray', ['getUpdates']);\n\t\n\t_module.factory('diffArray', ['getUpdates', function (getUpdates) {\n\t  var LocalCollection = Package.minimongo.LocalCollection;\n\t  var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n\t  var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\t\n\t  // Calculates the differences between `lastSeqArray` and\n\t  // `seqArray` and calls appropriate functions from `callbacks`.\n\t  // Reuses Minimongo's diff algorithm implementation.\n\t  // XXX Should be replaced with the original diffArray function here:\n\t  // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n\t  // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n\t  function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n\t    preventNestedDiff = !!preventNestedDiff;\n\t\n\t    var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges || Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\t\n\t    var oldObjIds = [];\n\t    var newObjIds = [];\n\t    var posOld = {}; // maps from idStringify'd ids\n\t    var posNew = {}; // ditto\n\t    var posCur = {};\n\t    var lengthCur = lastSeqArray.length;\n\t\n\t    _.each(seqArray, function (doc, i) {\n\t      newObjIds.push({ _id: doc._id });\n\t      posNew[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    _.each(lastSeqArray, function (doc, i) {\n\t      oldObjIds.push({ _id: doc._id });\n\t      posOld[idStringify(doc._id)] = i;\n\t      posCur[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    // Arrays can contain arbitrary objects. We don't diff the\n\t    // objects. Instead we always fire 'changedAt' callback on every\n\t    // object. The consumer of `observe-sequence` should deal with\n\t    // it appropriately.\n\t    diffFn(oldObjIds, newObjIds, {\n\t      addedBefore: function addedBefore(id, doc, before) {\n\t        var position = before ? posCur[idStringify(before)] : lengthCur;\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= position) posCur[id]++;\n\t        });\n\t\n\t        lengthCur++;\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.addedAt(id, seqArray[posNew[idStringify(id)]], position, before);\n\t      },\n\t\n\t      movedBefore: function movedBefore(id, before) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t        var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition && pos <= position) posCur[id]--;else if (pos <= prevPosition && pos >= position) posCur[id]++;\n\t        });\n\t\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.movedTo(id, seqArray[posNew[idStringify(id)]], prevPosition, position, before);\n\t      },\n\t      removed: function removed(id) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition) posCur[id]--;\n\t        });\n\t\n\t        delete posCur[idStringify(id)];\n\t        lengthCur--;\n\t\n\t        callbacks.removedAt(id, lastSeqArray[posOld[idStringify(id)]], prevPosition);\n\t      }\n\t    });\n\t\n\t    _.each(posNew, function (pos, idString) {\n\t      if (!_.has(posOld, idString)) return;\n\t\n\t      var id = idParse(idString);\n\t      var newItem = seqArray[pos] || {};\n\t      var oldItem = lastSeqArray[posOld[idString]];\n\t      var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n\t\n\t      if (!_.isEmpty(updates)) callbacks.changedAt(id, updates, pos, oldItem);\n\t    });\n\t  }\n\t\n\t  diffArray.shallow = function (lastSeqArray, seqArray, callbacks) {\n\t    return diffArray(lastSeqArray, seqArray, callbacks, true);\n\t  };\n\t\n\t  diffArray.deepCopyChanges = function (oldItem, newItem) {\n\t    var setDiff = getUpdates(oldItem, newItem).$set;\n\t\n\t    _.each(setDiff, function (v, deepKey) {\n\t      setDeep(oldItem, deepKey, v);\n\t    });\n\t  };\n\t\n\t  diffArray.deepCopyRemovals = function (oldItem, newItem) {\n\t    var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\t\n\t    _.each(unsetDiff, function (v, deepKey) {\n\t      unsetDeep(oldItem, deepKey);\n\t    });\n\t  };\n\t\n\t  // Finds changes between two collections\n\t  diffArray.getChanges = function (newCollection, oldCollection, diffMethod) {\n\t    var changes = { added: [], removed: [], changed: [] };\n\t\n\t    diffMethod(oldCollection, newCollection, {\n\t      addedAt: function addedAt(id, item, index) {\n\t        changes.added.push({ item: item, index: index });\n\t      },\n\t\n\t      removedAt: function removedAt(id, item, index) {\n\t        changes.removed.push({ item: item, index: index });\n\t      },\n\t\n\t      changedAt: function changedAt(id, updates, index, oldItem) {\n\t        changes.changed.push({ selector: id, modifier: updates });\n\t      },\n\t\n\t      movedTo: function movedTo(id, item, fromIndex, toIndex) {\n\t        // XXX do we need this?\n\t      }\n\t    });\n\t\n\t    return changes;\n\t  };\n\t\n\t  var setDeep = function setDeep(obj, deepKey, v) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _.initial(split);\n\t    var lastKey = _.last(split);\n\t\n\t    initialKeys.reduce(function (subObj, k, i) {\n\t      var nextKey = split[i + 1];\n\t\n\t      if (isNumStr(nextKey)) {\n\t        if (subObj[k] === null) subObj[k] = [];\n\t        if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n\t      } else if (subObj[k] === null || !isHash(subObj[k])) {\n\t        subObj[k] = {};\n\t      }\n\t\n\t      return subObj[k];\n\t    }, obj);\n\t\n\t    var deepObj = getDeep(obj, initialKeys);\n\t    deepObj[lastKey] = v;\n\t    return v;\n\t  };\n\t\n\t  var unsetDeep = function unsetDeep(obj, deepKey) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _.initial(split);\n\t    var lastKey = _.last(split);\n\t    var deepObj = getDeep(obj, initialKeys);\n\t\n\t    if (_.isArray(deepObj) && isNumStr(lastKey)) return !!deepObj.splice(lastKey, 1);else return delete deepObj[lastKey];\n\t  };\n\t\n\t  var getDeep = function getDeep(obj, keys) {\n\t    return keys.reduce(function (subObj, k) {\n\t      return subObj[k];\n\t    }, obj);\n\t  };\n\t\n\t  var isHash = function isHash(obj) {\n\t    return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n\t  };\n\t\n\t  var isNumStr = function isNumStr(str) {\n\t    return str.match(/^\\d+$/);\n\t  };\n\t\n\t  return diffArray;\n\t}]);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tangular.module('angular-meteor.ironrouter', []).run(['$compile', '$document', '$rootScope', function ($compile, $document, $rootScope) {\n\t  var Router = (Package['iron:router'] || {}).Router;\n\t  if (!Router) return;\n\t\n\t  var isLoaded = false;\n\t\n\t  // Recompile after iron:router builds page\n\t  Router.onAfterAction(function (req, res, next) {\n\t    Tracker.afterFlush(function () {\n\t      if (isLoaded) return;\n\t      $compile($document)($rootScope);\n\t      if (!$rootScope.$$phase) $rootScope.$apply();\n\t      isLoaded = true;\n\t    });\n\t  });\n\t}]);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Tracker, EJSON, FS, Mongo\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar angularMeteorUtils = angular.module('angular-meteor.utils', []);\n\t\n\tangularMeteorUtils.service('$meteorUtils', ['$q', '$timeout', '$angularMeteorSettings', function ($q, $timeout, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this.autorun = function (scope, fn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    // wrapping around Deps.autorun\n\t    var comp = Tracker.autorun(function (c) {\n\t      fn(c);\n\t      // this is run immediately for the first call\n\t      // but after that, we need to $apply to start Angular digest\n\t      if (!c.firstRun) $timeout(angular.noop, 0);\n\t    });\n\t\n\t    // stop autorun when scope is destroyed\n\t    scope.$on('$destroy', function () {\n\t      comp.stop();\n\t    });\n\t\n\t    // return autorun object so that it can be stopped manually\n\t    return comp;\n\t  };\n\t\n\t  // Borrowed from angularFire\n\t  // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n\t  this.stripDollarPrefixedKeys = function (data) {\n\t    if (!_.isObject(data) || data instanceof Date || data instanceof File || EJSON.toJSONValue(data).$type === 'oid' || (typeof FS === 'undefined' ? 'undefined' : _typeof(FS)) === 'object' && data instanceof FS.File) return data;\n\t\n\t    var out = _.isArray(data) ? [] : {};\n\t\n\t    _.each(data, function (v, k) {\n\t      if (typeof k !== 'string' || k.charAt(0) !== '$') out[k] = self.stripDollarPrefixedKeys(v);\n\t    });\n\t\n\t    return out;\n\t  };\n\t\n\t  // Returns a callback which fulfills promise\n\t  this.fulfill = function (deferred, boundError, boundResult) {\n\t    return function (err, result) {\n\t      if (err) deferred.reject(boundError === null ? err : boundError);else if (typeof boundResult == \"function\") deferred.resolve(boundResult === null ? result : boundResult(result));else deferred.resolve(boundResult === null ? result : boundResult);\n\t    };\n\t  };\n\t\n\t  // creates a function which invokes method with the given arguments and returns a promise\n\t  this.promissor = function (obj, method) {\n\t    return function () {\n\t      var deferred = $q.defer();\n\t      var fulfill = self.fulfill(deferred);\n\t      var args = _.toArray(arguments).concat(fulfill);\n\t      obj[method].apply(obj, args);\n\t      return deferred.promise;\n\t    };\n\t  };\n\t\n\t  // creates a $q.all() promise and call digestion loop on fulfillment\n\t  this.promiseAll = function (promises) {\n\t    var allPromise = $q.all(promises);\n\t\n\t    allPromise.finally(function () {\n\t      // calls digestion loop with no conflicts\n\t      $timeout(angular.noop);\n\t    });\n\t\n\t    return allPromise;\n\t  };\n\t\n\t  this.getCollectionByName = function (string) {\n\t    return Mongo.Collection.get(string);\n\t  };\n\t\n\t  this.findIndexById = function (collection, doc) {\n\t    var foundDoc = _.find(collection, function (colDoc) {\n\t      // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n\t      return EJSON.equals(colDoc._id, doc._id);\n\t    });\n\t\n\t    return _.indexOf(collection, foundDoc);\n\t  };\n\t}]);\n\t\n\tangularMeteorUtils.run(['$rootScope', '$meteorUtils', function ($rootScope, $meteorUtils) {\n\t  Object.getPrototypeOf($rootScope).$meteorAutorun = function (fn) {\n\t    return $meteorUtils.autorun(this, fn);\n\t  };\n\t}]);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, Meteor\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', []);\n\t\n\tangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings', function ($q, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this._subscribe = function (scope, deferred, args) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var subscription = null;\n\t    var lastArg = args[args.length - 1];\n\t\n\t    // User supplied onStop callback\n\t    // save it for later use and remove\n\t    // from subscription arguments\n\t    if (angular.isObject(lastArg) && angular.isFunction(lastArg.onStop)) {\n\t      var _onStop = lastArg.onStop;\n\t\n\t      args.pop();\n\t    }\n\t\n\t    args.push({\n\t      onReady: function onReady() {\n\t        deferred.resolve(subscription);\n\t      },\n\t      onStop: function onStop(err) {\n\t        if (!deferred.promise.$$state.status) {\n\t          if (err) deferred.reject(err);else deferred.reject(new Meteor.Error(\"Subscription Stopped\", \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n\t        } else if (_onStop)\n\t          // After promise was resolved or rejected\n\t          // call user supplied onStop callback.\n\t          _onStop.apply(this, Array.prototype.slice.call(arguments));\n\t      }\n\t    });\n\t\n\t    subscription = Meteor.subscribe.apply(scope, args);\n\t\n\t    return subscription;\n\t  };\n\t\n\t  this.subscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var subscription = null;\n\t\n\t    self._subscribe(this, deferred, args);\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\t\n\tangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe', function ($rootScope, $q, $meteorSubscribe) {\n\t  Object.getPrototypeOf($rootScope).$meteorSubscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\t\n\t    this.$on('$destroy', function () {\n\t      subscription.stop();\n\t    });\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Tracker, check, Match, Mongo\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorCollection = angular.module('angular-meteor.collection', ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray']);\n\t\n\t// The reason angular meteor collection is a factory function and not something\n\t// that inherit from array comes from here:\n\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n\t// We went with the direct extensions approach.\n\tangularMeteorCollection.factory('AngularMeteorCollection', ['$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\n\t\n\t  function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var data = [];\n\t    // Server backup data to evaluate what changes come from client\n\t    // after each server update.\n\t    data._serverBackup = [];\n\t    // Array differ function.\n\t    data._diffArrayFunc = diffArrayFunc;\n\t    // Handler of the cursor observer.\n\t    data._hObserve = null;\n\t    // On new cursor autorun handler\n\t    // (autorun for reactive variables).\n\t    data._hNewCurAutorun = null;\n\t    // On new data autorun handler\n\t    // (autorun for cursor.fetch).\n\t    data._hDataAutorun = null;\n\t\n\t    if (angular.isDefined(collection)) {\n\t      data.$$collection = collection;\n\t    } else {\n\t      var cursor = curDefFunc();\n\t      data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n\t    }\n\t\n\t    _.extend(data, AngularMeteorCollection);\n\t    data._startCurAutorun(curDefFunc, autoClientSave);\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorCollection._startCurAutorun = function (curDefFunc, autoClientSave) {\n\t    var self = this;\n\t\n\t    self._hNewCurAutorun = Tracker.autorun(function () {\n\t      // When the reactive func gets recomputated we need to stop any previous\n\t      // observeChanges.\n\t      Tracker.onInvalidate(function () {\n\t        self._stopCursor();\n\t      });\n\t\n\t      if (autoClientSave) self._setAutoClientSave();\n\t      self._updateCursor(curDefFunc(), autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorCollection.save = function (docs, useUnsetModifier) {\n\t    // save whole collection\n\t    if (!docs) docs = this;\n\t    // save single doc\n\t    docs = [].concat(docs);\n\t\n\t    var promises = docs.map(function (doc) {\n\t      return this._upsertDoc(doc, useUnsetModifier);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._upsertDoc = function (doc, useUnsetModifier) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\t\n\t    // delete $$hashkey\n\t    doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n\t    var docId = doc._id;\n\t    var isExist = collection.findOne(docId);\n\t\n\t    // update\n\t    if (isExist) {\n\t      // Deletes _id property (from the copy) so that\n\t      // it can be $set using update.\n\t      delete doc._id;\n\t      var modifier = useUnsetModifier ? { $unset: doc } : { $set: doc };\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      collection.update(docId, modifier, createFulfill(function () {\n\t        return { _id: docId, action: 'updated' };\n\t      }));\n\t    }\n\t    // insert\n\t    else {\n\t        collection.insert(doc, createFulfill(function (id) {\n\t          return { _id: id, action: 'inserted' };\n\t        }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  // performs $pull operations parallely.\n\t  // used for handling splice operations returned from getUpdates() to prevent conflicts.\n\t  // see issue: https://github.com/Urigo/angular-meteor/issues/793\n\t  AngularMeteorCollection._updateDiff = function (selector, update, callback) {\n\t    callback = callback || angular.noop;\n\t    var setters = _.omit(update, '$pull');\n\t    var updates = [setters];\n\t\n\t    _.each(update.$pull, function (pull, prop) {\n\t      var puller = {};\n\t      puller[prop] = pull;\n\t      updates.push({ $pull: puller });\n\t    });\n\t\n\t    this._updateParallel(selector, updates, callback);\n\t  };\n\t\n\t  // performs each update operation parallely\n\t  AngularMeteorCollection._updateParallel = function (selector, updates, callback) {\n\t    var self = this;\n\t    var done = _.after(updates.length, callback);\n\t\n\t    var next = function next(err, affectedDocsNum) {\n\t      if (err) return callback(err);\n\t      done(null, affectedDocsNum);\n\t    };\n\t\n\t    _.each(updates, function (update) {\n\t      self.$$collection.update(selector, update, next);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.remove = function (keyOrDocs) {\n\t    var keys;\n\t\n\t    // remove whole collection\n\t    if (!keyOrDocs) {\n\t      keys = _.pluck(this, '_id');\n\t    }\n\t    // remove docs\n\t    else {\n\t        keyOrDocs = [].concat(keyOrDocs);\n\t\n\t        keys = _.map(keyOrDocs, function (keyOrDoc) {\n\t          return keyOrDoc._id || keyOrDoc;\n\t        });\n\t      }\n\t\n\t    // Checks if all keys are correct.\n\t    check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\t\n\t    var promises = keys.map(function (key) {\n\t      return this._removeDoc(key);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._removeDoc = function (id) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n\t    collection.remove(id, fulfill);\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorCollection._updateCursor = function (cursor, autoClientSave) {\n\t    var self = this;\n\t    // XXX - consider adding an option for a non-orderd result for faster performance\n\t    if (self._hObserve) self._stopObserving();\n\t\n\t    self._hObserve = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        self.splice(atIndex, 0, doc);\n\t        self._serverBackup.splice(atIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        diffArray.deepCopyChanges(self[atIndex], doc);\n\t        diffArray.deepCopyRemovals(self[atIndex], doc);\n\t        self._serverBackup[atIndex] = self[atIndex];\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        self.splice(fromIndex, 1);\n\t        self.splice(toIndex, 0, doc);\n\t        self._serverBackup.splice(fromIndex, 1);\n\t        self._serverBackup.splice(toIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      removedAt: function removedAt(oldDoc) {\n\t        var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\n\t\n\t        if (removedIndex != -1) {\n\t          self.splice(removedIndex, 1);\n\t          self._serverBackup.splice(removedIndex, 1);\n\t          self._setServerUpdateMode();\n\t        } else {\n\t          // If it's been removed on client then it's already not in collection\n\t          // itself but still is in the _serverBackup.\n\t          removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\n\t\n\t          if (removedIndex != -1) {\n\t            self._serverBackup.splice(removedIndex, 1);\n\t          }\n\t        }\n\t      }\n\t    });\n\t\n\t    self._hDataAutorun = Tracker.autorun(function () {\n\t      cursor.fetch();\n\t      if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection._stopObserving = function () {\n\t    this._hObserve.stop();\n\t    this._hDataAutorun.stop();\n\t    delete this._serverMode;\n\t    delete this._hUnsetTimeout;\n\t  };\n\t\n\t  AngularMeteorCollection._setServerUpdateMode = function (name) {\n\t    this._serverMode = true;\n\t    // To simplify server update logic, we don't follow\n\t    // updates from the client at the same time.\n\t    this._unsetAutoClientSave();\n\t  };\n\t\n\t  // Here we use $timeout to combine multiple updates that go\n\t  // each one after another.\n\t  AngularMeteorCollection._unsetServerUpdateMode = function (autoClientSave) {\n\t    var self = this;\n\t\n\t    if (self._hUnsetTimeout) {\n\t      $timeout.cancel(self._hUnsetTimeout);\n\t      self._hUnsetTimeout = null;\n\t    }\n\t\n\t    self._hUnsetTimeout = $timeout(function () {\n\t      self._serverMode = false;\n\t      // Finds updates that was potentially done from the client side\n\t      // and saves them.\n\t      var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\n\t      self._saveChanges(changes);\n\t      // After, continues following client updates.\n\t      if (autoClientSave) self._setAutoClientSave();\n\t    }, 0);\n\t  };\n\t\n\t  AngularMeteorCollection.stop = function () {\n\t    this._stopCursor();\n\t    this._hNewCurAutorun.stop();\n\t  };\n\t\n\t  AngularMeteorCollection._stopCursor = function () {\n\t    this._unsetAutoClientSave();\n\t\n\t    if (this._hObserve) {\n\t      this._hObserve.stop();\n\t      this._hDataAutorun.stop();\n\t    }\n\t\n\t    this.splice(0);\n\t    this._serverBackup.splice(0);\n\t  };\n\t\n\t  AngularMeteorCollection._unsetAutoClientSave = function (name) {\n\t    if (this._hRegAutoBind) {\n\t      this._hRegAutoBind();\n\t      this._hRegAutoBind = null;\n\t    }\n\t  };\n\t\n\t  AngularMeteorCollection._setAutoClientSave = function () {\n\t    var self = this;\n\t\n\t    // Always unsets auto save to keep only one $watch handler.\n\t    self._unsetAutoClientSave();\n\t\n\t    self._hRegAutoBind = $rootScope.$watch(function () {\n\t      return self;\n\t    }, function (nItems, oItems) {\n\t      if (nItems === oItems) return;\n\t\n\t      var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\n\t      self._unsetAutoClientSave();\n\t      self._saveChanges(changes);\n\t      self._setAutoClientSave();\n\t    }, true);\n\t  };\n\t\n\t  AngularMeteorCollection._saveChanges = function (changes) {\n\t    var self = this;\n\t\n\t    // Saves added documents\n\t    // Using reversed iteration to prevent indexes from changing during splice\n\t    var addedDocs = changes.added.reverse().map(function (descriptor) {\n\t      self.splice(descriptor.index, 1);\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (addedDocs.length) self.save(addedDocs);\n\t\n\t    // Removes deleted documents\n\t    var removedDocs = changes.removed.map(function (descriptor) {\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (removedDocs.length) self.remove(removedDocs);\n\t\n\t    // Updates changed documents\n\t    changes.changed.forEach(function (descriptor) {\n\t      self._updateDiff(descriptor.selector, descriptor.modifier);\n\t    });\n\t  };\n\t\n\t  return AngularMeteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollectionFS', ['$meteorCollection', 'diffArray', '$angularMeteorSettings', function ($meteorCollection, diffArray, $angularMeteorSettings) {\n\t  function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n\t\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\n\t  }\n\t\n\t  return $meteorCollectionFS;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollection', ['AngularMeteorCollection', '$rootScope', 'diffArray', function (AngularMeteorCollection, $rootScope, diffArray) {\n\t  function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\n\t    // Validate parameters\n\t    if (!reactiveFunc) {\n\t      throw new TypeError('The first argument of $meteorCollection is undefined.');\n\t    }\n\t\n\t    if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n\t      throw new TypeError('The first argument of $meteorCollection must be a function or ' + 'a have a find function property.');\n\t    }\n\t\n\t    if (!angular.isFunction(reactiveFunc)) {\n\t      collection = angular.isDefined(collection) ? collection : reactiveFunc;\n\t      reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\n\t    }\n\t\n\t    // By default auto save - true.\n\t    autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n\t    diffFn = diffFn || diffArray;\n\t    return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\n\t  }\n\t\n\t  return $meteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.run(['$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper', function ($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n\t  scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n\t}]);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t  angular, _, Mongo\r\n\t*/\n\t\n\t'use strict';\n\t\n\tvar angularMeteorObject = angular.module('angular-meteor.object', ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray']);\n\t\n\tangularMeteorObject.factory('AngularMeteorObject', ['$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\n\t\n\t  // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n\t  AngularMeteorObject.$$internalProps = ['$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope', 'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject', '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'];\n\t\n\t  function AngularMeteorObject(collection, selector, options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    // Make data not be an object so we can extend it to preserve\n\t    // Collection Helpers and the like\n\t    var helpers = collection._helpers;\n\t    var data = _.isFunction(helpers) ? Object.create(helpers.prototype) : {};\n\t    var doc = collection.findOne(selector, options);\n\t    var collectionExtension = _.pick(AngularMeteorCollection, '_updateParallel');\n\t    _.extend(data, doc);\n\t    _.extend(data, AngularMeteorObject);\n\t    _.extend(data, collectionExtension);\n\t\n\t    // Omit options that may spoil document finding\n\t    data.$$options = _.omit(options, 'skip', 'limit');\n\t    data.$$collection = collection;\n\t    data.$$id = data._getId(selector);\n\t    data._serverBackup = doc || {};\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorObject.getRawObject = function () {\n\t    return angular.copy(_.omit(this, this.$$internalProps));\n\t  };\n\t\n\t  AngularMeteorObject.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorObject.save = function (custom) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\t    var oldDoc = collection.findOne(this.$$id);\n\t    var mods;\n\t\n\t    // update\n\t    if (oldDoc) {\n\t      if (custom) mods = { $set: custom };else {\n\t        mods = getUpdates(oldDoc, this.getRawObject());\n\t        // If there are no updates, there is nothing to do here, returning\n\t        if (_.isEmpty(mods)) {\n\t          return $q.when({ action: 'updated' });\n\t        }\n\t      }\n\t\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      this._updateDiff(mods, createFulfill({ action: 'updated' }));\n\t    }\n\t    // insert\n\t    else {\n\t        if (custom) mods = _.clone(custom);else mods = this.getRawObject();\n\t\n\t        mods._id = mods._id || this.$$id;\n\t        collection.insert(mods, createFulfill({ action: 'inserted' }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorObject._updateDiff = function (update, callback) {\n\t    var selector = this.$$id;\n\t    AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\n\t  };\n\t\n\t  AngularMeteorObject.reset = function (keepClientProps) {\n\t    var self = this;\n\t    var options = this.$$options;\n\t    var id = this.$$id;\n\t    var doc = this.$$collection.findOne(id, options);\n\t\n\t    if (doc) {\n\t      // extend SubObject\n\t      var docKeys = _.keys(doc);\n\t      var docExtension = _.pick(doc, docKeys);\n\t      var clientProps;\n\t\n\t      _.extend(self, docExtension);\n\t      _.extend(self._serverBackup, docExtension);\n\t\n\t      if (keepClientProps) {\n\t        clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\n\t      } else {\n\t        clientProps = _.keys(self);\n\t      }\n\t\n\t      var serverProps = _.keys(doc);\n\t      var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\n\t\n\t      removedKeys.forEach(function (prop) {\n\t        delete self[prop];\n\t        delete self._serverBackup[prop];\n\t      });\n\t    } else {\n\t      _.keys(this.getRawObject()).forEach(function (prop) {\n\t        delete self[prop];\n\t      });\n\t\n\t      self._serverBackup = {};\n\t    }\n\t  };\n\t\n\t  AngularMeteorObject.stop = function () {\n\t    if (this.unregisterAutoDestroy) this.unregisterAutoDestroy();\n\t\n\t    if (this.unregisterAutoBind) this.unregisterAutoBind();\n\t\n\t    if (this.autorunComputation && this.autorunComputation.stop) this.autorunComputation.stop();\n\t  };\n\t\n\t  AngularMeteorObject._getId = function (selector) {\n\t    var options = _.extend({}, this.$$options, {\n\t      fields: { _id: 1 },\n\t      reactive: false,\n\t      transform: null\n\t    });\n\t\n\t    var doc = this.$$collection.findOne(selector, options);\n\t\n\t    if (doc) return doc._id;\n\t    if (selector instanceof Mongo.ObjectID) return selector;\n\t    if (_.isString(selector)) return selector;\n\t    return new Mongo.ObjectID();\n\t  };\n\t\n\t  return AngularMeteorObject;\n\t}]);\n\t\n\tangularMeteorObject.factory('$meteorObject', ['$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject', function ($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n\t  function $meteorObject(collection, id, auto, options) {\n\t    // Validate parameters\n\t    if (!collection) {\n\t      throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n\t    }\n\t\n\t    if (!angular.isFunction(collection.findOne)) {\n\t      throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n\t    }\n\t\n\t    var data = new AngularMeteorObject(collection, id, options);\n\t    // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n\t    data._auto = auto !== false;\n\t    _.extend(data, $meteorObject);\n\t    data._setAutos();\n\t    return data;\n\t  }\n\t\n\t  $meteorObject._setAutos = function () {\n\t    var self = this;\n\t\n\t    this.autorunComputation = $meteorUtils.autorun($rootScope, function () {\n\t      self.reset(true);\n\t    });\n\t\n\t    // Deep watches the model and performs autobind\n\t    this.unregisterAutoBind = this._auto && $rootScope.$watch(function () {\n\t      return self.getRawObject();\n\t    }, function (item, oldItem) {\n\t      if (item !== oldItem) self.save();\n\t    }, true);\n\t\n\t    this.unregisterAutoDestroy = $rootScope.$on('$destroy', function () {\n\t      if (self && self.stop) self.pop();\n\t    });\n\t  };\n\t\n\t  return $meteorObject;\n\t}]);\n\t\n\tangularMeteorObject.run(['$rootScope', '$meteorObject', '$meteorStopper', function ($rootScope, $meteorObject, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorObject = $meteorStopper($meteorObject);\n\t}]);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Package, Meteor\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorUser = angular.module('angular-meteor.user', ['angular-meteor.utils', 'angular-meteor.core']);\n\t\n\t// requires package 'accounts-password'\n\tangularMeteorUser.service('$meteorUser', ['$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings', function ($rootScope, $meteorUtils, $q, $angularMeteorSettings) {\n\t\n\t  var pack = Package['accounts-base'];\n\t  if (!pack) return;\n\t\n\t  var self = this;\n\t  var Accounts = pack.Accounts;\n\t\n\t  this.waitForUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) deferred.resolve(Meteor.user());\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) {\n\t      console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    }\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) {\n\t        if (Meteor.user() === null) deferred.reject(\"AUTH_REQUIRED\");else deferred.resolve(Meteor.user());\n\t      }\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireValidUser = function (validatorFn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    return self.requireUser(true).then(function (user) {\n\t      var valid = validatorFn(user);\n\t\n\t      if (valid === true) return user;else if (typeof valid === \"string\") return $q.reject(valid);else return $q.reject(\"FORBIDDEN\");\n\t    });\n\t  };\n\t\n\t  this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n\t  this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n\t  this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n\t  this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n\t  this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n\t  this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n\t  this.logout = $meteorUtils.promissor(Meteor, 'logout');\n\t  this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n\t  this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n\t  this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n\t  this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n\t  this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n\t  this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n\t  this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n\t  this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n\t}]);\n\t\n\tangularMeteorUser.run(['$rootScope', '$angularMeteorSettings', '$$Core', function ($rootScope, $angularMeteorSettings, $$Core) {\n\t\n\t  var ScopeProto = Object.getPrototypeOf($rootScope);\n\t  _.extend(ScopeProto, $$Core);\n\t\n\t  $rootScope.autorun(function () {\n\t    if (!Meteor.user) return;\n\t    $rootScope.currentUser = Meteor.user();\n\t    $rootScope.loggingIn = Meteor.loggingIn();\n\t  });\n\t}]);\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, _, Meteor\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils']);\n\t\n\tangularMeteorMethods.service('$meteorMethods', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  this.call = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t    var fulfill = $meteorUtils.fulfill(deferred);\n\t    var args = _.toArray(arguments).concat(fulfill);\n\t    Meteor.call.apply(this, args);\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, Session\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils']);\n\t\n\tangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings', function ($meteorUtils, $parse, $angularMeteorSettings) {\n\t  return function (session) {\n\t\n\t    return {\n\t\n\t      bind: function bind(scope, model) {\n\t        if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t        var getter = $parse(model);\n\t        var setter = getter.assign;\n\t        $meteorUtils.autorun(scope, function () {\n\t          setter(scope, Session.get(session));\n\t        });\n\t\n\t        scope.$watch(model, function (newItem, oldItem) {\n\t          Session.set(session, getter(scope));\n\t        }, true);\n\t      }\n\t    };\n\t  };\n\t}]);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular, Package\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils']);\n\t\n\t// requires package 'mdg:camera'\n\tangularMeteorCamera.service('$meteorCamera', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t  var pack = Package['mdg:camera'];\n\t  if (!pack) return;\n\t\n\t  var MeteorCamera = pack.MeteorCamera;\n\t\n\t  this.getPicture = function (options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    options = options || {};\n\t    var deferred = $q.defer();\n\t    MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/*global\r\n\t angular\r\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorStopper = angular.module('angular-meteor.stopper', ['angular-meteor.subscribe']);\n\t\n\tangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe', function ($q, $meteorSubscribe) {\n\t  function $meteorStopper($meteorEntity) {\n\t    return function () {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var meteorEntity = $meteorEntity.apply(this, args);\n\t\n\t      angular.extend(meteorEntity, $meteorStopper);\n\t      meteorEntity.$$scope = this;\n\t\n\t      this.$on('$destroy', function () {\n\t        meteorEntity.stop();\n\t        if (meteorEntity.subscription) meteorEntity.subscription.stop();\n\t      });\n\t\n\t      return meteorEntity;\n\t    };\n\t  }\n\t\n\t  $meteorStopper.subscribe = function () {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\n\t    return this;\n\t  };\n\t\n\t  return $meteorStopper;\n\t}]);\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _module = 'angular-meteor.utilities';\n\texports.module = _module;\n\tvar utils = exports.utils = '$$utils';\n\t\n\tangular.module(_module, [])\n\t\n\t/*\n\t  A utility service which is provided with general utility functions\n\t */\n\t.service(utils, ['$rootScope', function ($rootScope) {\n\t  var _this = this;\n\t\n\t  // Checks if an object is a cursor\n\t  this.isCursor = function (obj) {\n\t    return obj instanceof Meteor.Collection.Cursor;\n\t  };\n\t\n\t  // Cheecks if an object is a scope\n\t  this.isScope = function (obj) {\n\t    return obj instanceof $rootScope.constructor;\n\t  };\n\t\n\t  // Checks if two objects are siblings\n\t  this.areSiblings = function (obj1, obj2) {\n\t    return _.isObject(obj1) && _.isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t  };\n\t\n\t  // Binds function into a scpecified context. If an object is provided, will bind every\n\t  // value in the object which is a function. If a tap function is provided, it will be\n\t  // called right after the function has been invoked.\n\t  this.bind = function (fn, context, tap) {\n\t    tap = _.isFunction(tap) ? tap : angular.noop;\n\t    if (_.isFunction(fn)) return bindFn(fn, context, tap);\n\t    if (_.isObject(fn)) return bindObj(fn, context, tap);\n\t    return fn;\n\t  };\n\t\n\t  var bindFn = function bindFn(fn, context, tap) {\n\t    return function () {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      var result = fn.apply(context, args);\n\t      tap.call(context, {\n\t        result: result,\n\t        args: args\n\t      });\n\t      return result;\n\t    };\n\t  };\n\t\n\t  var bindObj = function bindObj(obj, context, tap) {\n\t    return _.keys(obj).reduce(function (bound, k) {\n\t      bound[k] = _this.bind(obj[k], context, tap);\n\t      return bound;\n\t    }, {});\n\t  };\n\t}]);\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar _module = 'angular-meteor.mixer';\n\texports.module = _module;\n\tvar Mixer = exports.Mixer = '$Mixer';\n\t\n\tangular.module(_module, [])\n\t\n\t/*\n\t  A service which lets us apply mixins into the `ChildScope` prototype.\n\t  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n\t  and any time a `ChildScope` prototype is created\n\t  it will be extended by the `$Mixer`.\n\t  This concept is good because it keeps our code\n\t  clean and simple, and easy to extend.\n\t  So any time we would like to define a new behaviour to our scope,\n\t  we will just use the `$Mixer` service.\n\t */\n\t.service(Mixer, function () {\n\t  var _this = this;\n\t\n\t  this._mixins = [];\n\t\n\t  // Adds a new mixin\n\t  this.mixin = function (mixin) {\n\t    if (!_.isObject(mixin)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    _this._mixins = _.union(_this._mixins, [mixin]);\n\t    return _this;\n\t  };\n\t\n\t  // Removes a mixin. Useful mainly for test purposes\n\t  this._mixout = function (mixin) {\n\t    _this._mixins = _.without(_this._mixins, mixin);\n\t    return _this;\n\t  };\n\t\n\t  // Invoke function mixins with the provided context and arguments\n\t  this._construct = function (context) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    _this._mixins.filter(_.isFunction).forEach(function (mixin) {\n\t      mixin.call.apply(mixin, [context].concat(args));\n\t    });\n\t\n\t    return context;\n\t  };\n\t\n\t  // Extend prototype with the defined mixins\n\t  this._extend = function (obj) {\n\t    var _ref;\n\t\n\t    return (_ref = _).extend.apply(_ref, [obj].concat(_toConsumableArray(_this._mixins)));\n\t  };\n\t});\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.module = undefined;\n\t\n\tvar _mixer = __webpack_require__(14);\n\t\n\tvar _module = 'angular-meteor.scope';\n\t\n\texports.module = _module;\n\tangular.module(_module, [_mixer.module]).run(['$rootScope', _mixer.Mixer, function ($rootScope, $Mixer) {\n\t  var Scope = $rootScope.constructor;\n\t  var $new = $rootScope.$new;\n\t\n\t  // Extends and constructs every newly created scope without affecting the root scope\n\t  Scope.prototype.$new = function (isolate, parent) {\n\t    var firstChild = this === $rootScope && !this.$$ChildScope;\n\t    var scope = $new.call(this, isolate, parent);\n\t\n\t    // If the scope is isolated we would like to extend it aswell\n\t    if (isolate) {\n\t      // The scope is the prototype of its upcomming child scopes, so the methods would\n\t      // be accessable to them as well\n\t      $Mixer._extend(scope);\n\t    }\n\t    // Else, if this is the first child of the root scope we would like to apply the extensions\n\t    // without affection the root scope\n\t    else if (firstChild) {\n\t        // Creating a middle layer where all the extensions are gonna be applied to\n\t        scope.__proto__ = this.$$ChildScope.prototype = $Mixer._extend(Object.create(this));\n\t      }\n\t\n\t    return $Mixer._construct(scope);\n\t  };\n\t}]);\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Core = exports.module = undefined;\n\t\n\tvar _utils = __webpack_require__(13);\n\t\n\tvar _mixer = __webpack_require__(14);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar _module = 'angular-meteor.core';\n\texports.module = _module;\n\tvar Core = exports.Core = '$$Core';\n\t\n\tangular.module(_module, [_utils.module, _mixer.module])\n\t\n\t/*\n\t  A mixin which provides us with core Meteor functions.\n\t */\n\t.factory(Core, ['$q', _utils.utils, function ($q, $$utils) {\n\t  function $$Core() {}\n\t\n\t  // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n\t  $$Core.autorun = function (fn) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    fn = this.$bindToContext(fn);\n\t\n\t    if (!_.isFunction(fn)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t    if (!_.isObject(options)) {\n\t      throw Error('argument 2 must be an object');\n\t    }\n\t\n\t    var computation = Tracker.autorun(fn, options);\n\t    this.$$autoStop(computation);\n\t    return computation;\n\t  };\n\t\n\t  // Calls Meteor.subscribe() which will be digested after each invokation\n\t  // and automatically destroyed\n\t  $$Core.subscribe = function (name, fn, cb) {\n\t    fn = this.$bindToContext(fn || angular.noop);\n\t    cb = cb ? this.$bindToContext(cb) : angular.noop;\n\t\n\t    if (!_.isString(name)) {\n\t      throw Error('argument 1 must be a string');\n\t    }\n\t    if (!_.isFunction(fn)) {\n\t      throw Error('argument 2 must be a function');\n\t    }\n\t    if (!_.isFunction(cb) && !_.isObject(cb)) {\n\t      throw Error('argument 3 must be a function or an object');\n\t    }\n\t\n\t    var result = {};\n\t\n\t    var computation = this.autorun(function () {\n\t      var _Meteor;\n\t\n\t      var args = fn();\n\t      if (angular.isUndefined(args)) args = [];\n\t\n\t      if (!_.isArray(args)) {\n\t        throw Error('reactive function\\'s return value must be an array');\n\t      }\n\t\n\t      var subscription = (_Meteor = Meteor).subscribe.apply(_Meteor, [name].concat(_toConsumableArray(args), [cb]));\n\t      result.ready = subscription.ready.bind(subscription);\n\t      result.subscriptionId = subscription.subscriptionId;\n\t    });\n\t\n\t    // Once the computation has been stopped,\n\t    // any subscriptions made inside will be stopped as well\n\t    result.stop = computation.stop.bind(computation);\n\t    return result;\n\t  };\n\t\n\t  // Calls Meteor.call() wrapped by a digestion cycle\n\t  $$Core.callMethod = function () {\n\t    var _Meteor2;\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n\t    return (_Meteor2 = Meteor).call.apply(_Meteor2, args.concat([fn]));\n\t  };\n\t\n\t  // Calls Meteor.apply() wrapped by a digestion cycle\n\t  $$Core.applyMethod = function () {\n\t    var _Meteor3;\n\t\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n\t    return (_Meteor3 = Meteor).apply.apply(_Meteor3, args.concat([fn]));\n\t  };\n\t\n\t  $$Core.$$autoStop = function (stoppable) {\n\t    this.$on('$destroy', stoppable.stop.bind(stoppable));\n\t  };\n\t\n\t  // Digests scope only if there is no phase at the moment\n\t  $$Core.$$throttledDigest = function () {\n\t    var isDigestable = !this.$$destroyed && !this.$$phase && !this.$root.$$phase;\n\t\n\t    if (isDigestable) this.$digest();\n\t  };\n\t\n\t  // Creates a promise only that the digestion cycle will be called at its fulfillment\n\t  $$Core.$$defer = function () {\n\t    var deferred = $q.defer();\n\t    // Once promise has been fulfilled, digest\n\t    deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n\t    return deferred;\n\t  };\n\t\n\t  // Binds an object or a function to the scope to the view model and digest it once it is invoked\n\t  $$Core.$bindToContext = function (fn) {\n\t    return $$utils.bind(fn, this, this.$$throttledDigest.bind(this));\n\t  };\n\t\n\t  return $$Core;\n\t}]);\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.reactive = exports.ViewModel = exports.module = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(13);\n\t\n\tvar _mixer = __webpack_require__(14);\n\t\n\tvar _core = __webpack_require__(16);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _module = 'angular-meteor.view-model';\n\texports.module = _module;\n\tvar ViewModel = exports.ViewModel = '$$ViewModel';\n\tvar reactive = exports.reactive = '$reactive';\n\t\n\tangular.module(_module, [_utils.module, _mixer.module, _core.module])\n\t\n\t/*\n\t  A mixin which lets us bind a view model into a scope.\n\t  Note that only a single view model can be bound,\n\t  otherwise the scope might behave unexpectedly.\n\t  Mainly used to define the controller as the view model,\n\t  and very useful when wanting to use Angular's `controllerAs` syntax.\n\t */\n\t.factory(ViewModel, [_utils.utils, _mixer.Mixer, function ($$utils, $Mixer) {\n\t  function $$ViewModel() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // Defines the view model on the scope.\n\t    this.$$vm = vm;\n\t  }\n\t\n\t  // Gets an object, wraps it with scope functions and returns it\n\t  $$ViewModel.viewModel = function (vm) {\n\t    var _this = this;\n\t\n\t    if (!_.isObject(vm)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    // Apply mixin functions\n\t    $Mixer._mixins.forEach(function (mixin) {\n\t      // Reject methods which starts with double $\n\t      var keys = _.keys(mixin).filter(function (k) {\n\t        return k.match(/^(?!\\$\\$).*$/);\n\t      });\n\t      var proto = _.pick(mixin, keys);\n\t      // Bind all the methods to the prototype\n\t      var boundProto = $$utils.bind(proto, _this);\n\t      // Add the methods to the view model\n\t      _.extend(vm, boundProto);\n\t    });\n\t\n\t    // Apply mixin constructors on the view model\n\t    $Mixer._construct(this, vm);\n\t    return vm;\n\t  };\n\t\n\t  // Override $$Core.$bindToContext to be bound to view model instead of scope\n\t  $$ViewModel.$bindToContext = function (fn) {\n\t    return $$utils.bind(fn, this.$$vm, this.$$throttledDigest.bind(this));\n\t  };\n\t\n\t  return $$ViewModel;\n\t}])\n\t\n\t/*\n\t  Illustrates the old API where a view model is created using $reactive service\n\t */\n\t.service(reactive, [_utils.utils, function ($$utils) {\n\t  var Reactive = function () {\n\t    function Reactive(vm) {\n\t      var _this2 = this;\n\t\n\t      _classCallCheck(this, Reactive);\n\t\n\t      if (!_.isObject(vm)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\t\n\t      _.defer(function () {\n\t        if (!_this2._attached) {\n\t          console.warn('view model was not attached to any scope');\n\t        }\n\t      });\n\t\n\t      this._vm = vm;\n\t    }\n\t\n\t    _createClass(Reactive, [{\n\t      key: 'attach',\n\t      value: function attach(scope) {\n\t        this._attached = true;\n\t\n\t        if (!$$utils.isScope(scope)) {\n\t          throw Error('argument 1 must be a scope');\n\t        }\n\t\n\t        var viewModel = scope.viewModel(this._vm);\n\t\n\t        // Similar to the old/Meteor API\n\t        viewModel.call = viewModel.callMethod;\n\t        viewModel.apply = viewModel.applyMethod;\n\t\n\t        return viewModel;\n\t      }\n\t    }]);\n\t\n\t    return Reactive;\n\t  }();\n\t\n\t  return function (vm) {\n\t    return new Reactive(vm);\n\t  };\n\t}]);\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Reactive = exports.module = undefined;\n\t\n\tvar _utils = __webpack_require__(13);\n\t\n\tvar _mixer = __webpack_require__(14);\n\t\n\tvar _core = __webpack_require__(16);\n\t\n\tvar _viewModel = __webpack_require__(17);\n\t\n\tvar _module = 'angular-meteor.reactive';\n\texports.module = _module;\n\tvar Reactive = exports.Reactive = '$$Reactive';\n\t\n\tangular.module(_module, [_utils.module, _mixer.module, _core.module, _viewModel.module])\n\t\n\t/*\n\t  A mixin which enhance our reactive abilities by providing methods\n\t  that are capable of updating our scope reactively.\n\t */\n\t.factory(Reactive, ['$parse', _utils.utils, '$angularMeteorSettings', function ($parse, $$utils, $angularMeteorSettings) {\n\t  function $$Reactive() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // Helps us track changes made in the view model\n\t    vm.$$dependencies = {};\n\t  }\n\t\n\t  // Gets an object containing functions and define their results as reactive properties.\n\t  // Once a return value has been changed the property will be reset.\n\t  $$Reactive.helpers = function () {\n\t    var _this = this;\n\t\n\t    var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    if (!_.isObject(props)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    _.each(props, function (v, k, i) {\n\t      if (!_.isFunction(v)) {\n\t        throw Error('helper ' + (i + 1) + ' must be a function');\n\t      }\n\t\n\t      if (!_this.$$vm.$$dependencies[k]) {\n\t        // Registers a new dependency to the specified helper\n\t        _this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n\t      }\n\t\n\t      _this.$$setFnHelper(k, v);\n\t    });\n\t  };\n\t\n\t  // Gets a model reactively\n\t  $$Reactive.getReactively = function (k) {\n\t    var isDeep = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t    if (!_.isBoolean(isDeep)) {\n\t      throw Error('argument 2 must be a boolean');\n\t    }\n\t\n\t    return this.$$reactivateEntity(k, this.$watch, isDeep);\n\t  };\n\t\n\t  // Gets a collection reactively\n\t  $$Reactive.getCollectionReactively = function (k) {\n\t    return this.$$reactivateEntity(k, this.$watchCollection);\n\t  };\n\t\n\t  // Gets an entity reactively, and once it has been changed the computation will be recomputed\n\t  $$Reactive.$$reactivateEntity = function (k, watcher) {\n\t    if (!_.isString(k)) {\n\t      throw Error('argument 1 must be a string');\n\t    }\n\t\n\t    if (!this.$$vm.$$dependencies[k]) {\n\t      this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n\t\n\t      for (var _len = arguments.length, watcherArgs = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t        watcherArgs[_key - 2] = arguments[_key];\n\t      }\n\t\n\t      this.$$watchEntity.apply(this, [k, watcher].concat(watcherArgs));\n\t    }\n\t\n\t    this.$$vm.$$dependencies[k].depend();\n\t    return $parse(k)(this.$$vm);\n\t  };\n\t\n\t  // Watches for changes in the view model, and if so will notify a change\n\t  $$Reactive.$$watchEntity = function (k, watcher) {\n\t    var _this2 = this;\n\t\n\t    // Gets a deep property from the view model\n\t    var getVal = _.partial($parse(k), this.$$vm);\n\t    var initialVal = getVal();\n\t\n\t    // Watches for changes in the view model\n\t\n\t    for (var _len2 = arguments.length, watcherArgs = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n\t      watcherArgs[_key2 - 2] = arguments[_key2];\n\t    }\n\t\n\t    watcher.call.apply(watcher, [this, getVal, function (val, oldVal) {\n\t      var hasChanged = val !== initialVal || val !== oldVal;\n\t\n\t      // Notify if a change has been detected\n\t      if (hasChanged) _this2.$$changed(k);\n\t    }].concat(watcherArgs));\n\t  };\n\t\n\t  // Invokes a function and sets the return value as a property\n\t  $$Reactive.$$setFnHelper = function (k, fn) {\n\t    var _this3 = this;\n\t\n\t    this.autorun(function (computation) {\n\t      // Invokes the reactive functon\n\t      var model = fn.apply(_this3.$$vm);\n\t\n\t      // Ignore notifications made by the following handler\n\t      Tracker.nonreactive(function () {\n\t        // If a cursor, observe its changes and update acoordingly\n\t        if ($$utils.isCursor(model)) {\n\t          (function () {\n\t            var observation = _this3.$$handleCursor(k, model);\n\t\n\t            computation.onInvalidate(function () {\n\t              observation.stop();\n\t              _this3.$$vm[k].splice(0);\n\t            });\n\t          })();\n\t        } else {\n\t          _this3.$$handleNonCursor(k, model);\n\t        }\n\t\n\t        // Notify change and update the view model\n\t        _this3.$$changed(k);\n\t      });\n\t    });\n\t  };\n\t\n\t  // Sets a value helper as a setter and a getter which will notify computations once used\n\t  $$Reactive.$$setValHelper = function (k, v) {\n\t    var _this4 = this;\n\t\n\t    var watch = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];\n\t\n\t    // If set, reactives property\n\t    if (watch) {\n\t      var isDeep = _.isObject(v);\n\t      this.getReactively(k, isDeep);\n\t    }\n\t\n\t    Object.defineProperty(this.$$vm, k, {\n\t      configurable: true,\n\t      enumerable: true,\n\t\n\t      get: function get() {\n\t        return v;\n\t      },\n\t      set: function set(newVal) {\n\t        v = newVal;\n\t        _this4.$$changed(k);\n\t      }\n\t    });\n\t  };\n\t\n\t  // Fetching a cursor and updates properties once the result set has been changed\n\t  $$Reactive.$$handleCursor = function (k, cursor) {\n\t    var _this5 = this;\n\t\n\t    // If not defined set it\n\t    if (angular.isUndefined(this.$$vm[k])) {\n\t      this.$$setValHelper(k, cursor.fetch(), false);\n\t    }\n\t    // If defined update it\n\t    else {\n\t        var diff = jsondiffpatch.diff(this.$$vm[k], cursor.fetch());\n\t        jsondiffpatch.patch(this.$$vm[k], diff);\n\t      }\n\t\n\t    // Observe changes made in the result set\n\t    var observation = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        if (!observation) return;\n\t        _this5.$$vm[k].splice(atIndex, 0, doc);\n\t        _this5.$$changed(k);\n\t      },\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        var diff = jsondiffpatch.diff(_this5.$$vm[k][atIndex], doc);\n\t        jsondiffpatch.patch(_this5.$$vm[k][atIndex], diff);\n\t        _this5.$$changed(k);\n\t      },\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        _this5.$$vm[k].splice(fromIndex, 1);\n\t        _this5.$$vm[k].splice(toIndex, 0, doc);\n\t        _this5.$$changed(k);\n\t      },\n\t      removedAt: function removedAt(oldDoc, atIndex) {\n\t        _this5.$$vm[k].splice(atIndex, 1);\n\t        _this5.$$changed(k);\n\t      }\n\t    });\n\t\n\t    return observation;\n\t  };\n\t\n\t  $$Reactive.$$handleNonCursor = function (k, data) {\n\t    var v = this.$$vm[k];\n\t\n\t    if (angular.isDefined(v)) {\n\t      delete this.$$vm[k];\n\t      v = null;\n\t    }\n\t\n\t    if (angular.isUndefined(v)) {\n\t      this.$$setValHelper(k, data);\n\t    }\n\t    // Update property if the new value is from the same type\n\t    else if ($$utils.areSiblings(v, data)) {\n\t        var diff = jsondiffpatch.diff(v, data);\n\t        jsondiffpatch.patch(v, diff);\n\t        this.$$changed(k);\n\t      } else {\n\t        this.$$vm[k] = data;\n\t      }\n\t  };\n\t\n\t  // Notifies dependency in view model\n\t  $$Reactive.$$depend = function (k) {\n\t    this.$$vm.$$dependencies[k].depend();\n\t  };\n\t\n\t  // Notifies change in view model\n\t  $$Reactive.$$changed = function (k) {\n\t    this.$$throttledDigest();\n\t    this.$$vm.$$dependencies[k].changed();\n\t  };\n\t\n\t  return $$Reactive;\n\t}]);\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-meteor.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 39a73188e98df3db7f81\n **/","// lib\nimport './lib/get-updates';\nimport './lib/diff-array';\n// legacy\nimport './modules/angular-meteor-ironrouter';\nimport './modules/angular-meteor-utils';\nimport './modules/angular-meteor-subscribe';\nimport './modules/angular-meteor-collection';\nimport './modules/angular-meteor-object';\nimport './modules/angular-meteor-user';\nimport './modules/angular-meteor-methods';\nimport './modules/angular-meteor-session';\nimport './modules/angular-meteor-camera';\nimport './modules/angular-meteor-stopper';\n\n// new\nimport { module as utilsModule } from './modules/utils';\nimport { module as mixerModule, Mixer } from './modules/mixer';\nimport { module as scopeModule } from './modules/scope';\nimport { module as coreModule, Core } from './modules/core';\nimport { module as viewModelModule, ViewModel } from './modules/view-model';\nimport { module as reactiveModule, Reactive } from './modules/reactive';\n\nconst module = 'angular-meteor';\nexport default module;\n\nangular.module(module, [\n  // new\n  utilsModule,\n  mixerModule,\n  scopeModule,\n  coreModule,\n  viewModelModule,\n  reactiveModule,\n\n  // legacy\n  'angular-meteor.ironrouter',\n  'angular-meteor.utils',\n  'angular-meteor.subscribe',\n  'angular-meteor.collection',\n  'angular-meteor.object',\n  'angular-meteor.user',\n  'angular-meteor.methods',\n  'angular-meteor.session',\n  'angular-meteor.camera'\n\n])\n\n.constant('$angularMeteorSettings', {\n  suppressWarnings: false\n})\n\n.run([\n  Mixer,\n  Core,\n  ViewModel,\n  Reactive,\n\n  function($Mixer, $$Core, $$ViewModel, $$Reactive) {\n    // Load all mixins\n    $Mixer\n      .mixin($$Core)\n      .mixin($$ViewModel)\n      .mixin($$Reactive);\n  }\n])\n\n// legacy\n// Putting all services under $meteor service for syntactic sugar\n.service('$meteor', [\n  '$meteorCollection',\n  '$meteorCollectionFS',\n  '$meteorObject',\n  '$meteorMethods',\n  '$meteorSession',\n  '$meteorSubscribe',\n  '$meteorUtils',\n  '$meteorCamera',\n  '$meteorUser',\n  function($meteorCollection, $meteorCollectionFS, $meteorObject,\n    $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils,\n    $meteorCamera, $meteorUser) {\n    this.collection = $meteorCollection;\n    this.collectionFS = $meteorCollectionFS;\n    this.object = $meteorObject;\n    this.subscribe = $meteorSubscribe.subscribe;\n    this.call = $meteorMethods.call;\n    this.session = $meteorSession;\n    this.autorun = $meteorUtils.autorun;\n    this.getCollectionByName = $meteorUtils.getCollectionByName;\n    this.getPicture = $meteorCamera.getPicture;\n\n    // $meteorUser\n    [\n      'loginWithPassword',\n      'requireUser',\n      'requireValidUser',\n      'waitForUser',\n      'createUser',\n      'changePassword',\n      'forgotPassword',\n      'resetPassword',\n      'verifyEmail',\n      'loginWithMeteorDeveloperAccount',\n      'loginWithFacebook',\n      'loginWithGithub',\n      'loginWithGoogle',\n      'loginWithMeetup',\n      'loginWithTwitter',\n      'loginWithWeibo',\n      'logout',\n      'logoutOtherClients'\n    ].forEach((method) => {\n      this[method] = $meteorUser[method];\n    });\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/angular-meteor.js\n **/","/*global\r\n angular, _\r\n */\r\n\r\n'use strict';\r\n\r\n// https://github.com/DAB0mB/get-updates\r\n(function() {\r\n  var module = angular.module('getUpdates', []);\r\n\r\n  var utils = (function() {\r\n    var rip = function(obj, level) {\r\n      if (level < 1) return {};\r\n\r\n      return _.reduce(obj, function(clone, v, k) {\r\n        v = _.isObject(v) ? rip(v, --level) : v;\r\n        clone[k] = v;\r\n        return clone;\r\n      }, {});\r\n    };\r\n\r\n    var toPaths = function(obj) {\r\n      var keys = getKeyPaths(obj);\r\n      var values = getDeepValues(obj);\r\n      return _.object(keys, values);\r\n    };\r\n\r\n    var getKeyPaths = function(obj) {\r\n      var keys = _.keys(obj).map(function(k) {\r\n        var v = obj[k];\r\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\r\n\r\n        return getKeyPaths(v).map(function(subKey) {\r\n          return k + '.' + subKey;\r\n        });\r\n      });\r\n\r\n      return _.flatten(keys);\r\n    };\r\n\r\n    var getDeepValues = function(obj,arr) {\r\n      arr = arr || [];\r\n\r\n      _.values(obj).forEach(function(v) {\r\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v))\r\n          arr.push(v);\r\n        else\r\n          getDeepValues(v, arr);\r\n      });\r\n\r\n      return arr;\r\n    };\r\n\r\n    var flatten = function(arr) {\r\n      return arr.reduce(function(flattened, v, i) {\r\n        if (_.isArray(v) && !_.isEmpty(v))\r\n          flattened.push.apply(flattened, flatten(v));\r\n        else\r\n          flattened.push(v);\r\n\r\n        return flattened;\r\n      }, []);\r\n    };\r\n\r\n    var setFilled = function(obj, k, v) {\r\n      if (!_.isEmpty(v)) obj[k] = v;\r\n    };\r\n\r\n    var assert = function(result, msg) {\r\n      if (!result) throwErr(msg);\r\n    };\r\n\r\n    var throwErr = function(msg) {\r\n      throw Error('get-updates error - ' + msg);\r\n    };\r\n\r\n    return {\r\n      rip: rip,\r\n      toPaths: toPaths,\r\n      getKeyPaths: getKeyPaths,\r\n      getDeepValues: getDeepValues,\r\n      setFilled: setFilled,\r\n      assert: assert,\r\n      throwErr: throwErr\r\n    };\r\n  })();\r\n\r\n  var getDifference = (function() {\r\n    var getDifference = function(src, dst, isShallow) {\r\n      var level;\r\n\r\n      if (isShallow > 1)\r\n        level = isShallow;\r\n      else if (isShallow)\r\n        level = 1;\r\n\r\n      if (level) {\r\n        src = utils.rip(src, level);\r\n        dst = utils.rip(dst, level);\r\n      }\r\n\r\n      return compare(src, dst);\r\n    };\r\n\r\n    var compare = function(src, dst) {\r\n      var srcKeys = _.keys(src);\r\n      var dstKeys = _.keys(dst);\r\n\r\n      var keys = _.chain([])\r\n        .concat(srcKeys)\r\n        .concat(dstKeys)\r\n        .uniq()\r\n        .without('$$hashKey')\r\n        .value();\r\n\r\n      return keys.reduce(function(diff, k) {\r\n        var srcValue = src[k];\r\n        var dstValue = dst[k];\r\n\r\n        if (_.isDate(srcValue) && _.isDate(dstValue)) {\r\n          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\r\n        }\r\n\r\n        if (_.isObject(srcValue) && _.isObject(dstValue)) {\r\n          var valueDiff = getDifference(srcValue, dstValue);\r\n          utils.setFilled(diff, k, valueDiff);\r\n        }\r\n\r\n        else if (srcValue !== dstValue) {\r\n          diff[k] = dstValue;\r\n        }\r\n\r\n        return diff;\r\n      }, {});\r\n    };\r\n\r\n    return getDifference;\r\n  })();\r\n\r\n  var getUpdates = (function() {\r\n    var getUpdates = function(src, dst, isShallow) {\r\n      utils.assert(_.isObject(src), 'first argument must be an object');\r\n      utils.assert(_.isObject(dst), 'second argument must be an object');\r\n\r\n      var diff = getDifference(src, dst, isShallow);\r\n      var paths = utils.toPaths(diff);\r\n\r\n      var set = createSet(paths);\r\n      var unset = createUnset(paths);\r\n      var pull = createPull(unset);\r\n\r\n      var updates = {};\r\n      utils.setFilled(updates, '$set', set);\r\n      utils.setFilled(updates, '$unset', unset);\r\n      utils.setFilled(updates, '$pull', pull);\r\n\r\n      return updates;\r\n    };\r\n\r\n    var createSet = function(paths) {\r\n      var undefinedKeys = getUndefinedKeys(paths);\r\n      return _.omit(paths, undefinedKeys);\r\n    };\r\n\r\n    var createUnset = function(paths) {\r\n      var undefinedKeys = getUndefinedKeys(paths);\r\n      var unset = _.pick(paths, undefinedKeys);\r\n\r\n      return _.reduce(unset, function(result, v, k) {\r\n        result[k] = true;\r\n        return result;\r\n      }, {});\r\n    };\r\n\r\n    var createPull = function(unset) {\r\n      var arrKeyPaths = _.keys(unset).map(function(k) {\r\n        var split = k.match(/(.*)\\.\\d+$/);\r\n        return split && split[1];\r\n      });\r\n\r\n      return _.compact(arrKeyPaths).reduce(function(pull, k) {\r\n        pull[k] = null;\r\n        return pull;\r\n      }, {});\r\n    };\r\n\r\n    var getUndefinedKeys = function(obj) {\r\n      return _.keys(obj).filter(function (k) {\r\n        var v = obj[k];\r\n        return _.isUndefined(v);\r\n      });\r\n    };\r\n\r\n    return getUpdates;\r\n  })();\r\n\r\n  module.value('getUpdates', getUpdates);\r\n})();\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/get-updates.js\n **/","/*global\r\n angular, _, Package\r\n */\r\n\r\n'use strict';\r\n\r\nvar _module = angular.module('diffArray', ['getUpdates']);\r\n\r\n_module.factory('diffArray', ['getUpdates',\r\n  function(getUpdates) {\r\n    var LocalCollection = Package.minimongo.LocalCollection;\r\n    var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\r\n    var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\r\n\r\n    // Calculates the differences between `lastSeqArray` and\r\n    // `seqArray` and calls appropriate functions from `callbacks`.\r\n    // Reuses Minimongo's diff algorithm implementation.\r\n    // XXX Should be replaced with the original diffArray function here:\r\n    // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\r\n    // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\r\n    function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\r\n      preventNestedDiff = !!preventNestedDiff;\r\n\r\n      var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges ||\r\n        Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\r\n\r\n      var oldObjIds = [];\r\n      var newObjIds = [];\r\n      var posOld = {}; // maps from idStringify'd ids\r\n      var posNew = {}; // ditto\r\n      var posCur = {};\r\n      var lengthCur = lastSeqArray.length;\r\n\r\n      _.each(seqArray, function (doc, i) {\r\n        newObjIds.push({_id: doc._id});\r\n        posNew[idStringify(doc._id)] = i;\r\n      });\r\n\r\n      _.each(lastSeqArray, function (doc, i) {\r\n        oldObjIds.push({_id: doc._id});\r\n        posOld[idStringify(doc._id)] = i;\r\n        posCur[idStringify(doc._id)] = i;\r\n      });\r\n\r\n      // Arrays can contain arbitrary objects. We don't diff the\r\n      // objects. Instead we always fire 'changedAt' callback on every\r\n      // object. The consumer of `observe-sequence` should deal with\r\n      // it appropriately.\r\n      diffFn(oldObjIds, newObjIds, {\r\n        addedBefore: function (id, doc, before) {\r\n          var position = before ? posCur[idStringify(before)] : lengthCur;\r\n\r\n          _.each(posCur, function (pos, id) {\r\n            if (pos >= position) posCur[id]++;\r\n          });\r\n\r\n          lengthCur++;\r\n          posCur[idStringify(id)] = position;\r\n\r\n          callbacks.addedAt(\r\n            id,\r\n            seqArray[posNew[idStringify(id)]],\r\n            position,\r\n            before\r\n          );\r\n        },\r\n\r\n        movedBefore: function (id, before) {\r\n          var prevPosition = posCur[idStringify(id)];\r\n          var position = before ? posCur[idStringify(before)] : lengthCur - 1;\r\n\r\n          _.each(posCur, function (pos, id) {\r\n            if (pos >= prevPosition && pos <= position)\r\n              posCur[id]--;\r\n            else if (pos <= prevPosition && pos >= position)\r\n              posCur[id]++;\r\n          });\r\n\r\n          posCur[idStringify(id)] = position;\r\n\r\n          callbacks.movedTo(\r\n            id,\r\n            seqArray[posNew[idStringify(id)]],\r\n            prevPosition,\r\n            position,\r\n            before\r\n          );\r\n        },\r\n        removed: function (id) {\r\n          var prevPosition = posCur[idStringify(id)];\r\n\r\n          _.each(posCur, function (pos, id) {\r\n            if (pos >= prevPosition) posCur[id]--;\r\n          });\r\n\r\n          delete posCur[idStringify(id)];\r\n          lengthCur--;\r\n\r\n          callbacks.removedAt(\r\n            id,\r\n            lastSeqArray[posOld[idStringify(id)]],\r\n            prevPosition\r\n          );\r\n        }\r\n      });\r\n\r\n      _.each(posNew, function (pos, idString) {\r\n        if (!_.has(posOld, idString)) return;\r\n\r\n        var id = idParse(idString);\r\n        var newItem = seqArray[pos] || {};\r\n        var oldItem = lastSeqArray[posOld[idString]];\r\n        var updates = getUpdates(oldItem, newItem, preventNestedDiff);\r\n\r\n        if (!_.isEmpty(updates))\r\n          callbacks.changedAt(id, updates, pos, oldItem);\r\n      });\r\n    }\r\n\r\n    diffArray.shallow = function(lastSeqArray, seqArray, callbacks) {\r\n      return diffArray(lastSeqArray, seqArray, callbacks, true);\r\n    };\r\n\r\n    diffArray.deepCopyChanges = function (oldItem, newItem) {\r\n      var setDiff = getUpdates(oldItem, newItem).$set;\r\n\r\n      _.each(setDiff, function(v, deepKey) {\r\n        setDeep(oldItem, deepKey, v);\r\n      });\r\n    };\r\n\r\n    diffArray.deepCopyRemovals = function (oldItem, newItem) {\r\n      var unsetDiff = getUpdates(oldItem, newItem).$unset;\r\n\r\n      _.each(unsetDiff, function(v, deepKey) {\r\n        unsetDeep(oldItem, deepKey);\r\n      });\r\n    };\r\n\r\n    // Finds changes between two collections\r\n    diffArray.getChanges = function(newCollection, oldCollection, diffMethod) {\r\n      var changes = {added: [], removed: [], changed: []};\r\n\r\n      diffMethod(oldCollection, newCollection, {\r\n        addedAt: function(id, item, index) {\r\n          changes.added.push({item: item, index: index});\r\n        },\r\n\r\n        removedAt: function(id, item, index) {\r\n          changes.removed.push({item: item, index: index});\r\n        },\r\n\r\n        changedAt: function(id, updates, index, oldItem) {\r\n          changes.changed.push({selector: id, modifier: updates});\r\n        },\r\n\r\n        movedTo: function(id, item, fromIndex, toIndex) {\r\n          // XXX do we need this?\r\n        }\r\n      });\r\n\r\n      return changes;\r\n    };\r\n\r\n    var setDeep = function(obj, deepKey, v) {\r\n      var split = deepKey.split('.');\r\n      var initialKeys = _.initial(split);\r\n      var lastKey = _.last(split);\r\n\r\n      initialKeys.reduce(function(subObj, k, i) {\r\n        var nextKey = split[i + 1];\r\n\r\n        if (isNumStr(nextKey)) {\r\n          if (subObj[k] === null) subObj[k] = [];\r\n          if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\r\n        }\r\n\r\n        else if (subObj[k] === null || !isHash(subObj[k])) {\r\n          subObj[k] = {};\r\n        }\r\n\r\n        return subObj[k];\r\n      }, obj);\r\n\r\n      var deepObj = getDeep(obj, initialKeys);\r\n      deepObj[lastKey] = v;\r\n      return v;\r\n    };\r\n\r\n    var unsetDeep = function(obj, deepKey) {\r\n      var split = deepKey.split('.');\r\n      var initialKeys = _.initial(split);\r\n      var lastKey = _.last(split);\r\n      var deepObj = getDeep(obj, initialKeys);\r\n\r\n      if (_.isArray(deepObj) && isNumStr(lastKey))\r\n        return !!deepObj.splice(lastKey, 1);\r\n      else\r\n        return delete deepObj[lastKey];\r\n    };\r\n\r\n    var getDeep = function(obj, keys) {\r\n      return keys.reduce(function(subObj, k) {\r\n        return subObj[k];\r\n      }, obj);\r\n    };\r\n\r\n    var isHash = function(obj) {\r\n      return _.isObject(obj) &&\r\n             Object.getPrototypeOf(obj) === Object.prototype;\r\n    };\r\n\r\n    var isNumStr = function(str) {\r\n      return str.match(/^\\d+$/);\r\n    };\r\n\r\n    return diffArray;\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/diff-array.js\n **/","angular.module('angular-meteor.ironrouter', [])\r\n\r\n\r\n.run([\r\n  '$compile',\r\n  '$document',\r\n  '$rootScope',\r\n\r\nfunction ($compile, $document, $rootScope) {\r\n  const Router = (Package['iron:router'] || {}).Router;\r\n  if (!Router) return;\r\n\r\n  let isLoaded = false;\r\n\r\n  // Recompile after iron:router builds page\r\n  Router.onAfterAction((req, res, next) => {\r\n    Tracker.afterFlush(() => {\r\n      if (isLoaded) return;\r\n      $compile($document)($rootScope);\r\n      if (!$rootScope.$$phase) $rootScope.$apply();\r\n      isLoaded = true;\r\n    });\r\n  });\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-ironrouter.js\n **/","/*global\r\n angular, _, Tracker, EJSON, FS, Mongo\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorUtils = angular.module('angular-meteor.utils', []);\r\n\r\nangularMeteorUtils.service('$meteorUtils', [\r\n  '$q', '$timeout', '$angularMeteorSettings',\r\n  function ($q, $timeout, $angularMeteorSettings) {\r\n\r\n    var self = this;\r\n\r\n    this.autorun = function(scope, fn) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n\r\n      // wrapping around Deps.autorun\r\n      var comp = Tracker.autorun(function(c) {\r\n        fn(c);\r\n        // this is run immediately for the first call\r\n        // but after that, we need to $apply to start Angular digest\r\n        if (!c.firstRun) $timeout(angular.noop, 0);\r\n      });\r\n\r\n      // stop autorun when scope is destroyed\r\n      scope.$on('$destroy', function() {\r\n        comp.stop();\r\n      });\r\n\r\n      // return autorun object so that it can be stopped manually\r\n      return comp;\r\n    };\r\n\r\n    // Borrowed from angularFire\r\n    // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\r\n    this.stripDollarPrefixedKeys = function (data) {\r\n      if (!_.isObject(data) ||\r\n          data instanceof Date ||\r\n          data instanceof File ||\r\n          EJSON.toJSONValue(data).$type === 'oid' ||\r\n          (typeof FS === 'object' && data instanceof FS.File))\r\n        return data;\r\n\r\n      var out = _.isArray(data) ? [] : {};\r\n\r\n      _.each(data, function(v,k) {\r\n        if(typeof k !== 'string' || k.charAt(0) !== '$')\r\n          out[k] = self.stripDollarPrefixedKeys(v);\r\n      });\r\n\r\n      return out;\r\n    };\r\n\r\n    // Returns a callback which fulfills promise\r\n    this.fulfill = function(deferred, boundError, boundResult) {\r\n      return function(err, result) {\r\n        if (err)\r\n          deferred.reject(boundError === null ? err : boundError);\r\n        else if (typeof boundResult == \"function\")\r\n          deferred.resolve(boundResult === null ? result : boundResult(result));\r\n        else\r\n          deferred.resolve(boundResult === null ? result : boundResult);\r\n      };\r\n    };\r\n\r\n    // creates a function which invokes method with the given arguments and returns a promise\r\n    this.promissor = function(obj, method) {\r\n      return function() {\r\n        var deferred = $q.defer();\r\n        var fulfill = self.fulfill(deferred);\r\n        var args = _.toArray(arguments).concat(fulfill);\r\n        obj[method].apply(obj, args);\r\n        return deferred.promise;\r\n      };\r\n    };\r\n\r\n    // creates a $q.all() promise and call digestion loop on fulfillment\r\n    this.promiseAll = function(promises) {\r\n      var allPromise = $q.all(promises);\r\n\r\n      allPromise.finally(function() {\r\n        // calls digestion loop with no conflicts\r\n        $timeout(angular.noop);\r\n      });\r\n\r\n      return allPromise;\r\n    };\r\n\r\n    this.getCollectionByName = function(string){\r\n      return Mongo.Collection.get(string);\r\n    };\r\n\r\n    this.findIndexById = function(collection, doc) {\r\n      var foundDoc = _.find(collection, function(colDoc) {\r\n        // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\r\n        return EJSON.equals(colDoc._id, doc._id);\r\n      });\r\n\r\n      return _.indexOf(collection, foundDoc);\r\n    };\r\n  }\r\n]);\r\n\r\nangularMeteorUtils.run([\r\n  '$rootScope', '$meteorUtils',\r\n  function($rootScope, $meteorUtils) {\r\n    Object.getPrototypeOf($rootScope).$meteorAutorun = function(fn) {\r\n      return $meteorUtils.autorun(this, fn);\r\n    };\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-utils.js\n **/","/*global\r\n angular, Meteor\r\n */\r\n\r\n'use strict';\r\nvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', []);\r\n\r\nangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings',\r\n  function ($q, $angularMeteorSettings) {\r\n\r\n    var self = this;\r\n\r\n    this._subscribe = function(scope, deferred, args) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var subscription = null;\r\n      var lastArg = args[args.length - 1];\r\n\r\n      // User supplied onStop callback\r\n      // save it for later use and remove\r\n      // from subscription arguments\r\n      if (angular.isObject(lastArg) &&\r\n          angular.isFunction(lastArg.onStop)) {\r\n        var onStop = lastArg.onStop;\r\n\r\n        args.pop();\r\n      }\r\n\r\n      args.push({\r\n        onReady: function() {\r\n          deferred.resolve(subscription);\r\n        },\r\n        onStop: function(err) {\r\n          if (!deferred.promise.$$state.status) {\r\n            if (err)\r\n              deferred.reject(err);\r\n            else\r\n              deferred.reject(new Meteor.Error(\"Subscription Stopped\",\r\n                \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\r\n          } else if (onStop)\r\n            // After promise was resolved or rejected\r\n            // call user supplied onStop callback.\r\n            onStop.apply(this, Array.prototype.slice.call(arguments));\r\n\r\n        }\r\n      });\r\n\r\n      subscription =  Meteor.subscribe.apply(scope, args);\r\n\r\n      return subscription;\r\n    };\r\n\r\n    this.subscribe = function(){\r\n      var deferred = $q.defer();\r\n      var args = Array.prototype.slice.call(arguments);\r\n      var subscription = null;\r\n\r\n      self._subscribe(this, deferred, args);\r\n\r\n      return deferred.promise;\r\n    };\r\n  }]);\r\n\r\nangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe',\r\n  function($rootScope, $q, $meteorSubscribe) {\r\n    Object.getPrototypeOf($rootScope).$meteorSubscribe = function() {\r\n      var deferred = $q.defer();\r\n      var args = Array.prototype.slice.call(arguments);\r\n\r\n      var subscription = $meteorSubscribe._subscribe(this, deferred, args);\r\n\r\n      this.$on('$destroy', function() {\r\n        subscription.stop();\r\n      });\r\n\r\n      return deferred.promise;\r\n    };\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-subscribe.js\n **/","/*global\r\n angular, _, Tracker, check, Match, Mongo\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorCollection = angular.module('angular-meteor.collection',\r\n  ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray']);\r\n\r\n// The reason angular meteor collection is a factory function and not something\r\n// that inherit from array comes from here:\r\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\r\n// We went with the direct extensions approach.\r\nangularMeteorCollection.factory('AngularMeteorCollection', [\r\n  '$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings',\r\n  function($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\r\n\r\n    function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var data = [];\r\n      // Server backup data to evaluate what changes come from client\r\n      // after each server update.\r\n      data._serverBackup = [];\r\n      // Array differ function.\r\n      data._diffArrayFunc = diffArrayFunc;\r\n      // Handler of the cursor observer.\r\n      data._hObserve = null;\r\n      // On new cursor autorun handler\r\n      // (autorun for reactive variables).\r\n      data._hNewCurAutorun = null;\r\n      // On new data autorun handler\r\n      // (autorun for cursor.fetch).\r\n      data._hDataAutorun = null;\r\n\r\n      if (angular.isDefined(collection)) {\r\n        data.$$collection = collection;\r\n      } else {\r\n        var cursor = curDefFunc();\r\n        data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\r\n      }\r\n\r\n      _.extend(data, AngularMeteorCollection);\r\n      data._startCurAutorun(curDefFunc, autoClientSave);\r\n\r\n      return data;\r\n    }\r\n\r\n    AngularMeteorCollection._startCurAutorun = function(curDefFunc, autoClientSave) {\r\n      var self = this;\r\n\r\n      self._hNewCurAutorun = Tracker.autorun(function() {\r\n        // When the reactive func gets recomputated we need to stop any previous\r\n        // observeChanges.\r\n        Tracker.onInvalidate(function() {\r\n          self._stopCursor();\r\n        });\r\n\r\n        if (autoClientSave) self._setAutoClientSave();\r\n        self._updateCursor(curDefFunc(), autoClientSave);\r\n      });\r\n    };\r\n\r\n    AngularMeteorCollection.subscribe = function() {\r\n      $meteorSubscribe.subscribe.apply(this, arguments);\r\n      return this;\r\n    };\r\n\r\n    AngularMeteorCollection.save = function(docs, useUnsetModifier) {\r\n      // save whole collection\r\n      if (!docs) docs = this;\r\n      // save single doc\r\n      docs = [].concat(docs);\r\n\r\n      var promises = docs.map(function(doc) {\r\n        return this._upsertDoc(doc, useUnsetModifier);\r\n      }, this);\r\n\r\n      return $meteorUtils.promiseAll(promises);\r\n    };\r\n\r\n    AngularMeteorCollection._upsertDoc = function(doc, useUnsetModifier) {\r\n      var deferred = $q.defer();\r\n      var collection = this.$$collection;\r\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\r\n\r\n      // delete $$hashkey\r\n      doc = $meteorUtils.stripDollarPrefixedKeys(doc);\r\n      var docId = doc._id;\r\n      var isExist = collection.findOne(docId);\r\n\r\n      // update\r\n      if (isExist) {\r\n        // Deletes _id property (from the copy) so that\r\n        // it can be $set using update.\r\n        delete doc._id;\r\n        var modifier = useUnsetModifier ? {$unset: doc} : {$set: doc};\r\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\r\n        collection.update(docId, modifier, createFulfill(function() {\r\n          return {_id: docId, action: 'updated'};\r\n        }));\r\n      }\r\n      // insert\r\n      else {\r\n        collection.insert(doc, createFulfill(function(id) {\r\n          return {_id: id, action: 'inserted'};\r\n        }));\r\n      }\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    // performs $pull operations parallely.\r\n    // used for handling splice operations returned from getUpdates() to prevent conflicts.\r\n    // see issue: https://github.com/Urigo/angular-meteor/issues/793\r\n    AngularMeteorCollection._updateDiff = function(selector, update, callback) {\r\n      callback = callback || angular.noop;\r\n      var setters = _.omit(update, '$pull');\r\n      var updates = [setters];\r\n\r\n      _.each(update.$pull, function(pull, prop) {\r\n        var puller = {};\r\n        puller[prop] = pull;\r\n        updates.push({ $pull: puller });\r\n      });\r\n\r\n      this._updateParallel(selector, updates, callback);\r\n    };\r\n\r\n    // performs each update operation parallely\r\n    AngularMeteorCollection._updateParallel = function(selector, updates, callback) {\r\n      var self = this;\r\n      var done = _.after(updates.length, callback);\r\n\r\n      var next = function(err, affectedDocsNum) {\r\n        if (err) return callback(err);\r\n        done(null, affectedDocsNum);\r\n      };\r\n\r\n      _.each(updates, function(update) {\r\n        self.$$collection.update(selector, update, next);\r\n      });\r\n    };\r\n\r\n    AngularMeteorCollection.remove = function(keyOrDocs) {\r\n      var keys;\r\n\r\n      // remove whole collection\r\n      if (!keyOrDocs) {\r\n        keys = _.pluck(this, '_id');\r\n      }\r\n      // remove docs\r\n      else {\r\n        keyOrDocs = [].concat(keyOrDocs);\r\n\r\n        keys = _.map(keyOrDocs, function(keyOrDoc) {\r\n          return keyOrDoc._id || keyOrDoc;\r\n        });\r\n      }\r\n\r\n      // Checks if all keys are correct.\r\n      check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\r\n\r\n      var promises = keys.map(function(key) {\r\n        return this._removeDoc(key);\r\n      }, this);\r\n\r\n      return $meteorUtils.promiseAll(promises);\r\n    };\r\n\r\n    AngularMeteorCollection._removeDoc = function(id) {\r\n      var deferred = $q.defer();\r\n      var collection = this.$$collection;\r\n      var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\r\n      collection.remove(id, fulfill);\r\n      return deferred.promise;\r\n    };\r\n\r\n    AngularMeteorCollection._updateCursor = function(cursor, autoClientSave) {\r\n      var self = this;\r\n      // XXX - consider adding an option for a non-orderd result for faster performance\r\n      if (self._hObserve) self._stopObserving();\r\n\r\n\r\n      self._hObserve = cursor.observe({\r\n        addedAt: function(doc, atIndex) {\r\n          self.splice(atIndex, 0, doc);\r\n          self._serverBackup.splice(atIndex, 0, doc);\r\n          self._setServerUpdateMode();\r\n        },\r\n\r\n        changedAt: function(doc, oldDoc, atIndex) {\r\n          diffArray.deepCopyChanges(self[atIndex], doc);\r\n          diffArray.deepCopyRemovals(self[atIndex], doc);\r\n          self._serverBackup[atIndex] = self[atIndex];\r\n          self._setServerUpdateMode();\r\n        },\r\n\r\n        movedTo: function(doc, fromIndex, toIndex) {\r\n          self.splice(fromIndex, 1);\r\n          self.splice(toIndex, 0, doc);\r\n          self._serverBackup.splice(fromIndex, 1);\r\n          self._serverBackup.splice(toIndex, 0, doc);\r\n          self._setServerUpdateMode();\r\n        },\r\n\r\n        removedAt: function(oldDoc) {\r\n          var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\r\n\r\n          if (removedIndex != -1) {\r\n            self.splice(removedIndex, 1);\r\n            self._serverBackup.splice(removedIndex, 1);\r\n            self._setServerUpdateMode();\r\n          } else {\r\n            // If it's been removed on client then it's already not in collection\r\n            // itself but still is in the _serverBackup.\r\n            removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\r\n\r\n            if (removedIndex != -1) {\r\n              self._serverBackup.splice(removedIndex, 1);\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      self._hDataAutorun = Tracker.autorun(function() {\r\n        cursor.fetch();\r\n        if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\r\n      });\r\n    };\r\n\r\n    AngularMeteorCollection._stopObserving = function() {\r\n      this._hObserve.stop();\r\n      this._hDataAutorun.stop();\r\n      delete this._serverMode;\r\n      delete this._hUnsetTimeout;\r\n    };\r\n\r\n    AngularMeteorCollection._setServerUpdateMode = function(name) {\r\n      this._serverMode = true;\r\n      // To simplify server update logic, we don't follow\r\n      // updates from the client at the same time.\r\n      this._unsetAutoClientSave();\r\n    };\r\n\r\n    // Here we use $timeout to combine multiple updates that go\r\n    // each one after another.\r\n    AngularMeteorCollection._unsetServerUpdateMode = function(autoClientSave) {\r\n      var self = this;\r\n\r\n      if (self._hUnsetTimeout) {\r\n        $timeout.cancel(self._hUnsetTimeout);\r\n        self._hUnsetTimeout = null;\r\n      }\r\n\r\n      self._hUnsetTimeout = $timeout(function() {\r\n        self._serverMode = false;\r\n        // Finds updates that was potentially done from the client side\r\n        // and saves them.\r\n        var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\r\n        self._saveChanges(changes);\r\n        // After, continues following client updates.\r\n        if (autoClientSave) self._setAutoClientSave();\r\n      }, 0);\r\n    };\r\n\r\n    AngularMeteorCollection.stop = function() {\r\n      this._stopCursor();\r\n      this._hNewCurAutorun.stop();\r\n    };\r\n\r\n    AngularMeteorCollection._stopCursor = function() {\r\n      this._unsetAutoClientSave();\r\n\r\n      if (this._hObserve) {\r\n        this._hObserve.stop();\r\n        this._hDataAutorun.stop();\r\n      }\r\n\r\n      this.splice(0);\r\n      this._serverBackup.splice(0);\r\n    };\r\n\r\n    AngularMeteorCollection._unsetAutoClientSave = function(name) {\r\n      if (this._hRegAutoBind) {\r\n        this._hRegAutoBind();\r\n        this._hRegAutoBind = null;\r\n      }\r\n    };\r\n\r\n    AngularMeteorCollection._setAutoClientSave = function() {\r\n      var self = this;\r\n\r\n      // Always unsets auto save to keep only one $watch handler.\r\n      self._unsetAutoClientSave();\r\n\r\n      self._hRegAutoBind = $rootScope.$watch(function() {\r\n        return self;\r\n      }, function(nItems, oItems) {\r\n        if (nItems === oItems) return;\r\n\r\n        var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\r\n        self._unsetAutoClientSave();\r\n        self._saveChanges(changes);\r\n        self._setAutoClientSave();\r\n      }, true);\r\n    };\r\n\r\n    AngularMeteorCollection._saveChanges = function(changes) {\r\n      var self = this;\r\n\r\n      // Saves added documents\r\n      // Using reversed iteration to prevent indexes from changing during splice\r\n      var addedDocs = changes.added.reverse().map(function(descriptor) {\r\n        self.splice(descriptor.index, 1);\r\n        return descriptor.item;\r\n      });\r\n\r\n      if (addedDocs.length) self.save(addedDocs);\r\n\r\n      // Removes deleted documents\r\n      var removedDocs = changes.removed.map(function(descriptor) {\r\n        return descriptor.item;\r\n      });\r\n\r\n      if (removedDocs.length) self.remove(removedDocs);\r\n\r\n      // Updates changed documents\r\n      changes.changed.forEach(function(descriptor) {\r\n        self._updateDiff(descriptor.selector, descriptor.modifier);\r\n      });\r\n    };\r\n\r\n    return AngularMeteorCollection;\r\n}]);\r\n\r\nangularMeteorCollection.factory('$meteorCollectionFS', [\r\n  '$meteorCollection', 'diffArray', '$angularMeteorSettings',\r\n  function($meteorCollection, diffArray, $angularMeteorSettings) {\r\n    function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\r\n\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n      return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\r\n    }\r\n\r\n    return $meteorCollectionFS;\r\n}]);\r\n\r\nangularMeteorCollection.factory('$meteorCollection', [\r\n  'AngularMeteorCollection', '$rootScope', 'diffArray',\r\n  function(AngularMeteorCollection, $rootScope, diffArray) {\r\n    function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\r\n      // Validate parameters\r\n      if (!reactiveFunc) {\r\n        throw new TypeError('The first argument of $meteorCollection is undefined.');\r\n      }\r\n\r\n      if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\r\n        throw new TypeError(\r\n          'The first argument of $meteorCollection must be a function or ' +\r\n            'a have a find function property.');\r\n      }\r\n\r\n      if (!angular.isFunction(reactiveFunc)) {\r\n        collection = angular.isDefined(collection) ? collection : reactiveFunc;\r\n        reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\r\n      }\r\n\r\n      // By default auto save - true.\r\n      autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\r\n      diffFn = diffFn || diffArray;\r\n      return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\r\n    }\r\n\r\n    return $meteorCollection;\r\n}]);\r\n\r\nangularMeteorCollection.run([\r\n  '$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper',\r\n  function($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\r\n    var scopeProto = Object.getPrototypeOf($rootScope);\r\n    scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\r\n    scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-collection.js\n **/","/*global\r\n  angular, _, Mongo\r\n*/\r\n\r\n'use strict';\r\n\r\nvar angularMeteorObject = angular.module('angular-meteor.object',\r\n  ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray']);\r\n\r\nangularMeteorObject.factory('AngularMeteorObject', [\r\n  '$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings',\r\n  function($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\r\n\r\n    // A list of internals properties to not watch for, nor pass to the Document on update and etc.\r\n    AngularMeteorObject.$$internalProps = [\r\n      '$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope',\r\n      'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject',\r\n      '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'\r\n    ];\r\n\r\n    function AngularMeteorObject (collection, selector, options){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n      // Make data not be an object so we can extend it to preserve\r\n      // Collection Helpers and the like\r\n      var helpers = collection._helpers;\r\n      var data = _.isFunction(helpers) ? Object.create(helpers.prototype) : {};\r\n      var doc = collection.findOne(selector, options);\r\n      var collectionExtension = _.pick(AngularMeteorCollection, '_updateParallel');\r\n      _.extend(data, doc);\r\n      _.extend(data, AngularMeteorObject);\r\n      _.extend(data, collectionExtension);\r\n\r\n      // Omit options that may spoil document finding\r\n      data.$$options = _.omit(options, 'skip', 'limit');\r\n      data.$$collection = collection;\r\n      data.$$id = data._getId(selector);\r\n      data._serverBackup = doc || {};\r\n\r\n      return data;\r\n    }\r\n\r\n    AngularMeteorObject.getRawObject = function () {\r\n      return angular.copy(_.omit(this, this.$$internalProps));\r\n    };\r\n\r\n    AngularMeteorObject.subscribe = function () {\r\n      $meteorSubscribe.subscribe.apply(this, arguments);\r\n      return this;\r\n    };\r\n\r\n    AngularMeteorObject.save = function(custom) {\r\n      var deferred = $q.defer();\r\n      var collection = this.$$collection;\r\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\r\n      var oldDoc = collection.findOne(this.$$id);\r\n      var mods;\r\n\r\n      // update\r\n      if (oldDoc) {\r\n        if (custom)\r\n          mods = { $set: custom };\r\n        else {\r\n          mods = getUpdates(oldDoc, this.getRawObject());\r\n          // If there are no updates, there is nothing to do here, returning\r\n          if (_.isEmpty(mods)) {\r\n            return $q.when({ action: 'updated' });\r\n          }\r\n        }\r\n\r\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\r\n        this._updateDiff(mods, createFulfill({ action: 'updated' }));\r\n      }\r\n      // insert\r\n      else {\r\n        if (custom)\r\n          mods = _.clone(custom);\r\n        else\r\n          mods = this.getRawObject();\r\n\r\n        mods._id = mods._id || this.$$id;\r\n        collection.insert(mods, createFulfill({ action: 'inserted' }));\r\n      }\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    AngularMeteorObject._updateDiff = function(update, callback) {\r\n      var selector = this.$$id;\r\n      AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\r\n    };\r\n\r\n    AngularMeteorObject.reset = function(keepClientProps) {\r\n      var self = this;\r\n      var options = this.$$options;\r\n      var id = this.$$id;\r\n      var doc = this.$$collection.findOne(id, options);\r\n\r\n      if (doc) {\r\n        // extend SubObject\r\n        var docKeys = _.keys(doc);\r\n        var docExtension = _.pick(doc, docKeys);\r\n        var clientProps;\r\n\r\n        _.extend(self, docExtension);\r\n        _.extend(self._serverBackup, docExtension);\r\n\r\n        if (keepClientProps) {\r\n          clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\r\n        } else {\r\n          clientProps = _.keys(self);\r\n        }\r\n\r\n        var serverProps = _.keys(doc);\r\n        var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\r\n\r\n        removedKeys.forEach(function (prop) {\r\n          delete self[prop];\r\n          delete self._serverBackup[prop];\r\n        });\r\n      }\r\n\r\n      else {\r\n        _.keys(this.getRawObject()).forEach(function(prop) {\r\n          delete self[prop];\r\n        });\r\n\r\n        self._serverBackup = {};\r\n      }\r\n    };\r\n\r\n    AngularMeteorObject.stop = function () {\r\n      if (this.unregisterAutoDestroy)\r\n        this.unregisterAutoDestroy();\r\n\r\n      if (this.unregisterAutoBind)\r\n        this.unregisterAutoBind();\r\n\r\n      if (this.autorunComputation && this.autorunComputation.stop)\r\n        this.autorunComputation.stop();\r\n    };\r\n\r\n    AngularMeteorObject._getId = function(selector) {\r\n      var options = _.extend({}, this.$$options, {\r\n        fields: { _id: 1 },\r\n        reactive: false,\r\n        transform: null\r\n      });\r\n\r\n      var doc = this.$$collection.findOne(selector, options);\r\n\r\n      if (doc) return doc._id;\r\n      if (selector instanceof Mongo.ObjectID) return selector;\r\n      if (_.isString(selector)) return selector;\r\n      return new Mongo.ObjectID();\r\n    };\r\n\r\n    return AngularMeteorObject;\r\n}]);\r\n\r\n\r\nangularMeteorObject.factory('$meteorObject', [\r\n  '$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject',\r\n  function($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\r\n    function $meteorObject(collection, id, auto, options) {\r\n      // Validate parameters\r\n      if (!collection) {\r\n        throw new TypeError(\"The first argument of $meteorObject is undefined.\");\r\n      }\r\n\r\n      if (!angular.isFunction(collection.findOne)) {\r\n        throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\r\n      }\r\n\r\n      var data = new AngularMeteorObject(collection, id, options);\r\n      // Making auto default true - http://stackoverflow.com/a/15464208/1426570\r\n      data._auto = auto !== false;\r\n      _.extend(data, $meteorObject);\r\n      data._setAutos();\r\n      return data;\r\n    }\r\n\r\n    $meteorObject._setAutos = function() {\r\n      var self = this;\r\n\r\n      this.autorunComputation = $meteorUtils.autorun($rootScope, function() {\r\n        self.reset(true);\r\n      });\r\n\r\n      // Deep watches the model and performs autobind\r\n      this.unregisterAutoBind = this._auto && $rootScope.$watch(function(){\r\n        return self.getRawObject();\r\n      }, function (item, oldItem) {\r\n        if (item !== oldItem) self.save();\r\n      }, true);\r\n\r\n      this.unregisterAutoDestroy = $rootScope.$on('$destroy', function() {\r\n        if (self && self.stop) self.pop();\r\n      });\r\n    };\r\n\r\n    return $meteorObject;\r\n}]);\r\n\r\nangularMeteorObject.run([\r\n  '$rootScope', '$meteorObject', '$meteorStopper',\r\n  function ($rootScope, $meteorObject, $meteorStopper) {\r\n    var scopeProto = Object.getPrototypeOf($rootScope);\r\n    scopeProto.$meteorObject = $meteorStopper($meteorObject);\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-object.js\n **/","/*global\r\n angular, _, Package, Meteor\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorUser = angular.module('angular-meteor.user', [\r\n  'angular-meteor.utils',\r\n  'angular-meteor.core'\r\n]);\r\n\r\n// requires package 'accounts-password'\r\nangularMeteorUser.service('$meteorUser', [\r\n  '$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings',\r\n  function($rootScope, $meteorUtils, $q, $angularMeteorSettings){\r\n\r\n    var pack = Package['accounts-base'];\r\n    if (!pack) return;\r\n\r\n    var self = this;\r\n    var Accounts = pack.Accounts;\r\n\r\n    this.waitForUser = function(){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var deferred = $q.defer();\r\n\r\n      $meteorUtils.autorun($rootScope, function(){\r\n        if ( !Meteor.loggingIn() )\r\n          deferred.resolve( Meteor.user() );\r\n      }, true);\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    this.requireUser = function(){\r\n      if (!$angularMeteorSettings.suppressWarnings) {\r\n        console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n      }\r\n\r\n      var deferred = $q.defer();\r\n\r\n      $meteorUtils.autorun($rootScope, function(){\r\n        if ( !Meteor.loggingIn() ) {\r\n          if ( Meteor.user() === null)\r\n            deferred.reject(\"AUTH_REQUIRED\");\r\n          else\r\n            deferred.resolve( Meteor.user() );\r\n        }\r\n      }, true);\r\n\r\n      return deferred.promise;\r\n    };\r\n\r\n    this.requireValidUser = function(validatorFn) {\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      return self.requireUser(true).then(function(user){\r\n        var valid = validatorFn( user );\r\n\r\n        if ( valid === true )\r\n          return user;\r\n        else if ( typeof valid === \"string\" )\r\n          return $q.reject( valid );\r\n        else\r\n          return $q.reject( \"FORBIDDEN\" );\r\n\t    });\r\n\t  };\r\n\r\n    this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\r\n    this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\r\n    this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\r\n    this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\r\n    this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\r\n    this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\r\n    this.logout = $meteorUtils.promissor(Meteor, 'logout');\r\n    this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\r\n    this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\r\n    this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\r\n    this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\r\n    this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\r\n    this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\r\n    this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\r\n    this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\r\n  }\r\n]);\r\n\r\nangularMeteorUser.run([\r\n  '$rootScope', '$angularMeteorSettings', '$$Core',\r\n  function($rootScope, $angularMeteorSettings, $$Core){\r\n\r\n    let ScopeProto = Object.getPrototypeOf($rootScope);\r\n    _.extend(ScopeProto, $$Core);\r\n\r\n    $rootScope.autorun(function(){\r\n      if (!Meteor.user) return;\r\n      $rootScope.currentUser = Meteor.user();\r\n      $rootScope.loggingIn = Meteor.loggingIn();\r\n    });\r\n  }\r\n]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-user.js\n **/","/*global\r\n angular, _, Meteor\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils']);\r\n\r\nangularMeteorMethods.service('$meteorMethods', [\r\n  '$q', '$meteorUtils', '$angularMeteorSettings',\r\n  function($q, $meteorUtils, $angularMeteorSettings) {\r\n    this.call = function(){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      var deferred = $q.defer();\r\n      var fulfill = $meteorUtils.fulfill(deferred);\r\n      var args = _.toArray(arguments).concat(fulfill);\r\n      Meteor.call.apply(this, args);\r\n      return deferred.promise;\r\n    };\r\n  }\r\n]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-methods.js\n **/","/*global\r\n angular, Session\r\n */\r\n\r\n'use strict';\r\nvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils']);\r\n\r\nangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings',\r\n  function ($meteorUtils, $parse, $angularMeteorSettings) {\r\n    return function (session) {\r\n\r\n      return {\r\n\r\n        bind: function(scope, model) {\r\n          if (!$angularMeteorSettings.suppressWarnings)\r\n            console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n          var getter = $parse(model);\r\n          var setter = getter.assign;\r\n          $meteorUtils.autorun(scope, function() {\r\n            setter(scope, Session.get(session));\r\n          });\r\n\r\n          scope.$watch(model, function(newItem, oldItem) {\r\n            Session.set(session, getter(scope));\r\n          }, true);\r\n\r\n        }\r\n      };\r\n    };\r\n  }\r\n]);\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-session.js\n **/","/*global\r\n angular, Package\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils']);\r\n\r\n// requires package 'mdg:camera'\r\nangularMeteorCamera.service('$meteorCamera', [\r\n  '$q', '$meteorUtils', '$angularMeteorSettings',\r\n  function ($q, $meteorUtils, $angularMeteorSettings) {\r\n    if (!$angularMeteorSettings.suppressWarnings)\r\n      console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n    var pack = Package['mdg:camera'];\r\n    if (!pack) return;\r\n\r\n    var MeteorCamera = pack.MeteorCamera;\r\n\r\n    this.getPicture = function(options){\r\n      if (!$angularMeteorSettings.suppressWarnings)\r\n        console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\r\n\r\n      options = options || {};\r\n      var deferred = $q.defer();\r\n      MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\r\n      return deferred.promise;\r\n    };\r\n  }\r\n]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-camera.js\n **/","/*global\r\n angular\r\n */\r\n\r\n'use strict';\r\n\r\nvar angularMeteorStopper = angular.module('angular-meteor.stopper',\r\n  ['angular-meteor.subscribe']);\r\n\r\nangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe',\r\n  function($q, $meteorSubscribe) {\r\n    function $meteorStopper($meteorEntity) {\r\n      return function() {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        var meteorEntity = $meteorEntity.apply(this, args);\r\n\r\n        angular.extend(meteorEntity, $meteorStopper);\r\n        meteorEntity.$$scope = this;\r\n\r\n        this.$on('$destroy', function () {\r\n          meteorEntity.stop();\r\n          if (meteorEntity.subscription) meteorEntity.subscription.stop();\r\n        });\r\n\r\n        return meteorEntity;\r\n      };\r\n    }\r\n\r\n    $meteorStopper.subscribe = function() {\r\n      var args = Array.prototype.slice.call(arguments);\r\n      this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\r\n      return this;\r\n    };\r\n\r\n    return $meteorStopper;\r\n}]);\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-stopper.js\n **/","export const module = 'angular-meteor.utilities';\nexport const utils = '$$utils';\n\nangular.module(module, [])\n\n/*\n  A utility service which is provided with general utility functions\n */\n.service(utils, [\n  '$rootScope',\n\n  function($rootScope) {\n    // Checks if an object is a cursor\n    this.isCursor = (obj) => {\n      return obj instanceof Meteor.Collection.Cursor;\n    };\n\n    // Cheecks if an object is a scope\n    this.isScope = (obj) => {\n      return obj instanceof $rootScope.constructor;\n    };\n\n    // Checks if two objects are siblings\n    this.areSiblings = (obj1, obj2) => {\n      return _.isObject(obj1) && _.isObject(obj2) &&\n        Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n    };\n\n    // Binds function into a scpecified context. If an object is provided, will bind every\n    // value in the object which is a function. If a tap function is provided, it will be\n    // called right after the function has been invoked.\n    this.bind = (fn, context, tap) => {\n      tap = _.isFunction(tap) ? tap : angular.noop;\n      if (_.isFunction(fn)) return bindFn(fn, context, tap);\n      if (_.isObject(fn)) return bindObj(fn, context, tap);\n      return fn;\n    };\n\n    const bindFn = (fn, context, tap) => {\n      return (...args) => {\n        const result = fn.apply(context, args);\n        tap.call(context, {\n          result,\n          args\n        });\n        return result;\n      };\n    };\n\n    const bindObj = (obj, context, tap) => {\n      return _.keys(obj).reduce((bound, k) => {\n        bound[k] = this.bind(obj[k], context, tap);\n        return bound;\n      }, {});\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/utils.js\n **/","export const module = 'angular-meteor.mixer';\nexport const Mixer = '$Mixer';\n\nangular.module(module, [])\n\n/*\n  A service which lets us apply mixins into the `ChildScope` prototype.\n  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n  and any time a `ChildScope` prototype is created\n  it will be extended by the `$Mixer`.\n  This concept is good because it keeps our code\n  clean and simple, and easy to extend.\n  So any time we would like to define a new behaviour to our scope,\n  we will just use the `$Mixer` service.\n */\n.service(Mixer, function() {\n  this._mixins = [];\n\n  // Adds a new mixin\n  this.mixin = (mixin) => {\n    if (!_.isObject(mixin)) {\n      throw Error('argument 1 must be an object');\n    }\n\n    this._mixins = _.union(this._mixins, [mixin]);\n    return this;\n  };\n\n  // Removes a mixin. Useful mainly for test purposes\n  this._mixout = (mixin) => {\n    this._mixins = _.without(this._mixins, mixin);\n    return this;\n  };\n\n  // Invoke function mixins with the provided context and arguments\n  this._construct = (context, ...args) => {\n    this._mixins.filter(_.isFunction).forEach((mixin) => {\n      mixin.call(context, ...args);\n    });\n\n    return context;\n  };\n\n  // Extend prototype with the defined mixins\n  this._extend = (obj) => {\n    return _.extend(obj, ...this._mixins);\n  };\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/mixer.js\n **/","import { module as mixerModule, Mixer } from './mixer';\n\nexport const module = 'angular-meteor.scope'\n\nangular.module(module, [\n  mixerModule\n])\n\n\n.run([\n  '$rootScope',\n  Mixer,\n\n  function($rootScope, $Mixer) {\n    const Scope = $rootScope.constructor;\n    const $new = $rootScope.$new;\n\n    // Extends and constructs every newly created scope without affecting the root scope\n    Scope.prototype.$new = function(isolate, parent) {\n      const firstChild = this === $rootScope && !this.$$ChildScope;\n      const scope = $new.call(this, isolate, parent);\n\n      // If the scope is isolated we would like to extend it aswell\n      if (isolate) {\n        // The scope is the prototype of its upcomming child scopes, so the methods would\n        // be accessable to them as well\n        $Mixer._extend(scope);\n      }\n      // Else, if this is the first child of the root scope we would like to apply the extensions\n      // without affection the root scope\n      else if (firstChild) {\n        // Creating a middle layer where all the extensions are gonna be applied to\n        scope.__proto__ = this.$$ChildScope.prototype =\n          $Mixer._extend(Object.create(this));\n      }\n\n      return $Mixer._construct(scope);\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/scope.js\n **/","import { module as utilsModule, utils } from './utils';\nimport { module as mixerModule } from './mixer';\n\nexport const module = 'angular-meteor.core';\nexport const Core = '$$Core';\n\nangular.module(module, [\n  utilsModule,\n  mixerModule\n])\n\n\n/*\n  A mixin which provides us with core Meteor functions.\n */\n.factory(Core, [\n  '$q',\n  utils,\n\n  function($q, $$utils) {\n    function $$Core() {}\n\n    // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n    $$Core.autorun = function(fn, options = {}) {\n      fn = this.$bindToContext(fn);\n\n      if (!_.isFunction(fn)) {\n        throw Error('argument 1 must be a function');\n      }\n      if (!_.isObject(options)) {\n        throw Error('argument 2 must be an object');\n      }\n\n      const computation = Tracker.autorun(fn, options);\n      this.$$autoStop(computation);\n      return computation;\n    };\n\n    // Calls Meteor.subscribe() which will be digested after each invokation\n    // and automatically destroyed\n    $$Core.subscribe = function(name, fn, cb) {\n      fn = this.$bindToContext(fn || angular.noop);\n      cb = cb ? this.$bindToContext(cb) : angular.noop;\n\n      if (!_.isString(name)) {\n        throw Error('argument 1 must be a string');\n      }\n      if (!_.isFunction(fn)) {\n        throw Error('argument 2 must be a function');\n      }\n      if (!_.isFunction(cb) && !_.isObject(cb)) {\n        throw Error('argument 3 must be a function or an object');\n      }\n\n      const result = {};\n\n      const computation = this.autorun(() => {\n        let args = fn();\n        if (angular.isUndefined(args)) args = [];\n\n        if (!_.isArray(args)) {\n          throw Error(`reactive function's return value must be an array`);\n        }\n\n        const subscription = Meteor.subscribe(name, ...args, cb);\n        result.ready = subscription.ready.bind(subscription);\n        result.subscriptionId = subscription.subscriptionId;\n      });\n\n      // Once the computation has been stopped,\n      // any subscriptions made inside will be stopped as well\n      result.stop = computation.stop.bind(computation);\n      return result;\n    };\n\n    // Calls Meteor.call() wrapped by a digestion cycle\n    $$Core.callMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n      return Meteor.call(...args, fn);\n    };\n\n    // Calls Meteor.apply() wrapped by a digestion cycle\n    $$Core.applyMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext(fn);\n      return Meteor.apply(...args, fn);\n    };\n\n    $$Core.$$autoStop = function(stoppable) {\n      this.$on('$destroy', stoppable.stop.bind(stoppable));\n    };\n\n    // Digests scope only if there is no phase at the moment\n    $$Core.$$throttledDigest = function() {\n      const isDigestable = !this.$$destroyed &&\n        !this.$$phase &&\n        !this.$root.$$phase;\n\n      if (isDigestable) this.$digest();\n    };\n\n    // Creates a promise only that the digestion cycle will be called at its fulfillment\n    $$Core.$$defer = function() {\n      const deferred = $q.defer();\n      // Once promise has been fulfilled, digest\n      deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n      return deferred;\n    };\n\n    // Binds an object or a function to the scope to the view model and digest it once it is invoked\n    $$Core.$bindToContext = function(fn) {\n      return $$utils.bind(fn, this, this.$$throttledDigest.bind(this));\n    };\n\n    return $$Core;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/core.js\n **/","import { module as utilsModule, utils } from './utils';\nimport { module as mixerModule, Mixer } from './mixer';\nimport { module as coreModule } from './core';\n\nexport const module = 'angular-meteor.view-model';\nexport const ViewModel = '$$ViewModel';\nexport const reactive = '$reactive';\n\nangular.module(module, [\n  utilsModule,\n  mixerModule,\n  coreModule\n])\n\n/*\n  A mixin which lets us bind a view model into a scope.\n  Note that only a single view model can be bound,\n  otherwise the scope might behave unexpectedly.\n  Mainly used to define the controller as the view model,\n  and very useful when wanting to use Angular's `controllerAs` syntax.\n */\n.factory(ViewModel, [\n  utils,\n  Mixer,\n\n  function($$utils, $Mixer) {\n    function $$ViewModel(vm = this) {\n      // Defines the view model on the scope.\n      this.$$vm = vm;\n    }\n\n    // Gets an object, wraps it with scope functions and returns it\n    $$ViewModel.viewModel = function(vm) {\n      if (!_.isObject(vm)) {\n        throw Error('argument 1 must be an object');\n      }\n\n      // Apply mixin functions\n      $Mixer._mixins.forEach((mixin) => {\n        // Reject methods which starts with double $\n        const keys = _.keys(mixin).filter(k => k.match(/^(?!\\$\\$).*$/));\n        const proto = _.pick(mixin, keys);\n        // Bind all the methods to the prototype\n        const boundProto = $$utils.bind(proto, this);\n        // Add the methods to the view model\n        _.extend(vm, boundProto);\n      });\n\n      // Apply mixin constructors on the view model\n      $Mixer._construct(this, vm);\n      return vm;\n    };\n\n    // Override $$Core.$bindToContext to be bound to view model instead of scope\n    $$ViewModel.$bindToContext = function(fn) {\n      return $$utils.bind(fn, this.$$vm, this.$$throttledDigest.bind(this));\n    };\n\n    return $$ViewModel;\n  }\n])\n\n\n/*\n  Illustrates the old API where a view model is created using $reactive service\n */\n.service(reactive, [\n  utils,\n\n  function($$utils) {\n    class Reactive {\n      constructor(vm) {\n        if (!_.isObject(vm)) {\n          throw Error('argument 1 must be an object');\n        }\n\n        _.defer(() => {\n          if (!this._attached) {\n            console.warn('view model was not attached to any scope');\n          }\n        });\n\n        this._vm = vm;\n      }\n\n      attach(scope) {\n        this._attached = true;\n\n        if (!$$utils.isScope(scope)) {\n          throw Error('argument 1 must be a scope');\n        }\n\n        const viewModel = scope.viewModel(this._vm);\n\n        // Similar to the old/Meteor API\n        viewModel.call = viewModel.callMethod;\n        viewModel.apply = viewModel.applyMethod;\n\n        return viewModel;\n      }\n    }\n\n    return (vm) => new Reactive(vm);\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/view-model.js\n **/","import { module as utilsModule, utils } from './utils';\nimport { module as mixerModule } from './mixer';\nimport { module as coreModule } from './core';\nimport { module as viewModelModule } from './view-model';\n\nexport const module = 'angular-meteor.reactive';\nexport const Reactive = '$$Reactive';\n\nangular.module(module, [\n  utilsModule,\n  mixerModule,\n  coreModule,\n  viewModelModule\n])\n\n\n/*\n  A mixin which enhance our reactive abilities by providing methods\n  that are capable of updating our scope reactively.\n */\n.factory(Reactive, [\n  '$parse',\n  utils,\n  '$angularMeteorSettings',\n\n  function($parse, $$utils, $angularMeteorSettings) {\n    function $$Reactive(vm = this) {\n      // Helps us track changes made in the view model\n      vm.$$dependencies = {};\n    }\n\n    // Gets an object containing functions and define their results as reactive properties.\n    // Once a return value has been changed the property will be reset.\n    $$Reactive.helpers = function(props = {}) {\n      if (!_.isObject(props)) {\n        throw Error('argument 1 must be an object');\n      }\n\n      _.each(props, (v, k, i) => {\n        if (!_.isFunction(v)) {\n          throw Error(`helper ${i + 1} must be a function`);\n        }\n\n        if (!this.$$vm.$$dependencies[k]) {\n        // Registers a new dependency to the specified helper\n          this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n        }\n\n        this.$$setFnHelper(k, v);\n      });\n    };\n\n    // Gets a model reactively\n    $$Reactive.getReactively = function(k, isDeep = false) {\n      if (!_.isBoolean(isDeep)) {\n        throw Error('argument 2 must be a boolean');\n      }\n\n      return this.$$reactivateEntity(k, this.$watch, isDeep);\n    };\n\n    // Gets a collection reactively\n    $$Reactive.getCollectionReactively = function(k) {\n      return this.$$reactivateEntity(k, this.$watchCollection);\n    };\n\n    // Gets an entity reactively, and once it has been changed the computation will be recomputed\n    $$Reactive.$$reactivateEntity = function(k, watcher, ...watcherArgs) {\n      if (!_.isString(k)) {\n        throw Error('argument 1 must be a string');\n      }\n\n      if (!this.$$vm.$$dependencies[k]) {\n        this.$$vm.$$dependencies[k] = new Tracker.Dependency();\n        this.$$watchEntity(k, watcher, ...watcherArgs);\n      }\n\n      this.$$vm.$$dependencies[k].depend();\n      return $parse(k)(this.$$vm);\n    };\n\n    // Watches for changes in the view model, and if so will notify a change\n    $$Reactive.$$watchEntity = function(k, watcher, ...watcherArgs) {\n      // Gets a deep property from the view model\n      const getVal = _.partial($parse(k), this.$$vm);\n      const initialVal = getVal();\n\n      // Watches for changes in the view model\n      watcher.call(this, getVal, (val, oldVal) => {\n        const hasChanged =\n          val !== initialVal ||\n          val !== oldVal;\n\n        // Notify if a change has been detected\n        if (hasChanged) this.$$changed(k);\n      }, ...watcherArgs);\n    };\n\n    // Invokes a function and sets the return value as a property\n    $$Reactive.$$setFnHelper = function(k, fn) {\n      this.autorun((computation) => {\n        // Invokes the reactive functon\n        const model = fn.apply(this.$$vm);\n\n        // Ignore notifications made by the following handler\n        Tracker.nonreactive(() => {\n          // If a cursor, observe its changes and update acoordingly\n          if ($$utils.isCursor(model)) {\n            const observation = this.$$handleCursor(k, model);\n\n            computation.onInvalidate(() => {\n              observation.stop();\n              this.$$vm[k].splice(0);\n            });\n          } else {\n            this.$$handleNonCursor(k, model);\n          }\n\n          // Notify change and update the view model\n          this.$$changed(k);\n        });\n      });\n    };\n\n    // Sets a value helper as a setter and a getter which will notify computations once used\n    $$Reactive.$$setValHelper = function(k, v, watch = true) {\n      // If set, reactives property\n      if (watch) {\n        const isDeep = _.isObject(v);\n        this.getReactively(k, isDeep);\n      }\n\n      Object.defineProperty(this.$$vm, k, {\n        configurable: true,\n        enumerable: true,\n\n        get: () => {\n          return v;\n        },\n        set: (newVal) => {\n          v = newVal;\n          this.$$changed(k);\n        }\n      });\n    };\n\n    // Fetching a cursor and updates properties once the result set has been changed\n    $$Reactive.$$handleCursor = function(k, cursor) {\n      // If not defined set it\n      if (angular.isUndefined(this.$$vm[k])) {\n        this.$$setValHelper(k, cursor.fetch(), false);\n      }\n      // If defined update it\n      else {\n        const diff = jsondiffpatch.diff(this.$$vm[k], cursor.fetch());\n        jsondiffpatch.patch(this.$$vm[k], diff);\n      }\n\n      // Observe changes made in the result set\n      const observation = cursor.observe({\n        addedAt: (doc, atIndex) => {\n          if (!observation) return;\n          this.$$vm[k].splice(atIndex, 0, doc);\n          this.$$changed(k);\n        },\n        changedAt: (doc, oldDoc, atIndex) => {\n          const diff = jsondiffpatch.diff(this.$$vm[k][atIndex], doc);\n          jsondiffpatch.patch(this.$$vm[k][atIndex], diff);\n          this.$$changed(k);\n        },\n        movedTo: (doc, fromIndex, toIndex) => {\n          this.$$vm[k].splice(fromIndex, 1);\n          this.$$vm[k].splice(toIndex, 0, doc);\n          this.$$changed(k);\n        },\n        removedAt: (oldDoc, atIndex) => {\n          this.$$vm[k].splice(atIndex, 1);\n          this.$$changed(k);\n        }\n      });\n\n      return observation;\n    };\n\n    $$Reactive.$$handleNonCursor = function(k, data) {\n      let v = this.$$vm[k];\n\n      if (angular.isDefined(v)) {\n        delete this.$$vm[k];\n        v = null;\n      }\n\n      if (angular.isUndefined(v)) {\n        this.$$setValHelper(k, data);\n      }\n      // Update property if the new value is from the same type\n      else if ($$utils.areSiblings(v, data)) {\n        const diff = jsondiffpatch.diff(v, data);\n        jsondiffpatch.patch(v, diff);\n        this.$$changed(k);\n      } else {\n        this.$$vm[k] = data;\n      }\n    };\n\n    // Notifies dependency in view model\n    $$Reactive.$$depend = function(k) {\n      this.$$vm.$$dependencies[k].depend();\n    };\n\n    // Notifies change in view model\n    $$Reactive.$$changed = function(k) {\n      this.$$throttledDigest();\n      this.$$vm.$$dependencies[k].changed();\n    };\n\n    return $$Reactive;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/reactive.js\n **/"],"sourceRoot":""}