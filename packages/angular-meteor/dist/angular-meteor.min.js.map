{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-meteor.min.js","webpack:///webpack/bootstrap 92defbad9aebff27e73c","webpack:///./src/angular-meteor.js","webpack:///./src/lib/get-updates.js","webpack:///./src/lib/underscore.js","webpack:///external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}","webpack:///./src/lib/diff-array.js","webpack:///./src/modules/angular-meteor-settings.js","webpack:///./src/modules/angular-meteor-ironrouter.js","webpack:///./src/modules/angular-meteor-utils.js","webpack:///./src/modules/angular-meteor-subscribe.js","webpack:///./src/modules/angular-meteor-collection.js","webpack:///./src/modules/angular-meteor-object.js","webpack:///./src/modules/angular-meteor-user.js","webpack:///./src/modules/angular-meteor-methods.js","webpack:///./src/modules/angular-meteor-session.js","webpack:///./src/modules/angular-meteor-camera.js","webpack:///./src/modules/angular-meteor-stopper.js","webpack:///./src/modules/utils.js","webpack:///./src/modules/mixer.js","webpack:///./src/modules/scope.js","webpack:///./src/modules/core.js","webpack:///./src/modules/view-model.js","webpack:///./src/modules/reactive.js","webpack:///external \"jsondiffpatch\"","webpack:///./src/modules/templates.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_3__","__WEBPACK_EXTERNAL_MODULE_22__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","_utils","_mixer","_scope","_core","_viewModel","_reactive","_templates","name","angular","run","Mixer","Core","ViewModel","Reactive","$Mixer","$$Core","$$ViewModel","$$Reactive","mixin","service","$meteorCollection","$meteorCollectionFS","$meteorObject","$meteorMethods","$meteorSession","$meteorSubscribe","$meteorUtils","$meteorCamera","$meteorUser","_this","collection","collectionFS","object","subscribe","session","autorun","getCollectionByName","getPicture","forEach","method","_interopRequireDefault","obj","__esModule","default","_underscore","_underscore2","utils","rip","level","reduce","clone","v","k","isObject","toPaths","keys","getKeyPaths","values","getDeepValues","map","isEmpty","isArray","subKey","flatten","arr","push","setFilled","assert","result","msg","throwErr","Error","getDifference","src","dst","isShallow","compare","srcKeys","dstKeys","chain","concat","uniq","without","diff","srcValue","dstValue","isDate","getTime","valueDiff","getUpdates","paths","set","createSet","unset","createUnset","pull","createPull","updates","undefinedKeys","getUndefinedKeys","omit","pick","arrKeyPaths","split","match","compact","filter","isUndefined","Package","underscore","_","_module","diffArray","lastSeqArray","seqArray","callbacks","preventNestedDiff","diffFn","minimongo","LocalCollection","_diffQueryOrderedChanges","DiffSequence","diffQueryOrderedChanges","oldObjIds","newObjIds","posOld","posNew","posCur","lengthCur","length","each","doc","i","_id","idStringify","addedBefore","before","position","pos","addedAt","movedBefore","prevPosition","movedTo","removed","removedAt","idString","has","idParse","newItem","oldItem","changedAt","_idStringify","MongoID","_idParse","shallow","deepCopyChanges","setDiff","$set","deepKey","setDeep","deepCopyRemovals","unsetDiff","$unset","unsetDeep","getChanges","newCollection","oldCollection","diffMethod","changes","added","changed","item","index","selector","modifier","fromIndex","toIndex","initialKeys","initial","lastKey","last","subObj","nextKey","isNumStr","parseInt","isHash","deepObj","getDeep","splice","getPrototypeOf","prototype","str","constant","suppressWarnings","$compile","$document","$rootScope","Router","isLoaded","onAfterAction","req","res","next","Tracker","afterFlush","$$phase","$apply","_typeof","Symbol","iterator","constructor","angularMeteorUtils","$q","$timeout","$angularMeteorSettings","self","scope","fn","console","warn","comp","firstRun","noop","$on","stop","stripDollarPrefixedKeys","data","Date","File","EJSON","toJSONValue","$type","FS","out","charAt","fulfill","deferred","boundError","boundResult","err","reject","resolve","promissor","defer","args","toArray","arguments","apply","promise","promiseAll","promises","allPromise","all","string","Mongo","Collection","get","findIndexById","foundDoc","find","colDoc","equals","indexOf","$meteorAutorun","angularMeteorSubscribe","_subscribe","subscription","lastArg","isFunction","onStop","_onStop","pop","onReady","$$state","status","Array","slice","Meteor","angularMeteorCollection","AngularMeteorCollection","curDefFunc","diffArrayFunc","autoClientSave","_serverBackup","_diffArrayFunc","_hObserve","_hNewCurAutorun","_hDataAutorun","isDefined","$$collection","cursor","extend","_startCurAutorun","onInvalidate","_stopCursor","_setAutoClientSave","_updateCursor","save","docs","useUnsetModifier","_upsertDoc","createFulfill","partial","docId","isExist","findOne","update","action","insert","_updateDiff","callback","setters","$pull","prop","puller","_updateParallel","done","after","affectedDocsNum","remove","keyOrDocs","keyOrDoc","pluck","check","Match","OneOf","String","ObjectID","key","_removeDoc","_stopObserving","observe","atIndex","_setServerUpdateMode","oldDoc","removedIndex","fetch","_serverMode","_unsetServerUpdateMode","_hUnsetTimeout","_unsetAutoClientSave","cancel","_saveChanges","_hRegAutoBind","$watch","nItems","oItems","addedDocs","reverse","descriptor","removedDocs","reactiveFunc","TypeError","bind","$meteorStopper","scopeProto","angularMeteorObject","AngularMeteorObject","options","helpers","_helpers","create","collectionExtension","$$options","$$id","_getId","$$internalProps","getRawObject","copy","custom","mods","when","reset","keepClientProps","clientProps","docKeys","docExtension","intersection","serverProps","removedKeys","difference","unregisterAutoDestroy","unregisterAutoBind","autorunComputation","fields","reactive","transform","isString","auto","_auto","_setAutos","angularMeteorUser","pack","Accounts","waitForUser","loggingIn","user","requireUser","requireValidUser","validatorFn","then","valid","loginWithPassword","createUser","changePassword","forgotPassword","resetPassword","verifyEmail","logout","logoutOtherClients","loginWithFacebook","loginWithTwitter","loginWithGoogle","loginWithGithub","loginWithMeteorDeveloperAccount","loginWithMeetup","loginWithWeibo","ScopeProto","currentUser","angularMeteorMethods","angularMeteorSession","$parse","model","getter","setter","assign","Session","angularMeteorCamera","MeteorCamera","angularMeteorStopper","$meteorEntity","meteorEntity","$$scope","undefined","bindFn","context","tap","_len","_key","bindObj","bound","isCursor","Cursor","isScope","isViewModel","$$dependencies","areSiblings","obj1","obj2","_toConsumableArray","arr2","from","caller","_mixins","_autoExtend","_autoConstruct","union","_extend","_construct","_mixout","_$defaults","defaults","pattern","mixins","boundMixin","methodName","methodHandler","methodContext","recentCaller","_len2","_key2","configurable","enumerable","Scope","$new","$$utils","$bindToContext","computation","$$autoStop","subName","cb","hooks","onStart","hook","hasOwnProperty","_Meteor","ready","subscriptionId","callMethod","_Meteor2","applyMethod","_Meteor3","stoppable","removeListener","baseStop","$$throttledDigest","isDigestable","$$destroyed","$root","$digest","$$defer","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","writable","protoProps","staticProps","viewModel","vm","_attached","_vm","_jsondiffpatch","_jsondiffpatch2","Dependency","$$setFnHelper","getReactively","isDeep","isBoolean","$$reactivateEntity","getCollectionReactively","$watchCollection","watcher","watcherArgs","$$watchEntity","depend","_this2","getVal","initialVal","val","oldVal","hasChanged","$$changed","_this3","activeObservation","lastModel","lastModelData","nonreactive","modelData","$$setValHelper","handle","$$handleCursor","observation","patch","$$handleNonCursor","_this4","watch","newVal","_this5","$$depend","e"],"mappings":";CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,cAAAA,QAAA,kBACA,kBAAAC,gBAAAC,IACAD,QAAA,8BAAAJ,GACA,gBAAAC,SACAA,QAAA,cAAAD,EAAAG,QAAA,cAAAA,QAAA,kBAEAJ,EAAA,cAAAC,EAAAD,EAAA,EAAAA,EAAA,gBACCO,KAAA,SAAAC,EAAAC,GACD,MCCgB,UAAUC,GCP1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAV,OAGA,IAAAC,GAAAU,EAAAD,IACAV,WACAY,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAb,EAAAD,QAAAC,IAAAD,QAAAS,GAGAR,EAAAY,QAAA,EAGAZ,EAAAD,QAvBA,GAAAW,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDiBM,SAASR,EAAQD,EAASS,GAE/B,YAEAS,QAAOC,eAAenB,EAAS,cAC7BoB,OAAO,IAGTX,EAAoB,GAEpBA,EAAoB,GAEpBA,EAAoB,GAEpBA,EAAoB,GAEpBA,EAAoB,GAEpBA,EAAoB,GAEpBA,EAAoB,GAEpBA,EAAoB,IAEpBA,EAAoB,IAEpBA,EAAoB,IAEpBA,EAAoB,IAEpBA,EAAoB,IAEpBA,EAAoB,GAEpB,IAAIY,GAASZ,EAAoB,IAE7Ba,EAASb,EAAoB,IAE7Bc,EAASd,EAAoB,IAE7Be,EAAQf,EAAoB,IAE5BgB,EAAahB,EAAoB,IAEjCiB,EAAYjB,EAAoB,IAEhCkB,EAAalB,EAAoB,IE5EhCmB,EAAO,gBFsFZ5B,cErFc4B,EAEfC,QAAQ5B,OAAO2B,GFwFdP,EAAOO,KAAMN,EAAOM,KAAML,EAAOK,KAAMJ,EAAMI,KAAMH,EAAWG,KAAMF,EAAUE,KAAMD,EAAWC,KE7E9F,4BACA,uBACA,2BACA,4BACA,wBACA,sBACA,yBACA,yBACA,0BAIDE,KAAIR,EAAAS,MAAAP,EAAAQ,KAAAP,EAAAQ,UAAAP,EAAAQ,SAMH,SAASC,EAAQC,EAAQC,EAAaC,GAEpCH,EACGI,MAAMH,GACNG,MAAMF,GACNE,MAAMD,MAMZE,QAAQ,WACP,oBACA,sBACA,gBACA,iBACA,iBACA,mBACA,eACA,gBACA,cACA,SAASC,EAAmBC,EAAqBC,EAC/CC,EAAgBC,EAAgBC,EAAkBC,EAClDC,EAAeC,GF+ChB,GAAIC,GAAQ7C,IE9CXA,MAAK8C,WAAaV,EAClBpC,KAAK+C,aAAeV,EACpBrC,KAAKgD,OAASV,EACdtC,KAAKiD,UAAYR,EAAiBQ,UAClCjD,KAAKS,KAAO8B,EAAe9B,KAC3BT,KAAKkD,QAAUV,EACfxC,KAAKmD,QAAUT,EAAaS,QAC5BnD,KAAKoD,oBAAsBV,EAAaU,oBACxCpD,KAAKqD,WAAaV,EAAcU,YAI9B,oBACA,cACA,mBACA,cACA,aACA,iBACA,iBACA,gBACA,cACA,kCACA,oBACA,kBACA,kBACA,kBACA,mBACA,iBACA,SACA,sBACAC,QAAQ,SAACC,GACTV,EAAKU,GAAUX,EAAYW,QFgChC3D,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASS,GAE/B,YAMA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAJvF,GAAIG,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,IGjJ3C,WACE,GAAIhE,GAAS4B,QAAQ5B,OAAO,iBAExBkE,EAAQ,WACV,GAAIC,GAAM,QAANA,GAAeN,EAAKO,GACtB,MAAY,GAARA,KAEGH,aAAEI,OAAOR,EAAK,SAASS,EAAOC,EAAGC,GAGtC,MAFAD,GAAIN,aAAEQ,SAASF,GAAKJ,EAAII,IAAKH,GAASG,EACtCD,EAAME,GAAKD,EACJD,QAIPI,EAAU,SAASb,GACrB,GAAIc,GAAOC,EAAYf,GACnBgB,EAASC,EAAcjB,EAC3B,OAAOI,cAAEb,OAAOuB,EAAME,IAGpBD,EAAc,QAAdA,GAAuBf,GACzB,GAAIc,GAAOV,aAAEU,KAAKd,GAAKkB,IAAI,SAASP,GAClC,GAAID,GAAIV,EAAIW,EACZ,QAAKP,aAAEQ,SAASF,IAAMN,aAAEe,QAAQT,IAAMN,aAAEgB,QAAQV,GAAWC,EAEpDI,EAAYL,GAAGQ,IAAI,SAASG,GACjC,MAAOV,GAAI,IAAMU,KAIrB,OAAOjB,cAAEkB,QAAQR,IAGfG,EAAgB,QAAhBA,GAAyBjB,EAAIuB,GAU/B,MATAA,GAAMA,MAENnB,aAAEY,OAAOhB,GAAKH,QAAQ,SAASa,IACxBN,aAAEQ,SAASF,IAAMN,aAAEe,QAAQT,IAAMN,aAAEgB,QAAQV,GAC9Ca,EAAIC,KAAKd,GAETO,EAAcP,EAAGa,KAGdA,GAcLE,EAAY,SAASzB,EAAKW,EAAGD,GAC1BN,aAAEe,QAAQT,KAAIV,EAAIW,GAAKD,IAG1BgB,EAAS,SAASC,EAAQC,GACvBD,GAAQE,EAASD,IAGpBC,EAAW,SAASD,GACtB,KAAME,OAAM,uBAAyBF,GAGvC,QACEtB,IAAKA,EACLO,QAASA,EACTE,YAAaA,EACbE,cAAeA,EACfQ,UAAWA,EACXC,OAAQA,EACRG,SAAUA,MAIVE,EAAgB,WAClB,GAAIA,GAAgB,SAASC,EAAKC,EAAKC,GACrC,GAAI3B,EAYJ,OAVI2B,GAAY,EACd3B,EAAQ2B,EACDA,IACP3B,EAAQ,GAENA,IACFyB,EAAM3B,EAAMC,IAAI0B,EAAKzB,GACrB0B,EAAM5B,EAAMC,IAAI2B,EAAK1B,IAGhB4B,EAAQH,EAAKC,IAGlBE,EAAU,SAASH,EAAKC,GAC1B,GAAIG,GAAUhC,aAAEU,KAAKkB,GACjBK,EAAUjC,aAAEU,KAAKmB,GAEjBnB,EAAOV,aAAEkC,UACVC,OAAOH,GACPG,OAAOF,GACPG,OACAC,QAAQ,aACRnF,OAEH,OAAOwD,GAAKN,OAAO,SAASkC,EAAM/B,GAChC,GAAIgC,GAAWX,EAAIrB,GACfiC,EAAWX,EAAItB,EAMnB,IAJIP,aAAEyC,OAAOF,IAAavC,aAAEyC,OAAOD,IAC7BD,EAASG,WAAaF,EAASE,YAAWJ,EAAK/B,GAAKiC,GAGtDxC,aAAEQ,SAAS+B,IAAavC,aAAEQ,SAASgC,GAAW,CAChD,GAAIG,GAAYhB,EAAcY,EAAUC,EACxCvC,GAAMoB,UAAUiB,EAAM/B,EAAGoC,OAGlBJ,KAAaC,IACpBF,EAAK/B,GAAKiC,EAGZ,OAAOF,QAIX,OAAOX,MAGLiB,EAAa,WACf,GAAIA,GAAa,SAAShB,EAAKC,EAAKC,GAClC7B,EAAMqB,OAAOtB,aAAEQ,SAASoB,GAAM,oCAC9B3B,EAAMqB,OAAOtB,aAAEQ,SAASqB,GAAM,oCAE9B,IAAIS,GAAOX,EAAcC,EAAKC,EAAKC,GAC/Be,EAAQ5C,EAAMQ,QAAQ6B,GAEtBQ,EAAMC,EAAUF,GAChBG,EAAQC,EAAYJ,GACpBK,EAAOC,EAAWH,GAElBI,IAKJ,OAJAnD,GAAMoB,UAAU+B,EAAS,OAAQN,GACjC7C,EAAMoB,UAAU+B,EAAS,SAAUJ,GACnC/C,EAAMoB,UAAU+B,EAAS,QAASF,GAE3BE,GAGLL,EAAY,SAASF,GACvB,GAAIQ,GAAgBC,EAAiBT,EACrC,OAAO7C,cAAEuD,KAAKV,EAAOQ,IAGnBJ,EAAc,SAASJ,GACzB,GAAIQ,GAAgBC,EAAiBT,GACjCG,EAAQhD,aAAEwD,KAAKX,EAAOQ,EAE1B,OAAOrD,cAAEI,OAAO4C,EAAO,SAASzB,EAAQjB,EAAGC,GAEzC,MADAgB,GAAOhB,IAAK,EACLgB,QAIP4B,EAAa,SAASH,GACxB,GAAIS,GAAczD,aAAEU,KAAKsC,GAAOlC,IAAI,SAASP,GAC3C,GAAImD,GAAQnD,EAAEoD,MAAM,aACpB,OAAOD,IAASA,EAAM,IAGxB,OAAO1D,cAAE4D,QAAQH,GAAarD,OAAO,SAAS8C,EAAM3C,GAElD,MADA2C,GAAK3C,GAAK,KACH2C,QAIPI,EAAmB,SAAS1D,GAC9B,MAAOI,cAAEU,KAAKd,GAAKiE,OAAO,SAAUtD,GAClC,GAAID,GAAIV,EAAIW,EACZ,OAAOP,cAAE8D,YAAYxD,KAIzB,OAAOsC,KAGT7G,GAAOmB,MAAM,aAAc0F,OHiJvB,SAAS7G,EAAQD,EAASS,GAE/B,YAUA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GARvF5C,OAAOC,eAAenB,EAAS,cAC7BoB,OAAO,GAGT,IAAI6C,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,EI/V3C,IAAiB,mBAAbC,eACgC,mBAAvB+D,SAAQC,WACjB,KAAM,IAAItC,OAAM,wBJuWnB5F,cInWckE,cAAK+D,QAAQC,WAAWC,EJoWtClI,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GKhXvBC,EAAAD,QAAAM,GLsXM,SAASL,EAAQD,EAASS,GAE/B,YAMA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAJvF,GAAIG,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GMpXvCmE,EAAUvG,QAAQ5B,OAAO,aAAc,cAE3CmI,GAAQrI,QAAQ,aAAc,aAC5B,SAAS+G,GAAY,QAWVuB,GAAUC,EAAcC,EAAUC,EAAWC,GACpDA,IAAsBA,CAEtB,IAAIC,GAAST,QAAQU,UAAUC,gBAAgBC,0BAC7CZ,QAAQ,iBAAiBa,aAAaC,wBAEpCC,KACAC,KACAC,KACAC,KACAC,KACAC,EAAYf,EAAagB,MAE7BpF,cAAEqF,KAAKhB,EAAU,SAAUiB,EAAKC,GAC9BR,EAAU3D,MAAMoE,IAAKF,EAAIE,MACzBP,EAAOQ,EAAYH,EAAIE,MAAQD,IAGjCvF,aAAEqF,KAAKjB,EAAc,SAAUkB,EAAKC,GAClCT,EAAU1D,MAAMoE,IAAKF,EAAIE,MACzBR,EAAOS,EAAYH,EAAIE,MAAQD,EAC/BL,EAAOO,EAAYH,EAAIE,MAAQD,IArBsCf,EA4BhEM,EAAWC,GAChBW,YAAa,SAAUhJ,EAAI4I,EAAKK,GAC9B,GAAIC,GAAWD,EAAST,EAAOO,EAAYE,IAAWR,CAEtDnF,cAAEqF,KAAKH,EAAQ,SAAUW,EAAKnJ,GACxBmJ,GAAOD,GAAUV,EAAOxI,OAG9ByI,IACAD,EAAOO,EAAY/I,IAAOkJ,EAE1BtB,EAAUwB,QACRpJ,EACA2H,EAASY,EAAOQ,EAAY/I,KAC5BkJ,EACAD,IAIJI,YAAa,SAAUrJ,EAAIiJ,GACzB,GAAIK,GAAed,EAAOO,EAAY/I,IAClCkJ,EAAWD,EAAST,EAAOO,EAAYE,IAAWR,EAAY,CAElEnF,cAAEqF,KAAKH,EAAQ,SAAUW,EAAKnJ,GACxBmJ,GAAOG,GAAuBJ,GAAPC,EACzBX,EAAOxI,KACOsJ,GAAPH,GAAuBA,GAAOD,GACrCV,EAAOxI,OAGXwI,EAAOO,EAAY/I,IAAOkJ,EAE1BtB,EAAU2B,QACRvJ,EACA2H,EAASY,EAAOQ,EAAY/I,KAC5BsJ,EACAJ,EACAD,IAGJO,QAAS,SAAUxJ,GACjB,GAAIsJ,GAAed,EAAOO,EAAY/I,GAEtCsD,cAAEqF,KAAKH,EAAQ,SAAUW,EAAKnJ,GACxBmJ,GAAOG,GAAcd,EAAOxI,aAG3BwI,GAAOO,EAAY/I,IAC1ByI,IAEAb,EAAU6B,UACRzJ,EACA0H,EAAaY,EAAOS,EAAY/I,KAChCsJ,MAKNhG,aAAEqF,KAAKJ,EAAQ,SAAUY,EAAKO,GAC5B,GAAKpG,aAAEqG,IAAIrB,EAAQoB,GAAnB,CAEA,GAAI1J,GAAK4J,EAAQF,GACbG,EAAUlC,EAASwB,OACnBW,EAAUpC,EAAaY,EAAOoB,IAC9BhD,EAAUR,EAAW4D,EAASD,EAAShC,EAEtCvE,cAAEe,QAAQqC,IACbkB,EAAUmC,UAAU/J,EAAI0G,EAASyC,EAAKW,MAzG5C,GAAI9B,GAAkBX,QAAQU,UAAUC,gBACpCe,EAAcf,EAAgBgC,cAAgB3C,QAAQ,YAAY4C,QAAQlB,YAC1Ea,EAAU5B,EAAgBkC,UAAY7C,QAAQ,YAAY4C,QAAQL,OA2GtEnC,GAAU0C,QAAU,SAASzC,EAAcC,EAAUC,GACnD,MAAOH,GAAUC,EAAcC,EAAUC,GAAW,IAGtDH,EAAU2C,gBAAkB,SAAUN,EAASD,GAC7C,GAAIQ,GAAUnE,EAAW4D,EAASD,GAASS,IAE3ChH,cAAEqF,KAAK0B,EAAS,SAASzG,EAAG2G,GAC1BC,EAAQV,EAASS,EAAS3G,MAI9B6D,EAAUgD,iBAAmB,SAAUX,EAASD,GAC9C,GAAIa,GAAYxE,EAAW4D,EAASD,GAASc,MAE7CrH,cAAEqF,KAAK+B,EAAW,SAAS9G,EAAG2G,GAC5BK,EAAUd,EAASS,MA9HJ9C,EAmIToD,WAAa,SAASC,EAAeC,EAAeC,GAC5D,GAAIC,IAAWC,SAAW1B,WAAa2B,WAoBvC,OAlBAH,GAAWD,EAAeD,GACxB1B,QAAS,SAASpJ,EAAIoL,EAAMC,GAC1BJ,EAAQC,MAAMxG,MAAM0G,KAAMA,EAAMC,MAAOA,KAGzC5B,UAAW,SAASzJ,EAAIoL,EAAMC,GAC5BJ,EAAQzB,QAAQ9E,MAAM0G,KAAMA,EAAMC,MAAOA,KAG3CtB,UAAW,SAAS/J,EAAI0G,EAAS2E,EAAOvB,GACtCmB,EAAQE,QAAQzG,MAAM4G,SAAUtL,EAAIuL,SAAU7E,KAGhD6C,QAAS,SAASvJ,EAAIoL,EAAMI,EAAWC,OAKlCR,EAGT,IAAIT,GAAU,SAAStH,EAAKqH,EAAS3G,GACnC,GAAIoD,GAAQuD,EAAQvD,MAAM,KACtB0E,EAAcpI,aAAEqI,QAAQ3E,GACxB4E,EAAUtI,aAAEuI,KAAK7E,EAErB0E,GAAYhI,OAAO,SAASoI,EAAQjI,EAAGgF,GACrC,GAAIkD,GAAU/E,EAAM6B,EAAI,EAWxB,OATImD,GAASD,IACO,OAAdD,EAAOjI,KAAaiI,EAAOjI,OAC3BiI,EAAOjI,GAAG6E,QAAUuD,SAASF,IAAUD,EAAOjI,GAAGa,KAAK,OAGrC,OAAdoH,EAAOjI,IAAgBqI,EAAOJ,EAAOjI,MAC5CiI,EAAOjI,OAGFiI,EAAOjI,IACbX,EAEH,IAAIiJ,GAAUC,EAAQlJ,EAAKwI,EAE3B,OADAS,GAAQP,GAAWhI,EACZA,GAGLgH,EAAY,SAAS1H,EAAKqH,GAC5B,GAAIvD,GAAQuD,EAAQvD,MAAM,KACtB0E,EAAcpI,aAAEqI,QAAQ3E,GACxB4E,EAAUtI,aAAEuI,KAAK7E,GACjBmF,EAAUC,EAAQlJ,EAAKwI,EAE3B,OAAIpI,cAAEgB,QAAQ6H,IAAYH,EAASJ,KACxBO,EAAQE,OAAOT,EAAS,SAEnBO,GAAQP,IAGtBQ,EAAU,SAASlJ,EAAKc,GAC1B,MAAOA,GAAKN,OAAO,SAASoI,EAAQjI,GAClC,MAAOiI,GAAOjI,IACbX,IAGDgJ,EAAS,SAAShJ,GACpB,MAAOI,cAAEQ,SAASZ,IACX5C,OAAOgM,eAAepJ,KAAS5C,OAAOiM,WAG3CP,EAAW,SAASQ,GACtB,MAAOA,GAAIvF,MAAM,SAGnB,OAAOQ,ONsWL,SAASpI,EAAQD,GAEtB,YOlkBD6B,SAAQ5B,OAAO,8BACZoN,SAAS,0BACRC,kBAAkB,KPwkBhB,SAASrN,EAAQD,GAEtB,YQ5kBD6B,SAAQ5B,OAAO,gCAGd6B,KACC,WACA,YACA,aAEF,SAAUyL,EAAUC,EAAWC,GAC7B,GAAMC,IAAUzF,QAAQ,oBAAsByF,MAC9C,IAAKA,EAAL,CAEA,GAAIC,IAAW,CAJ0BD,GAOlCE,cAAc,SAACC,EAAKC,EAAKC,GAC9BC,QAAQC,WAAW,WACbN,IACJJ,EAASC,GAAWC,GACfA,EAAWS,SAAST,EAAWU,SACpCR,GAAW,YR6kBX,SAAS1N,EAAQD,EAASS,GAE/B,YAUA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GARvF,GAAIsK,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUxK,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXuK,SAAyBvK,EAAIyK,cAAgBF,OAAS,eAAkBvK,IAItOG,EAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GSnmBvCuK,EAAqB3M,QAAQ5B,OAAO,wBAAyB,2BAEjEuO,GAAmBhM,QAAQ,gBACzB,KAAM,WAAY,yBAClB,SAAUiM,EAAIC,EAAUC,GAEtB,GAAIC,GAAOvO,IAEXA,MAAKmD,QAAU,SAASqL,EAAOC,GACxBH,EAAuBrB,kBAC1ByB,QAAQC,KAAK,4RAFkB,IAM7BC,GAAOjB,QAAQxK,QAAQ,SAASxC,GAClC8N,EAAG9N,GAGEA,EAAEkO,UAAUR,EAAS7M,QAAQsN,KAAM,IAVT,OAAAN,GAc3BO,IAAI,WAAY,WACpBH,EAAKI,SAIAJ,GAvBqC5O,KA4BzCiP,wBAA0B,SAAUC,GACvC,IAAKrL,aAAEQ,SAAS6K,IACZA,YAAgBC,OAChBD,YAAgBE,OACkB,QAAlCC,MAAMC,YAAYJ,GAAMK,OACT,YAAP,mBAAAC,IAAA,YAAAzB,EAAAyB,MAAmBN,YAAgBM,IAAGJ,KAChD,MAAOF,EAET,IAAIO,GAAM5L,aAAEgB,QAAQqK,QAOpB,OALArL,cAAEqF,KAAKgG,EAAM,SAAS/K,EAAEC,GACN,gBAANA,IAAkC,MAAhBA,EAAEsL,OAAO,KACnCD,EAAIrL,GAAKmK,EAAKU,wBAAwB9K,MAGnCsL,GA3CqCzP,KA+CzC2P,QAAU,SAASC,EAAUC,EAAYC,GAC5C,MAAO,UAASC,EAAK3K,GACf2K,EACFH,EAASI,OAAqB,MAAdH,EAAqBE,EAAMF,GACd,kBAAfC,GACdF,EAASK,QAAuB,MAAfH,EAAsB1K,EAAS0K,EAAY1K,IAE5DwK,EAASK,QAAuB,MAAfH,EAAsB1K,EAAS0K,KAtDR9P,KA2DzCkQ,UAAY,SAASzM,EAAKF,GAC7B,MAAO,YACL,GAAIqM,GAAWxB,EAAG+B,QACdR,EAAUpB,EAAKoB,QAAQC,GACvBQ,EAAOvM,aAAEwM,QAAQC,WAAWtK,OAAO2J,EAEvC,OADAlM,GAAIF,GAAQgN,MAAM9M,EAAK2M,GAChBR,EAASY,UAjE0BxQ,KAsEzCyQ,WAAa,SAASC,GACzB,GAAIC,GAAavC,EAAGwC,IAAIF,EAOxB,OALAC,cAAmB,WAEjBtC,EAAS7M,QAAQsN,QAGZ6B,GAGT3Q,KAAKoD,oBAAsB,SAASyN,GAClC,MAAOC,OAAMC,WAAWC,IAAIH,IAG9B7Q,KAAKiR,cAAgB,SAASnO,EAAYqG,GACxC,GAAI+H,GAAWrN,aAAEsN,KAAKrO,EAAY,SAASsO,GAEzC,MAAO/B,OAAMgC,OAAOD,EAAO/H,IAAKF,EAAIE,MAGtC,OAAOxF,cAAEyN,QAAQxO,EAAYoO,OAKnC/C,EAAmB1M,KACjB,aAAc,eACd,SAAS2L,EAAY1K,GACnB7B,OAAOgM,eAAeO,GAAYmE,eAAiB,SAAS9C,GAC1D,MAAO/L,GAAaS,QAAQnD,KAAMyO,QT6lBlC,SAAS7O,EAAQD,GUzsBvB,YACA,IAAI6R,GAAyBhQ,QAAQ5B,OAAO,4BAA6B,2BAEzE4R,GAAuBrP,QAAQ,oBAAqB,KAAM,yBACxD,SAAUiM,EAAIE,GAEZ,GAAIC,GAAOvO,IAEXA,MAAKyR,WAAa,SAASjD,EAAOoB,EAAUQ,GACrC9B,EAAuBrB,kBAC1ByB,QAAQC,KAAK,0TAEf,IAAI+C,GAAe,KACfC,EAAUvB,EAAKA,EAAKnH,OAAS,EALe,IAU5CzH,QAAQ6C,SAASsN,IACjBnQ,QAAQoQ,WAAWD,EAAQE,QAAS,CACtC,GAAIC,GAASH,EAAQE,MAErBzB,GAAK2B,MAwBP,MArBA3B,GAAKnL,MACH+M,QAAS,WACPpC,EAASK,QAAQyB,IAEnBG,OAAQ,SAAS9B,GACVH,EAASY,QAAQyB,QAAQC,OAMnBJ,GAGTA,EAAOvB,MAAMvQ,KAAMmS,MAAMrF,UAAUsF,MAAM3R,KAAK6P,YAR1CP,EACFH,EAASI,OAAOD,GAEhBH,EAASI,OAAO,GAAIqC,QAAO9M,MAAM,uBAC/B,6FASVmM,EAAgBW,OAAOpP,UAAUsN,MAAM/B,EAAO4B,IAKhDpQ,KAAKiD,UAAY,WACf,GAAI2M,GAAWxB,EAAG+B,QACdC,EAAO+B,MAAMrF,UAAUsF,MAAM3R,KAAK6P,UAKtC,OAFA/B,GAAKkD,WAAWzR,KAAM4P,EAAUQ,GAEzBR,EAASY,YAItBgB,EAAuB/P,KAAK,aAAc,KAAM,mBAC9C,SAAS2L,EAAYgB,EAAI3L,GACvB5B,OAAOgM,eAAeO,GAAY3K,iBAAmB,WACnD,GAAImN,GAAWxB,EAAG+B,QACdC,EAAO+B,MAAMrF,UAAUsF,MAAM3R,KAAK6P,WAElCoB,EAAejP,EAAiBgP,WAAWzR,KAAM4P,EAAUQ,EAM/D,OAJApQ,MAAK+O,IAAI,WAAY,WACnB2C,EAAa1C,SAGRY,EAASY,aV6sBhB,SAAS5Q,EAAQD,EAASS,GAE/B,YAMA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAJvF,GAAIG,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GWvxBvC0O,EAA0B9Q,QAAQ5B,OAAO,6BAC1C,yBAA0B,2BAA4B,uBAAwB,YAAa,2BAM9F0S,GAAwB5S,QAAQ,2BAC9B,KAAM,mBAAoB,eAAgB,aAAc,WAAY,YAAa,yBACjF,SAAS0O,EAAI3L,EAAkBC,EAAc0K,EAAYiB,EAAUrG,EAAWsG,GAE5E,QAASiE,GAAwBC,EAAY1P,EAAY2P,EAAeC,GACjEpE,EAAuBrB,kBAC1ByB,QAAQC,KAAK,ySAEf,IAAIO,KAeJ,IAnBsFA,EAOjFyD,iBAPiFzD,EASjF0D,eAAiBH,EATgEvD,EAWjF2D,UAAY,KAXqE3D,EAcjF4D,gBAAkB,KAd+D5D,EAiBjF6D,cAAgB,KAEjBvR,QAAQwR,UAAUlQ,GACpBoM,EAAK+D,aAAenQ,MACf,CACL,GAAIoQ,GAASV,GACbtD,GAAK+D,aAAevQ,EAAaU,oBAAoB8P,EAAOpQ,WAAWvB,MAMzE,MAHAsC,cAAEsP,OAAOjE,EAAMqD,GACfrD,EAAKkE,iBAAiBZ,EAAYE,GAE3BxD,EAgST,MA7RAqD,GAAwBa,iBAAmB,SAASZ,EAAYE,GAC9D,GAAInE,GAAOvO,IAEXuO,GAAKuE,gBAAkBnF,QAAQxK,QAAQ,WAGrCwK,QAAQ0F,aAAa,WACnB9E,EAAK+E,gBAGHZ,GAAgBnE,EAAKgF,qBACzBhF,EAAKiF,cAAchB,IAAcE,MAIrCH,EAAwBtP,UAAY,WAElC,MADAR,GAAiBQ,UAAUsN,MAAMvQ,KAAMsQ,WAChCtQ,MAGTuS,EAAwBkB,KAAO,SAASC,EAAMC,GAEvCD,IAAMA,EAAO1T,MAF4C0T,KAIpD1N,OAAO0N,EAEjB,IAAIhD,GAAWgD,EAAK/O,IAAI,SAASwE,GAC/B,MAAOnJ,MAAK4T,WAAWzK,EAAKwK,IAC3B3T,KAEH,OAAO0C,GAAa+N,WAAWC,IAGjC6B,EAAwBqB,WAAa,SAASzK,EAAKwK,GACjD,GAAI/D,GAAWxB,EAAG+B,QACdrN,EAAa9C,KAAKiT,aAClBY,EAAgBhQ,aAAEiQ,QAAQpR,EAAaiN,QAASC,EAAU,KAHKzG,GAM7DzG,EAAauM,wBAAwB9F,EAC3C,IAAI4K,GAAQ5K,EAAIE,IACZ2K,EAAUlR,EAAWmR,QAAQF,EARkC,IAW/DC,EAAS,OAGJ7K,GAAIE,GACX,IAAIyC,GAAW6H,GAAoBzI,OAAQ/B,IAAQ0B,KAAM1B,EAJ9CrG,GAMAoR,OAAOH,EAAOjI,EAAU+H,EAAc,WAC/C,OAAQxK,IAAK0K,EAAOI,OAAQ,kBAK9BrR,GAAWsR,OAAOjL,EAAK0K,EAAc,SAAStT,GAC5C,OAAQ8I,IAAK9I,EAAI4T,OAAQ,cAI7B,OAAOvE,GAASY,SA/FkF+B,EAqG5E8B,YAAc,SAASxI,EAAUqI,EAAQI,GAC/DA,EAAWA,GAAY9S,QAAQsN,IAC/B,IAAIyF,GAAU1Q,aAAEuD,KAAK8M,EAAQ,SACzBjN,GAAWsN,EAEf1Q,cAAEqF,KAAKgL,EAAOM,MAAO,SAASzN,EAAM0N,GAClC,GAAIC,KACJA,GAAOD,GAAQ1N,EACfE,EAAQhC,MAAOuP,MAAOE,MAGxB1U,KAAK2U,gBAAgB9I,EAAU5E,EAASqN,IAhH0D/B,EAoH5EoC,gBAAkB,SAAS9I,EAAU5E,EAASqN,GACpE,GAAI/F,GAAOvO,KACP4U,EAAO/Q,aAAEgR,MAAM5N,EAAQgC,OAAQqL,GAE/B5G,EAAO,SAASqC,EAAK+E,GACvB,MAAI/E,GAAYuE,EAASvE,OACzB6E,GAAK,KAAME,GAGbjR,cAAEqF,KAAKjC,EAAS,SAASiN,GACvB3F,EAAK0E,aAAaiB,OAAOrI,EAAUqI,EAAQxG,MAI/C6E,EAAwBwC,OAAS,SAASC,GACxC,GAAIzQ,EAGCyQ,IAKHA,KAAehP,OAAOgP,GAEtBzQ,EAAOV,aAAEc,IAAIqQ,EAAW,SAASC,GAC/B,MAAOA,GAAS5L,KAAO4L,KAPzB1Q,EAAOV,aAAEqR,MAAMlV,KAAM,OAL4BmV,MAiB7C5Q,GAAO6Q,MAAMC,MAAMC,OAAQxE,MAAMyE,WAEvC,IAAI7E,GAAWnM,EAAKI,IAAI,SAAS6Q,GAC/B,MAAOxV,MAAKyV,WAAWD,IACtBxV,KAEH,OAAO0C,GAAa+N,WAAWC,IAGjC6B,EAAwBkD,WAAa,SAASlV,GAC5C,GAAIqP,GAAWxB,EAAG+B,QACdrN,EAAa9C,KAAKiT,aAClBtD,EAAUjN,EAAaiN,QAAQC,EAAU,MAAQvG,IAAK9I,EAAI4T,OAAQ,WAEtE,OADArR,GAAWiS,OAAOxU,EAAIoP,GACfC,EAASY,SAGlB+B,EAAwBiB,cAAgB,SAASN,EAAQR,GACvD,GAAInE,GAAOvO,IAEPuO,GAAKsE,WAAWtE,EAAKmH,iBAGzBnH,EAAKsE,UAAYK,EAAOyC,SACtBhM,QAAS,SAASR,EAAKyM,GACrBrH,EAAK3B,OAAOgJ,EAAS,EAAGzM,GACxBoF,EAAKoE,cAAc/F,OAAOgJ,EAAS,EAAGzM,GACtCoF,EAAKsH,wBAGPvL,UAAW,SAASnB,EAAK2M,EAAQF,GAC/B5N,EAAU2C,gBAAgB4D,EAAKqH,GAAUzM,GACzCnB,EAAUgD,iBAAiBuD,EAAKqH,GAAUzM,GAC1CoF,EAAKoE,cAAciD,GAAWrH,EAAKqH,GACnCrH,EAAKsH,wBAGP/L,QAAS,SAASX,EAAK4C,EAAWC,GAChCuC,EAAK3B,OAAOb,EAAW,GACvBwC,EAAK3B,OAAOZ,EAAS,EAAG7C,GACxBoF,EAAKoE,cAAc/F,OAAOb,EAAW,GACrCwC,EAAKoE,cAAc/F,OAAOZ,EAAS,EAAG7C,GACtCoF,EAAKsH,wBAGP7L,UAAW,SAAS8L,GAClB,GAAIC,GAAerT,EAAauO,cAAc1C,EAAMuH,EAEhC,KAAhBC,GACFxH,EAAK3B,OAAOmJ,EAAc,GAC1BxH,EAAKoE,cAAc/F,OAAOmJ,EAAc,GACxCxH,EAAKsH,yBAILE,EAAerT,EAAauO,cAAc1C,EAAKoE,cAAemD,GAE1C,IAAhBC,GACFxH,EAAKoE,cAAc/F,OAAOmJ,EAAc,OAMhDxH,EAAKwE,cAAgBpF,QAAQxK,QAAQ,WACnC+P,EAAO8C,QACHzH,EAAK0H,aAAa1H,EAAK2H,uBAAuBxD,MAItDH,EAAwBmD,eAAiB,WACvC1V,KAAK6S,UAAU7D,OACfhP,KAAK+S,cAAc/D,aACZhP,MAAKiW,kBACLjW,MAAKmW,gBAGd5D,EAAwBsD,qBAAuB,SAAStU,GACtDvB,KAAKiW,aAAc,EADyCjW,KAIvDoW,wBApO6F7D,EAyO5E2D,uBAAyB,SAASxD,GACxD,GAAInE,GAAOvO,IAEPuO,GAAK4H,iBACP9H,EAASgI,OAAO9H,EAAK4H,gBACrB5H,EAAK4H,eAAiB,MAGxB5H,EAAK4H,eAAiB9H,EAAS,WAC7BE,EAAK0H,aAAc,CADqB,IAIpCzK,GAAUxD,EAAUoD,WAAWmD,EAAMA,EAAKoE,cAAepE,EAAKqE,eAClErE,GAAK+H,aAAa9K,GAEdkH,GAAgBnE,EAAKgF,sBACxB,IAGLhB,EAAwBvD,KAAO,WAC7BhP,KAAKsT,cACLtT,KAAK8S,gBAAgB9D,QAGvBuD,EAAwBe,YAAc,WACpCtT,KAAKoW,uBAEDpW,KAAK6S,YACP7S,KAAK6S,UAAU7D,OACfhP,KAAK+S,cAAc/D,QAGrBhP,KAAK4M,OAAO,GACZ5M,KAAK2S,cAAc/F,OAAO,IAG5B2F,EAAwB6D,qBAAuB,SAAS7U,GAClDvB,KAAKuW,gBACPvW,KAAKuW,gBACLvW,KAAKuW,cAAgB,OAIzBhE,EAAwBgB,mBAAqB,WAC3C,GAAIhF,GAAOvO,IAD2CuO,GAIjD6H,uBAEL7H,EAAKgI,cAAgBnJ,EAAWoJ,OAAO,WACrC,MAAOjI,IACN,SAASkI,EAAQC,GAClB,GAAID,IAAWC,EAAf,CAEA,GAAIlL,GAAUxD,EAAUoD,WAAWmD,EAAMmI,EAAQnI,EAAKqE,eACtDrE,GAAK6H,uBACL7H,EAAK+H,aAAa9K,GAClB+C,EAAKgF,wBACJ,IAGLhB,EAAwB+D,aAAe,SAAS9K,GAC9C,GAAI+C,GAAOvO,KAIP2W,EAAYnL,EAAQC,MAAMmL,UAAUjS,IAAI,SAASkS,GAEnD,MADAtI,GAAK3B,OAAOiK,EAAWjL,MAAO,GACvBiL,EAAWlL,MAGhBgL,GAAU1N,QAAQsF,EAAKkF,KAAKkD,EAVuB,IAanDG,GAActL,EAAQzB,QAAQpF,IAAI,SAASkS,GAC7C,MAAOA,GAAWlL,MAGhBmL,GAAY7N,QAAQsF,EAAKwG,OAAO+B,GAjBmBtL,EAoB/CE,QAAQpI,QAAQ,SAASuT,GAC/BtI,EAAK8F,YAAYwC,EAAWhL,SAAUgL,EAAW/K,aAI9CyG,KAGXD,EAAwB5S,QAAQ,uBAC9B,oBAAqB,YAAa,yBAClC,SAAS0C,EAAmB4F,EAAWsG,GACrC,QAASjM,GAAoB0U,EAAcrE,EAAgB5P,GAIzD,MAFKwL,GAAuBrB,kBAC1ByB,QAAQC,KAAK,iSACR,GAAIvM,GAAkB2U,EAAcrE,EAAgB5P,EAAYkF,EAAU0C,SAGnF,MAAOrI,MAGXiQ,EAAwB5S,QAAQ,qBAC9B,0BAA2B,aAAc,YACzC,SAAS6S,EAAyBnF,EAAYpF,GAC5C,QAAS5F,GAAkB2U,EAAcrE,EAAgB5P,EAAYuF,GAEnE,IAAK0O,EACH,KAAM,IAAIC,WAAU,wDAGtB,KAAMxV,QAAQoQ,WAAWmF,KAAiBvV,QAAQoQ,WAAWmF,EAAa5F,MACxE,KAAM,IAAI6F,WACR,iGAYJ,OARKxV,SAAQoQ,WAAWmF,KACtBjU,EAAatB,QAAQwR,UAAUlQ,GAAcA,EAAaiU,EAC1DA,EAAelT,aAAEoT,KAAKF,EAAa5F,KAAM4F,IAdgCrE,EAkB1DlR,QAAQwR,UAAUN,GAAkBA,GAAiB,EACtErK,EAASA,GAAUL,EACZ,GAAIuK,GAAwBwE,EAAcjU,EAAYuF,EAAQqK,GAGvE,MAAOtQ,MAGXkQ,EAAwB7Q,KACtB,aAAc,oBAAqB,sBAAuB,iBAC1D,SAAS2L,EAAYhL,EAAmBC,EAAqB6U,GAC3D,GAAIC,GAAatW,OAAOgM,eAAeO,EACvC+J,GAAW/U,kBAAoB8U,EAAe9U,GAC9C+U,EAAW9U,oBAAsB6U,EAAe7U,OXsxB9C,SAASzC,EAAQD,EAASS,GAE/B,YAMA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAJvF,GAAIG,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GYtpCvCwT,EAAsB5V,QAAQ5B,OAAO,yBACtC,uBAAwB,2BAA4B,4BAA6B,aAAc,YAAa,2BAE/GwX,GAAoB1X,QAAQ,uBAC1B,KAAM,mBAAoB,eAAgB,YAAa,aAAc,0BAA2B,yBAChG,SAAS0O,EAAI3L,EAAkBC,EAAcsF,EAAWvB,EAAY8L,EAAyBjE,GAS3F,QAAS+I,GAAqBvU,EAAY+I,EAAUyL,GAC7ChJ,EAAuBrB,kBAC1ByB,QAAQC,KAAK,iSAF2C,IAKtD4I,GAAUzU,EAAW0U,SACrBtI,EAAOrL,aAAE+N,WAAW2F,GAAW1W,OAAO4W,OAAOF,EAAQzK,cACrD3D,EAAMrG,EAAWmR,QAAQpI,EAAUyL,GACnCI,EAAsB7T,aAAEwD,KAAKkL,EAAyB,kBAW1D,OAVA1O,cAAEsP,OAAOjE,EAAM/F,GACftF,aAAEsP,OAAOjE,EAAMmI,GACfxT,aAAEsP,OAAOjE,EAAMwI,GAX2CxI,EAcrDyI,UAAY9T,aAAEuD,KAAKkQ,EAAS,OAAQ,SACzCpI,EAAK+D,aAAenQ,EACpBoM,EAAK0I,KAAO1I,EAAK2I,OAAOhM,GACxBqD,EAAKyD,cAAgBxJ,MAEd+F,EAsHT,MA/IAmI,GAAoBS,iBAClB,eAAgB,YAAa,OAAQ,YAAa,kBAAmB,UACrE,OAAQ,OAAQ,QAAS,YAAa,OAAQ,qBAAsB,qBAAsB,wBAAyB,eACnH,QAAS,YAAa,gBAAiB,gBAAiB,cAAe,kBAAmB,UAyB5FT,EAAoBU,aAAe,WACjC,MAAOvW,SAAQwW,KAAKnU,aAAEuD,KAAKpH,KAAMA,KAAK8X,mBAGxCT,EAAoBpU,UAAY,WAE9B,MADAR,GAAiBQ,UAAUsN,MAAMvQ,KAAMsQ,WAChCtQ,MAGTqX,EAAoB5D,KAAO,SAASwE,GAClC,GAIIC,GAJAtI,EAAWxB,EAAG+B,QACdrN,EAAa9C,KAAKiT,aAClBY,EAAgBhQ,aAAEiQ,QAAQpR,EAAaiN,QAASC,EAAU,MAC1DkG,EAAShT,EAAWmR,QAAQjU,KAAK4X,KAJK,IAQtC9B,EAAQ,CACV,GAAImC,EACFC,GAASrN,KAAMoN,OACZ,IACHC,EAAOzR,EAAWqP,EAAQ9V,KAAK+X,gBAE3BlU,aAAEe,QAAQsT,GACZ,MAAO9J,GAAG+J,MAAOhE,OAAQ,WAPnBnU,MAYLqU,YAAY6D,EAAMrE,GAAgBM,OAAQ,iBAK7C+D,GADED,EACKpU,aAAEK,MAAM+T,GAERjY,KAAK+X,eAEdG,EAAK7O,IAAM6O,EAAK7O,KAAOrJ,KAAK4X,KAC5B9U,EAAWsR,OAAO8D,EAAMrE,GAAgBM,OAAQ,aAGlD,OAAOvE,GAASY,SAGlB6G,EAAoBhD,YAAc,SAASH,EAAQI,GACjD,GAAIzI,GAAW7L,KAAK4X,IACpBrF,GAAwB8B,YAAY5T,KAAKT,KAAM6L,EAAUqI,EAAQI,IAGnE+C,EAAoBe,MAAQ,SAASC,GACnC,GAAI9J,GAAOvO,KACPsX,EAAUtX,KAAK2X,UACfpX,EAAKP,KAAK4X,KACVzO,EAAMnJ,KAAKiT,aAAagB,QAAQ1T,EAAI+W,EAExC,IAAInO,EAAK,CAEP,GAEImP,GAFAC,EAAU1U,aAAEU,KAAK4E,GACjBqP,EAAe3U,aAAEwD,KAAK8B,EAAKoP,EAG/B1U,cAAEsP,OAAO5E,EAAMiK,GACf3U,aAAEsP,OAAO5E,EAAKoE,cAAe6F,GAG3BF,EADED,EACYxU,aAAE4U,aAAa5U,aAAEU,KAAKgK,GAAO1K,aAAEU,KAAKgK,EAAKoE,gBAEzC9O,aAAEU,KAAKgK,EAGvB,IAAImK,GAAc7U,aAAEU,KAAK4E,GACrBwP,EAAc9U,aAAE+U,WAAWN,EAAaI,EAAanK,EAAKuJ,gBAE9Da,GAAYrV,QAAQ,SAAUmR,SACrBlG,GAAKkG,SACLlG,GAAKoE,cAAc8B,SAK5B5Q,cAAEU,KAAKvE,KAAK+X,gBAAgBzU,QAAQ,SAASmR,SACpClG,GAAKkG,KAGdlG,EAAKoE,kBAIT0E,EAAoBrI,KAAO,WACrBhP,KAAK6Y,uBACP7Y,KAAK6Y,wBAEH7Y,KAAK8Y,oBACP9Y,KAAK8Y,qBAEH9Y,KAAK+Y,oBAAsB/Y,KAAK+Y,mBAAmB/J,MACrDhP,KAAK+Y,mBAAmB/J,QAG5BqI,EAAoBQ,OAAS,SAAShM,GACpC,GAAIyL,GAAUzT,aAAEsP,UAAWnT,KAAK2X,WAC9BqB,QAAU3P,IAAK,GACf4P,UAAU,EACVC,UAAW,OAGT/P,EAAMnJ,KAAKiT,aAAagB,QAAQpI,EAAUyL,EAE9C,OAAInO,GAAYA,EAAIE,IAChBwC,YAAoBiF,OAAMyE,SAAiB1J,EAC3ChI,aAAEsV,SAAStN,GAAkBA,EAC1B,GAAIiF,OAAMyE,UAGZ8B,KAIXD,EAAoB1X,QAAQ,iBAC1B,aAAc,eAAgB,aAAc,sBAC5C,SAAS0N,EAAY1K,EAAc+D,EAAY4Q,GAC7C,QAAS/U,GAAcQ,EAAYvC,EAAI6Y,EAAM9B,GAE3C,IAAKxU,EACH,KAAM,IAAIkU,WAAU,oDAGtB,KAAKxV,QAAQoQ,WAAW9O,EAAWmR,SACjC,KAAM,IAAI+C,WAAU,gGAGtB,IAAI9H,GAAO,GAAImI,GAAoBvU,EAAYvC,EAAI+W,EAKnD,OAfoDpI,GAY/CmK,MAAQD,KAAS,EACtBvV,aAAEsP,OAAOjE,EAAM5M,GACf4M,EAAKoK,YACEpK,EAsBT,MAnBA5M,GAAcgX,UAAY,WACxB,GAAI/K,GAAOvO,IAEXA,MAAK+Y,mBAAqBrW,EAAaS,QAAQiK,EAAY,WACzDmB,EAAK6J,OAAM,KAJsBpY,KAQ9B8Y,mBAAqB9Y,KAAKqZ,OAASjM,EAAWoJ,OAAO,WACxD,MAAOjI,GAAKwJ,gBACX,SAAUpM,EAAMtB,GACbsB,IAAStB,GAASkE,EAAKkF,SAC1B,GAEHzT,KAAK6Y,sBAAwBzL,EAAW2B,IAAI,WAAY,WAClDR,GAAQA,EAAKS,MAAMT,EAAKwD,SAIzBzP,KAGX8U,EAAoB3V,KAClB,aAAc,gBAAiB,iBAC/B,SAAU2L,EAAY9K,EAAe4U,GACnC,GAAIC,GAAatW,OAAOgM,eAAeO,EACvC+J,GAAW7U,cAAgB4U,EAAe5U,OZ4oCxC,SAAS1C,EAAQD,EAASS,GAE/B,YAMA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAJvF,GAAIG,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,Ga51CvC2V,EAAoB/X,QAAQ5B,OAAO,uBACrC,uBACA,sBACA,2BAIF2Z,GAAkBpX,QAAQ,eACxB,aAAc,eAAgB,KAAM,yBACpC,SAASiL,EAAY1K,EAAc0L,EAAIE,GAErC,GAAIkL,GAAO5R,QAAQ,gBACnB,IAAK4R,EAAL,CAEA,GAAIjL,GAAOvO,KACPyZ,EAAWD,EAAKC,QAEpBzZ,MAAK0Z,YAAc,WACZpL,EAAuBrB,kBAC1ByB,QAAQC,KAAK,0QAEf,IAAIiB,GAAWxB,EAAG+B,OAOlB,OALAzN,GAAaS,QAAQiK,EAAY,WACzBiF,OAAOsH,aACX/J,EAASK,QAASoC,OAAOuH,UAC1B,GAEIhK,EAASY,SAGlBxQ,KAAK6Z,YAAc,WACZvL,EAAuBrB,kBAC1ByB,QAAQC,KAAK,0QAGf,IAAIiB,GAAWxB,EAAG+B,OAWlB,OATAzN,GAAaS,QAAQiK,EAAY,WACzBiF,OAAOsH,cACY,OAAlBtH,OAAOuH,OACVhK,EAASI,OAAO,iBAEhBJ,EAASK,QAASoC,OAAOuH,WAE5B,GAEIhK,EAASY,SAGlBxQ,KAAK8Z,iBAAmB,SAASC,GAI/B,MAHKzL,GAAuBrB,kBAC1ByB,QAAQC,KAAK,gRAERJ,EAAKsL,aAAY,GAAMG,KAAK,SAASJ,GAC1C,GAAIK,GAAQF,EAAaH,EAEzB,OAAKK,MAAU,EACNL,EACkB,gBAAVK,GACR7L,EAAG4B,OAAQiK,GAEX7L,EAAG4B,OAAQ,gBAIxBhQ,KAAKka,kBAAoBxX,EAAawN,UAAUmC,OAAQ,qBACxDrS,KAAKma,WAAazX,EAAawN,UAAUuJ,EAAU,cACnDzZ,KAAKoa,eAAiB1X,EAAawN,UAAUuJ,EAAU,kBACvDzZ,KAAKqa,eAAiB3X,EAAawN,UAAUuJ,EAAU,kBACvDzZ,KAAKsa,cAAgB5X,EAAawN,UAAUuJ,EAAU,iBACtDzZ,KAAKua,YAAc7X,EAAawN,UAAUuJ,EAAU,eACpDzZ,KAAKwa,OAAS9X,EAAawN,UAAUmC,OAAQ,UAC7CrS,KAAKya,mBAAqB/X,EAAawN,UAAUmC,OAAQ,sBACzDrS,KAAK0a,kBAAoBhY,EAAawN,UAAUmC,OAAQ,qBACxDrS,KAAK2a,iBAAmBjY,EAAawN,UAAUmC,OAAQ,oBACvDrS,KAAK4a,gBAAkBlY,EAAawN,UAAUmC,OAAQ,mBACtDrS,KAAK6a,gBAAkBnY,EAAawN,UAAUmC,OAAQ,mBACtDrS,KAAK8a,gCAAkCpY,EAAawN,UAAUmC,OAAQ,mCACtErS,KAAK+a,gBAAkBrY,EAAawN,UAAUmC,OAAQ,mBACtDrS,KAAKgb,eAAiBtY,EAAawN,UAAUmC,OAAQ,sBAIzDkH,EAAkB9X,KAChB,aAAc,yBAA0B,SACxC,SAAS2L,EAAYkB,EAAwBvM,GAE3C,GAAIkZ,GAAapa,OAAOgM,eAAeO,EACvCvJ,cAAEsP,OAAO8H,EAAYlZ,GAErBqL,EAAWjK,QAAQ,WACZkP,OAAOuH,OACZxM,EAAW8N,YAAc7I,OAAOuH,OAChCxM,EAAWuM,UAAYtH,OAAOsH,mBbs1C9B,SAAS/Z,EAAQD,EAASS,GAE/B,YAMA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAJvF,GAAIG,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,Gc17CvCuX,EAAuB3Z,QAAQ5B,OAAO,0BAA2B,uBAAwB,2BAE7Fub,GAAqBhZ,QAAQ,kBAC3B,KAAM,eAAgB,yBACtB,SAASiM,EAAI1L,EAAc4L,GACzBtO,KAAKS,KAAO,WACL6N,EAAuBrB,kBAC1ByB,QAAQC,KAAK,2RAEf,IAAIiB,GAAWxB,EAAG+B,QACdR,EAAUjN,EAAaiN,QAAQC,GAC/BQ,EAAOvM,aAAEwM,QAAQC,WAAWtK,OAAO2J,EAEvC,OADA0C,QAAO5R,KAAK8P,MAAMvQ,KAAMoQ,GACjBR,EAASY,adq8ChB,SAAS5Q,EAAQD,Get9CvB,YACA,IAAIyb,GAAuB5Z,QAAQ5B,OAAO,0BAA2B,uBAAwB,2BAE7Fwb,GAAqB1b,QAAQ,kBAAmB,eAAgB,SAAU,yBACxE,SAAUgD,EAAc2Y,EAAQ/M,GAC9B,MAAO,UAAUpL,GAEf,OAEE+T,KAAM,SAASzI,EAAO8M,GACfhN,EAAuBrB,kBAC1ByB,QAAQC,KAAK,4QAEf,IAAI4M,GAASF,EAAOC,GAChBE,EAASD,EAAOE,MACpB/Y,GAAaS,QAAQqL,EAAO,WAC1BgN,EAAOhN,EAAOkN,QAAQ1K,IAAI9N,MAG5BsL,EAAMgI,OAAO8E,EAAO,SAASlR,EAASC,GACpCqR,QAAQ/U,IAAIzD,EAASqY,EAAO/M,MAC3B,Ufm+CP,SAAS5O,EAAQD,GgBx/CvB,YAEA,IAAIgc,GAAsBna,QAAQ5B,OAAO,yBAA0B,uBAAwB,2BAG3F+b,GAAoBxZ,QAAQ,iBAC1B,KAAM,eAAgB,yBACtB,SAAUiM,EAAI1L,EAAc4L,GACrBA,EAAuBrB,kBAC1ByB,QAAQC,KAAK,wTACf,IAAI6K,GAAO5R,QAAQ,aACnB,IAAK4R,EAAL,CAEA,GAAIoC,GAAepC,EAAKoC,YAExB5b,MAAKqD,WAAa,SAASiU,GACpBhJ,EAAuBrB,kBAC1ByB,QAAQC,KAAK,yTAEf2I,EAAUA,KACV,IAAI1H,GAAWxB,EAAG+B,OAElB,OADAyL,GAAavY,WAAWiU,EAAS5U,EAAaiN,QAAQC,IAC/CA,EAASY,chBggDhB,SAAS5Q,EAAQD,GiBthDvB,YAEA,IAAIkc,GAAuBra,QAAQ5B,OAAO,0BACvC,4BAEHic,GAAqBnc,QAAQ,kBAAmB,KAAM,mBACpD,SAAS0O,EAAI3L,GACX,QAASyU,GAAe4E,GACtB,MAAO,YACL,GAAI1L,GAAO+B,MAAMrF,UAAUsF,MAAM3R,KAAK6P,WAClCyL,EAAeD,EAAcvL,MAAMvQ,KAAMoQ,EAU7C,OARA5O,SAAQ2R,OAAO4I,EAAc7E,GAC7B6E,EAAaC,QAAUhc,KAEvBA,KAAK+O,IAAI,WAAY,WACnBgN,EAAa/M,OACT+M,EAAarK,cAAcqK,EAAarK,aAAa1C,SAGpD+M,GAUX,MANA7E,GAAejU,UAAY,WACzB,GAAImN,GAAO+B,MAAMrF,UAAUsF,MAAM3R,KAAK6P,UAEtC,OADAtQ,MAAK0R,aAAejP,EAAiBgP,WAAWzR,KAAKgc,QAAS5N,EAAG+B,QAASC,GACnEpQ,MAGFkX,MjB+hDL,SAAStX,EAAQD,EAASS,GAE/B,YAWA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GATvF5C,OAAOC,eAAenB,EAAS,cAC7BoB,OAAO,IAETpB,EAAQmE,MAAQnE,EAAQ4B,KAAO0a,MAE/B,IAAIrY,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GkB1kD9BrC,EAAA5B,EAAA4B,KAAO,2BACPuC,EAAAnE,EAAAmE,MAAQ,SAErBtC,SAAQ5B,OAAO2B,MAKdY,QAAQ2B,GACP,aAEA,SAASsJ,GAkCP,QAAS8O,GAAOzN,EAAI0N,EAASC,GAC3B,MAAO,YlB2kDN,IAAK,GAAIC,GAAO/L,UAAUrH,OkB3kDhBmH,EAAA+B,MAAAkK,GAAAC,EAAA,EAAAD,EAAAC,MlB4kDRlM,EAAKkM,GAAQhM,UAAUgM,EkB3kDxB,IAAMlX,GAASqJ,EAAG8B,MAAM4L,EAAS/L,EAKjC,OAJAgM,GAAI3b,KAAK0b,GACP/W,SACAgL,SAEKhL,GAIX,QAASmX,GAAQ9Y,EAAK0Y,EAASC,GAC7B,MAAOvY,cAAEU,KAAKd,GAAKQ,OAAO,SAACuY,EAAOpY,GAEhC,MADAoY,GAAMpY,GAAKmK,EAAK0I,KAAKxT,EAAIW,GAAI+X,EAASC,GAC/BI,OA/CX,GAAMjO,GAAOvO,IADMA,MAIdyc,SAAW,SAAChZ,GACf,MAAOA,aAAe4O,QAAOtB,WAAW2L,QALvB1c,KASd2c,QAAU,SAAClZ,GACd,MAAOA,aAAe2J,GAAWc,aAVhBlO,KAcd4c,YAAc,SAACnZ,GAClB,MAAOI,cAAEQ,SAASZ,IAAQA,EAAIoZ,gBAfb7c,KAmBd8c,YAAc,SAACC,EAAMC,GACxB,MAAOnZ,cAAEQ,SAAS0Y,IAASlZ,aAAEQ,SAAS2Y,IACpCnc,OAAOgM,eAAekQ,KAAUlc,OAAOgM,eAAemQ,IArBvChd,KA2BdiX,KAAO,SAACxI,EAAI0N,EAASC,GAExB,MADAA,GAAMvY,aAAE+N,WAAWwK,GAAOA,EAAM5a,QAAQsN,KACpCjL,aAAE+N,WAAWnD,GAAYyN,EAAOzN,EAAI0N,EAASC,GAC7CvY,aAAEQ,SAASoK,GAAY8N,EAAQ9N,EAAI0N,EAASC,GACzC3N,OlBsmDP,SAAS7O,EAAQD,EAASS,GAE/B,YAWA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAEvF,QAASwZ,GAAmBjY,GAAO,GAAImN,MAAMtN,QAAQG,GAAM,CAAE,IAAK,GAAIoE,GAAI,EAAG8T,EAAO/K,MAAMnN,EAAIiE,QAASG,EAAIpE,EAAIiE,OAAQG,IAAO8T,EAAK9T,GAAKpE,EAAIoE,EAAM,OAAO8T,GAAe,MAAO/K,OAAMgL,KAAKnY,GAX1LnE,OAAOC,eAAenB,EAAS,cAC7BoB,OAAO,IAETpB,EAAQ+B,MAAQ/B,EAAQ4B,KAAO0a,MAE/B,IAAIrY,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GmB3pD9BrC,EAAA5B,EAAA4B,KAAO,uBACPG,EAAA/B,EAAA+B,MAAQ,QAErBF,SAAQ5B,OAAO2B,MAYdY,QAAQT,EAAO,WnBkqDb,GAAImB,GAAQ7C,KmBhqDTod,EAAAnB,MAEJjc,MAAKqd,WAJoBrd,KAMpBsd,eACLtd,KAAKud,kBAPoBvd,KAUpBkC,MAAQ,SAACA,GACZ,IAAK2B,aAAEQ,SAASnC,GACd,KAAMqD,OAAM,+BAOd,OAJA1C,GAAKwa,QAAUxZ,aAAE2Z,MAAM3a,EAAKwa,SAAUnb,IALhBW,EAOjBya,YAAYha,QAAQ,SAAA6Y,GnBoqDtB,MmBpqDiCtZ,GAAK4a,QAAQtB,KACjDtZ,EAAK0a,eAAeja,QAAQ,SAAA6Y,GnBsqDzB,MmBtqDoCtZ,GAAK6a,WAAWvB,KACvDtZ,GAnBuB7C,KAuBpB2d,QAAU,SAACzb,GAEd,MADAW,GAAKwa,QAAUxZ,aAAEqC,QAAQrD,EAAKwa,QAASnb,GACvCW,GAzBuB7C,KA6BpB0d,WAAa,SAACvB,GnBwqDhB,IAAK,GAAIE,GAAO/L,UAAUrH,OmBxqDEmH,EAAA+B,MAAAkK,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAD,EAAAC,MnByqD1BlM,EAAKkM,EAAO,GAAKhM,UAAUgM,EmBpqD9B,OAJAzZ,GAAKwa,QAAQ3V,OAAO7D,aAAE+N,YAAYtO,QAAQ,SAACpB,GACzCA,EAAMzB,KAAN8P,MAAArO,GAAWia,GAAAnW,OAAYoK,MAGlB+L,GAlCgBnc,KAsCpByd,QAAU,SAACha,EAAK6T,GnB4qDlB,GAAIsG,GmB3qDwB/Z,aAAEga,YAAavG,GAC1CwG,QAAS,OADHA,EAAAF,EAAAE,QAAS3B,EAAAyB,EAAAzB,QAIX4B,EAASlb,EAAKwa,QAAQ1Y,IAAI,SAACzC,GAE/B,GAAMqC,GAAOV,aAAEU,KAAKrC,GACjBwF,OAAO,SAAAtD,GnB+qDP,MmB/qDYA,GAAEoD,MAAMsW,KACpBpW,OAAO,SAAAtD,GnBgrDP,MmBhrDYP,cAAE+N,WAAW1P,EAAMkC,KAElC,OAAOG,GAAKN,OAAO,SAAC+Z,EAAYC,GAC9B,GAAMC,GAAgBhc,EAAM+b,EAmB5B,OApB6CD,GAIlCC,GAAc,WAGvB,GAAME,GAAgBhC,GAAWnc,KAC3Boe,EAAehB,CACrBA,GAASpd,IAET,KnBkrDG,IAAK,GAAIqe,GAAQ/N,UAAUrH,OmBzrDKmH,EAAA+B,MAAAkM,GAAAC,EAAA,EAAAD,EAAAC,MnB0rD9BlO,EAAKkO,GAAShO,UAAUgO,EmBlrD3B,OAAOJ,GAAc3N,MAAM4N,EAAe/N,GAD5C,QAKEgN,EAASgB,IAINJ,QAIX,OAAOna,cAAEsP,OAAF5C,MAAA1M,cAASJ,GAAAuC,OAAAiX,EAAQc,MAzEDld,OA6ElBC,eAAed,KAAM,UAC1Bue,cAAc,EACdC,YAAY,EAEZxN,IAAK,WACH,MAAOoM,SnB2rDP,SAASxd,EAAQD,EAASS,GAE/B,YAEAS,QAAOC,eAAenB,EAAS,cAC7BoB,OAAO,IAETpB,EAAQ4B,KAAO0a,MAEf,IAAIhb,GAASb,EAAoB,IoBryDrBmB,EAAA5B,EAAA4B,KAAO,sBAEpBC,SAAQ5B,OAAO2B,GAAMN,EAAAM,OAIpBE,KACC,aADGR,EAAAS,MAGH,SAAS0L,EAAYtL,GACnB,GAAM2c,GAAQrR,EAAWc,YACnBwQ,EAAOtR,EAAWsR,IAFG5c,GAOpBwb,YAAYrY,KAAKwZ,EAAM3R,WAC9BhL,EAAOyb,eAAetY,KAAKmI,GAE3BqR,EAAM3R,UAAU4R,KAAO,WACrB,GAAMlQ,GAAQkQ,EAAKnO,MAAMvQ,KAAMsQ,UADC,OAGzBxO,GAAO4b,WAAWlP,QpBsyDzB,SAAS5O,EAAQD,EAASS,GAE/B,YAeA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAEvF,QAASwZ,GAAmBjY,GAAO,GAAImN,MAAMtN,QAAQG,GAAM,CAAE,IAAK,GAAIoE,GAAI,EAAG8T,EAAO/K,MAAMnN,EAAIiE,QAASG,EAAIpE,EAAIiE,OAAQG,IAAO8T,EAAK9T,GAAKpE,EAAIoE,EAAM,OAAO8T,GAAe,MAAO/K,OAAMgL,KAAKnY,GAf1LnE,OAAOC,eAAenB,EAAS,cAC7BoB,OAAO,IAETpB,EAAQgC,KAAOhC,EAAQ4B,KAAO0a,MAE9B,IAAIrY,GAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GAEtC5C,EAASZ,EAAoB,IAE7Ba,EAASb,EAAoB,IqBz0DrBmB,EAAA5B,EAAA4B,KAAO,sBACPI,EAAAhC,EAAAgC,KAAO,QAEpBH,SAAQ5B,OAAO2B,GAAMP,EAAAO,KAAAN,EAAAM,OASpB7B,QAAQiC,GACP,KADaX,EAAA8C,MAAA7C,EAAAS,MAKb,SAAS0M,EAAIuQ,EAAS7c,GACpB,QAASC,MAoIT,MArI4BA,GAIrBoB,QAAU,SAASsL,GrBu0DzB,GqBv0D6B6I,GAAAhH,UAAArH,QAAA,GAAAgT,SAAA3L,UAAA,MAAUA,UAAA,EAGtC,IAFA7B,EAAKzO,KAAK4e,eAAe9c,EAAOsb,OAAQ3O,IAEnC5K,aAAE+N,WAAWnD,GAChB,KAAMlJ,OAAM,gCAEd,KAAK1B,aAAEQ,SAASiT,GACd,KAAM/R,OAAM,+BAGd,IAAMsZ,GAAclR,QAAQxK,QAAQsL,EAAI6I,EAGxC,OAb0CuH,GAY9B7P,KAAOhP,KAAK8e,WAAWD,GAC5BA,GAjBmB9c,EAsBrBkB,UAAY,SAAS8b,EAAStQ,EAAIuQ,GACvCvQ,EAAKzO,KAAK4e,eAAe9c,EAAOsb,OAAQ3O,GAAMjN,QAAQsN,MACtDkQ,EAAKA,EAAKhf,KAAK4e,eAAe9c,EAAOsb,OAAQ4B,GAAMxd,QAAQsN,IAFhB,IAMrCmQ,IACJC,QAAS1d,QAAQsN,KAGnB,KAAKjL,aAAEsV,SAAS4F,GACd,KAAMxZ,OAAM,8BAEd,KAAK1B,aAAE+N,WAAWnD,GAChB,KAAMlJ,OAAM,gCAEd,KAAK1B,aAAE+N,WAAWoN,KAAQnb,aAAEQ,SAAS2a,GACnC,KAAMzZ,OAAM,6CAGd,IAAI1B,aAAEQ,SAAS2a,GACb,IAAK,GAAMG,KAAQF,GACbA,EAAMG,eAAeD,IAASH,EAAGG,KAEnCF,EAAME,GAAQH,EAAGG,SACVH,GAAGG,GAKhB,IAAM/Z,MAEAyZ,EAAc7e,KAAKmD,QAAQ,WrBy0DhC,GAAIkc,GqBx0DCjP,EAAO3B,GAGX,IAFIjN,QAAQmG,YAAYyI,KAAOA,OAE1BvM,aAAEgB,QAAQuL,GACb,KAAM7K,OAAA,oDAGR,IAAMmM,IAAe2N,EAAAhN,QAAOpP,UAAPsN,MAAA8O,GAAiBN,GAAA/Y,OAAAiX,EAAY7M,IAAM4O,IAExDC,GAAMC,UAEN9Z,EAAOka,MAAQ5N,EAAa4N,MAAMrI,KAAKvF,GACvCtM,EAAOma,eAAiB7N,EAAa6N,gBAMvC,OAnD2Cna,GAkDpC4J,KAAO6P,EAAY7P,KAAKiI,KAAK4H,GAC7BzZ,GAzEmBrD,EA6ErByd,WAAa,WrB60DnB,IAAK,GAFDC,GAEKpD,EAAO/L,UAAUrH,OqB70DKmH,EAAA+B,MAAAkK,GAAAC,EAAA,EAAAD,EAAAC,MrB80D7BlM,EAAKkM,GAAQhM,UAAUgM,EqB70DxB,IAAI7N,GAAK2B,EAAK2B,KAEd,OADIlO,cAAE+N,WAAWnD,KAAKA,EAAKzO,KAAK4e,eAAe9c,EAAOsb,OAAQ3O,KACvDgR,EAAApN,QAAO5R,KAAP8P,MAAAkP,EAAerP,EAAApK,QAAMyI,MAhFF1M,EAoFrB2d,YAAc,WrBm1DpB,IAAK,GAFDC,GAEKtB,EAAQ/N,UAAUrH,OqBn1DKmH,EAAA+B,MAAAkM,GAAAC,EAAA,EAAAD,EAAAC,MrBo1D9BlO,EAAKkO,GAAShO,UAAUgO,EqBn1DzB,IAAI7P,GAAK2B,EAAK2B,KAEd,OADIlO,cAAE+N,WAAWnD,KAAKA,EAAKzO,KAAK4e,eAAe9c,EAAOsb,OAAQ3O,KACvDkR,EAAAtN,QAAO9B,MAAPA,MAAAoP,EAAgBvP,EAAApK,QAAMyI,MAvFH1M,EA2FrB+c,WAAa,SAASc,GAC3B,GAAIC,GAAA5D,OACE6D,EAAWF,EAAU5Q,KAAKiI,KAAK2I,GAI/B5Q,EAAO,WAEX,MADA6Q,KACOC,EAAAvP,MAAA0L,OAAA3L,WAIT,OADAuP,GAAiB7f,KAAK+O,IAAI,WAAYC;AAC/BA,GAvGmBjN,EA2GrBge,kBAAoB,WACzB,GAAMC,IAAgBhgB,KAAKigB,cACxBjgB,KAAK6N,UACL7N,KAAKkgB,MAAMrS,OAEVmS,IAAchgB,KAAKmgB,WAhHGpe,EAoHrBqe,QAAU,WACf,GAAMxQ,GAAWxB,EAAG+B,OAGpB,OAJ0BP,GAGjBY,QAAUZ,EAASY,QAATZ,WAAyB5P,KAAK+f,kBAAkB9I,KAAKjX,OACjE4P,GAxHmB7N,EA4HrB6c,eAAiB,SAASzC,EAAS1N,GAMxC,MALI5K,cAAE+N,WAAWuK,KACf1N,EAAK0N,EACLA,EAAUnc,MAGL2e,EAAQ1H,KAAKxI,EAAI0N,EAASnc,KAAK+f,kBAAkB9I,KAAKjX,QAGxD+B,MrBy1DL,SAASnC,EAAQD,EAASS,GAE/B,YAmBA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAEvF,QAAS4c,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIvJ,WAAU,qCAnBhHnW,OAAOC,eAAenB,EAAS,cAC7BoB,OAAO,IAETpB,EAAQsZ,SAAWtZ,EAAQiC,UAAYjC,EAAQ4B,KAAO0a,MAEtD,IAAIuE,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIvX,GAAI,EAAGA,EAAIuX,EAAM1X,OAAQG,IAAK,CAAE,GAAIyN,GAAa8J,EAAMvX,EAAIyN,GAAW2H,WAAa3H,EAAW2H,aAAc,EAAO3H,EAAW0H,cAAe,EAAU,SAAW1H,KAAYA,EAAW+J,UAAW,GAAM/f,OAAOC,eAAe4f,EAAQ7J,EAAWrB,IAAKqB,IAAiB,MAAO,UAAU0J,EAAaM,EAAYC,GAAiJ,MAA9HD,IAAYJ,EAAiBF,EAAYzT,UAAW+T,GAAiBC,GAAaL,EAAiBF,EAAaO,GAAqBP,MAE5hB3c,EAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GAEtC5C,EAASZ,EAAoB,IAE7Ba,EAASb,EAAoB,IAE7Be,EAAQf,EAAoB,IsBjgEpBmB,EAAA5B,EAAA4B,KAAO,4BACPK,EAAAjC,EAAAiC,UAAY,cACZqX,EAAAtZ,EAAAsZ,SAAW,WAExBzX,SAAQ5B,OAAO2B,GAAMP,EAAAO,KAAAN,EAAAM,KAAAJ,EAAAI,OAapB7B,QAAQkC,GAAWZ,EAAA8C,MAAA7C,EAAAS,MAIlB,SAASid,EAAS7c,GAChB,QAASE,MAmBT,MApBwBA,GAIZ+e,UAAY,SAASC,GAC/B,IAAKnd,aAAEQ,SAAS2c,GACd,KAAMzb,OAAM,+BAWd,OAbmCzD,GAM5B2b,QAAQuD,GACblD,QAAS,eACT3B,QAASnc,OARwB8B,EAY5B4b,WAAW1d,KAAMghB,GACjBA,GAGFhf,KAQVG,QAAQ8W,GAAUjY,EAAA8C,MAGjB,SAAS6a,GtB2/DR,GsB1/DO9c,GAAA,WACJ,QADIA,GACQmf,GtB2/DX,GAAIne,GAAQ7C,IsB1/DX,ItB4/DDqgB,EAAgBrgB,KsB9/Db6B,IAEGgC,aAAEQ,SAAS2c,GACd,KAAMzb,OAAM,+BAGd1B,cAAEsM,MAAM,WACDtN,EAAKoe,WACRvS,QAAQC,KAAK,8CAIjB3O,KAAKkhB,IAAMF,EtBohEd,MAnBAR,GsB7gEK3e,ItB8gEH2T,IAAK,SACLzU,MAAO,SsBhgEDyN,GAGL,GAFAxO,KAAKihB,WAAY,GAEZtC,EAAQhC,QAAQnO,GACnB,KAAMjJ,OAAM,6BAGd,IAAMwb,GAAYvS,EAAMuS,UAAU/gB,KAAKkhB,IAMvC,OAbYH,GAUFtgB,KAAOsgB,EAAUvB,WAC3BuB,EAAUxQ,MAAQwQ,EAAUrB,YAErBqB,MA5BLlf,IAgCN,OAAO,UAACmf,GtBogEP,MsBpgEc,IAAInf,GAASmf,QtB0gE1B,SAASphB,EAAQD,EAASS,GAE/B,YAuBA,SAASoD,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GArBvF5C,OAAOC,eAAenB,EAAS,cAC7BoB,OAAO,IAETpB,EAAQkC,SAAWlC,EAAQ4B,KAAO0a,MAElC,IAAIkF,GAAiB/gB,EAAoB,IAErCghB,EAAkB5d,EAAuB2d,GAEzCvd,EAAcxD,EAAoB,GAElCyD,EAAeL,EAAuBI,GAEtC5C,EAASZ,EAAoB,IAE7Ba,EAASb,EAAoB,IAE7Be,EAAQf,EAAoB,IAE5BgB,EAAahB,EAAoB,IuBpnEzBmB,EAAA5B,EAAA4B,KAAO,0BACPM,EAAAlC,EAAAkC,SAAW,YAExBL,SAAQ5B,OAAO2B,GAAMP,EAAAO,KAAAN,EAAAM,KAAAJ,EAAAI,KAAAH,EAAAG,OAYpB7B,QAAQmC,GACP,SADiBb,EAAA8C,MAAA7C,EAAAS,MAKjB,SAAS2Z,EAAQsD,EAAS7c,GACxB,QAASG,KvB8mER,GuB9mEmB+e,GAAA1Q,UAAArH,QAAA,GAAAgT,SAAA3L,UAAA,GAAKtQ,KAAAsQ,UAAA,EAEvB0Q,GAAGnE,kBA2PL,MA9PgC5a,GAQrBsV,QAAU,SAASyJ,EAAIL,GvBgnEjC,GAAI9d,GAAQ7C,IuB/mEX,IAAI2e,EAAQ/B,YAAYoE,IACtB,IAAKnd,aAAEQ,SAASsc,GACd,KAAMpb,OAAM,oCAMd,IAHAob,EAAQK,EACRA,EAAKlf,EAAOsb,QAEPvZ,aAAEQ,SAASsc,GACd,KAAMpb,OAAM,+BAIhB1B,cAAEqF,KAAKyX,EAAO,SAACxc,EAAGC,GAChB,IAAKP,aAAE+N,WAAWzN,GAChB,KAAMoB,OAAA,WAAiBnB,EAAA,0BAI3BP,aAAEqF,KAAKyX,EAAO,SAACxc,EAAGC,GACX4c,EAAGnE,eAAezY,KAErB4c,EAAGnE,eAAezY,GAAK,GAAIuJ,SAAQ0T,YAGrCxe,EAAKye,cAAcN,EAAI5c,EAAGD,MAlCElC,EAuCrBsf,cAAgB,SAASP,EAAI5c,EAAGod,GACzC,GAAI7C,EAAQ/B,YAAYoE,GAAK,CAG3B,GAFIxf,QAAQmG,YAAY6Z,KAASA,GAAS,IAErC3d,aAAEsV,SAAS/U,GACd,KAAMmB,OAAM,8BAEd,KAAK1B,aAAE4d,UAAUD,GACf,KAAMjc,OAAM,oCAET,CAKL,GAJAic,EAAShgB,QAAQwR,UAAU5O,GAAKA,GAAI,EACpCA,EAAI4c,EACJA,EAAKlf,EAAOsb,QAEPvZ,aAAEsV,SAAS/U,GACd,KAAMmB,OAAM,8BAEd,KAAK1B,aAAE4d,UAAUD,GACf,KAAMjc,OAAM,gCAIhB,MAAOvF,MAAK0hB,mBAAmBV,EAAI5c,EAAGpE,KAAKwW,OAAQgL,IA9DrBvf,EAkErB0f,wBAA0B,SAASX,EAAI5c,GAChD,GAAIua,EAAQ/B,YAAYoE,IACtB,IAAKnd,aAAEsV,SAAS/U,GACd,KAAMmB,OAAM,mCAMd,IAHAnB,EAAI4c,EACJA,EAAKlf,EAAOsb,QAEPvZ,aAAEsV,SAAS/U,GACd,KAAMmB,OAAM,8BAIhB,OAAOvF,MAAK0hB,mBAAmBV,EAAI5c,EAAGpE,KAAK4hB,mBAhFb3f,EAoFrByf,mBAAqB,SAASV,EAAI5c,EAAGyd,GAC9C,IAAKb,EAAGnE,eAAezY,GAAI,CACzB4c,EAAGnE,eAAezY,GAAK,GAAIuJ,SAAQ0T,UvBmnEpC,KAAK,GAAIhF,GAAO/L,UAAUrH,OuBrnE+B6Y,EAAA3P,MAAAkK,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAD,EAAAC,MvBsnEvDwF,EAAYxF,EAAO,GAAKhM,UAAUgM,EuBnnEnCtc,MAAK+hB,cAALxR,MAAAvQ,MAAmBghB,EAAI5c,EAAGyd,GAAA7b,OAAY8b,IAIxC,MADAd,GAAGnE,eAAezY,GAAG4d,SACd3G,EAAOjX,GAAG4c,IA3Fa/e,EA+FrB8f,cAAgB,SAASf,EAAI5c,EAAGyd,GvB+nE1C,IAAK,GARDI,GAASjiB,KuBrnENkiB,EAASre,aAAEiQ,QAAQuH,EAAOjX,GAAI4c,GAC9BmB,EAAaD,IvB4nEX7D,EAAQ/N,UAAUrH,OuB/nE2B6Y,EAAA3P,MAAAkM,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAD,EAAAC,MvBgoEpDwD,EAAYxD,EAAQ,GAAKhO,UAAUgO,EuB1nEpCuD,GAAQphB,KAAR8P,MAAAsR,GAAa7hB,KAAMkiB,EAAQ,SAACE,EAAKC,GAC/B,GAAMC,GACJF,IAAQD,GACRC,IAAQC,CAGNC,IAAYL,EAAKM,UAAUvB,EAAI5c,KANV4B,OAOrB8b,KA5GwB7f,EAgHrBqf,cAAgB,SAASN,EAAI5c,EAAGqK,GvB4nE1C,GAAI+T,GAASxiB,KuB3nERyiB,EAAoB,KACpBC,EAAY,KACZC,IAEJ3iB,MAAKmD,QAAQ,WAEX,GAAMmY,GAAQ7M,EAAG8B,MAAMyQ,EAFWrT,SAK1BiV,YAAY,WAElB,GAAIjE,EAAQlC,SAASnB,GAAQ,CAC3B,GAAIuH,GAAA5G,MAEAza,SAAQmG,YAAYqZ,EAAG5c,KACzBoe,EAAKM,eAAe9B,EAAI5c,MAAO,GAG7Bqe,IACFE,EAAgBD,EAAU1M,QAC1ByM,EAAkBzT,OAClByT,EAAoB,KAGtB,IAAMM,GAASP,EAAKQ,eAAehC,EAAI5c,EAAGkX,EAK1C,IAHAmH,EAAoBM,EAAOE,YAC3BJ,EAAYE,EAAO7T,KAEU,IAAzByT,EAAc1Z,OAAc,CAC9B,GAAM9C,GAAOib,aAAcjb,KAAKwc,EAAeE,EAC/C7B,GAAG5c,GAAKgd,aAAc8B,MAAMP,EAAexc,OAE3C6a,GAAG5c,GAAKye,CAGVH,GAAYpH,EACZqH,EAAgBE,MAMhBL,GAAKW,kBAAkBnC,EAAI5c,EAAGkX,EAlCRkH,GAsCnBD,UAAUvB,EAAI5c,QAhKOnC,EAsKrB6gB,eAAiB,SAAS9B,EAAI5c,EAAGD,GvB8nE3C,GAAIif,GAASpjB,KuB9nEiCqjB,EAAA/S,UAAArH,QAAA,GAAAgT,SAAA3L,UAAA,IAAQ,EAAAA,UAAA,EAErD,IAAI+S,EAAO,CACT,GAAM7B,GAAS3d,aAAEQ,SAASF,EAC1BnE,MAAKuhB,cAAcP,EAAI5c,EAAGod,GAG5B3gB,OAAOC,eAAekgB,EAAI5c,GACxBma,cAAc,EACdC,YAAY,EAEZxN,IAAK,WACH,MAAO7M,IAETwC,IAAK,SAAC2c,GACJnf,EAAImf,EACJF,EAAKb,UAAUvB,EAAI5c,OAtLOnC,EA4LrB+gB,eAAiB,SAAShC,EAAI5c,EAAG8O,GvBkoE3C,GAAIqQ,GAASvjB,KuBjoENkP,KAEA+T,EAAc/P,EAAOyC,SACzBhM,QAAS,SAACR,EAAKyM,GACb,MAAKqN,IAILjC,EAAG5c,GAAGwI,OAAOgJ,EAAS,EAAGzM,OACzBoa,GAAKhB,UAAUvB,EAAI5c,QAJjB8K,GAAKjK,KAAKkE,IAMdmB,UAAW,SAACnB,EAAK2M,EAAQF,GACvB,GAAMzP,GAAOib,aAAcjb,KAAK6a,EAAG5c,GAAGwR,GAAUzM,EAChDiY,cAAc8B,MAAMlC,EAAG5c,GAAGwR,GAAUzP,GACpCod,EAAKhB,UAAUvB,EAAI5c,IAErB0F,QAAS,SAACX,EAAK4C,EAAWC,GACxBgV,EAAG5c,GAAGwI,OAAOb,EAAW,GACxBiV,EAAG5c,GAAGwI,OAAOZ,EAAS,EAAG7C,GACzBoa,EAAKhB,UAAUvB,EAAI5c,IAErB4F,UAAW,SAAC8L,EAAQF,GAClBoL,EAAG5c,GAAGwI,OAAOgJ,EAAS,GACtB2N,EAAKhB,UAAUvB,EAAI5c,KAIvB,QACE6e,cACA/T,SAIJjN,EAAWkhB,kBAAoB,SAASnC,EAAI5c,EAAG8K,GAC7C,GAAI/K,GAAI6c,EAAG5c,EAOX,IALI5C,QAAQwR,UAAU7O,WACb6c,GAAG5c,GACVD,EAAI,MAGF3C,QAAQmG,YAAYxD,GACtBnE,KAAK8iB,eAAe9B,EAAI5c,EAAG8K,OAGxB,IAAIyP,EAAQ7B,YAAY3Y,EAAG+K,GAAO,CACrC,GAAM/I,GAAOib,aAAcjb,KAAKhC,EAAG+K,EACnCkS,cAAc8B,MAAM/e,EAAGgC,GACvBnG,KAAKuiB,UAAUvB,EAAI5c,OAEnB4c,GAAG5c,GAAK8K,GA/OoBjN,EAoPrBuhB,SAAW,SAASxC,EAAI5c,GACjC4c,EAAGnE,eAAezY,GAAG4d,UArPS/f,EAyPrBsgB,UAAY,SAASvB,EAAI5c,GAClCpE,KAAK+f,oBACLiB,EAAGnE,eAAezY,GAAGsH,WAGhBzJ,MvBwoEL,SAASrC,EAAQD,GwBj6EvBC,EAAAD,QAAAO,GxBu6EM,SAASN,EAAQD,GAEtB,YAEAkB,QAAOC,eAAenB,EAAS,cAC7BoB,OAAO,GyB56EH,IAAMQ,GAAA5B,EAAA4B,KAAO,mBAEpB,KACEC,QAAQ5B,OAAO2B,GACf,MAAOkiB,GACPjiB,QAAQ5B,OAAO2B","file":"dist/angular-meteor.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"jsondiffpatch\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"jsondiffpatch\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteor\"] = factory(require(\"underscore\"), require(\"jsondiffpatch\"));\n\telse\n\t\troot[\"angularMeteor\"] = factory(root[\"_\"], root[\"jsondiffpatch\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_22__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! angular-meteor v1.3.11 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"underscore\"), require(\"jsondiffpatch\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"underscore\", \"jsondiffpatch\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularMeteor\"] = factory(require(\"underscore\"), require(\"jsondiffpatch\"));\n\telse\n\t\troot[\"angularMeteor\"] = factory(root[\"_\"], root[\"jsondiffpatch\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_22__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(9);\n\t\n\t__webpack_require__(10);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\t__webpack_require__(14);\n\t\n\t__webpack_require__(15);\n\t\n\tvar _utils = __webpack_require__(16);\n\t\n\tvar _mixer = __webpack_require__(17);\n\t\n\tvar _scope = __webpack_require__(18);\n\t\n\tvar _core = __webpack_require__(19);\n\t\n\tvar _viewModel = __webpack_require__(20);\n\t\n\tvar _reactive = __webpack_require__(21);\n\t\n\tvar _templates = __webpack_require__(23);\n\t\n\t// legacy\n\t// lib\n\t\n\t\n\tvar name = 'angular-meteor';\n\t\n\t// new\n\t\n\texports.default = name;\n\t\n\t\n\tangular.module(name, [\n\t// new\n\t_utils.name, _mixer.name, _scope.name, _core.name, _viewModel.name, _reactive.name, _templates.name,\n\t\n\t// legacy\n\t'angular-meteor.ironrouter', 'angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'angular-meteor.object', 'angular-meteor.user', 'angular-meteor.methods', 'angular-meteor.session', 'angular-meteor.camera']).run([_mixer.Mixer, _core.Core, _viewModel.ViewModel, _reactive.Reactive, function ($Mixer, $$Core, $$ViewModel, $$Reactive) {\n\t  // Load all mixins\n\t  $Mixer.mixin($$Core).mixin($$ViewModel).mixin($$Reactive);\n\t}])\n\t\n\t// legacy\n\t// Putting all services under $meteor service for syntactic sugar\n\t.service('$meteor', ['$meteorCollection', '$meteorCollectionFS', '$meteorObject', '$meteorMethods', '$meteorSession', '$meteorSubscribe', '$meteorUtils', '$meteorCamera', '$meteorUser', function ($meteorCollection, $meteorCollectionFS, $meteorObject, $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils, $meteorCamera, $meteorUser) {\n\t  var _this = this;\n\t\n\t  this.collection = $meteorCollection;\n\t  this.collectionFS = $meteorCollectionFS;\n\t  this.object = $meteorObject;\n\t  this.subscribe = $meteorSubscribe.subscribe;\n\t  this.call = $meteorMethods.call;\n\t  this.session = $meteorSession;\n\t  this.autorun = $meteorUtils.autorun;\n\t  this.getCollectionByName = $meteorUtils.getCollectionByName;\n\t  this.getPicture = $meteorCamera.getPicture;\n\t\n\t  // $meteorUser\n\t  ['loginWithPassword', 'requireUser', 'requireValidUser', 'waitForUser', 'createUser', 'changePassword', 'forgotPassword', 'resetPassword', 'verifyEmail', 'loginWithMeteorDeveloperAccount', 'loginWithFacebook', 'loginWithGithub', 'loginWithGoogle', 'loginWithMeetup', 'loginWithTwitter', 'loginWithWeibo', 'logout', 'logoutOtherClients'].forEach(function (method) {\n\t    _this[method] = $meteorUser[method];\n\t  });\n\t}]);\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t'use strict';\n\t\n\t// https://github.com/DAB0mB/get-updates\n\t/*global\n\t angular, _\n\t */\n\t\n\t(function () {\n\t  var module = angular.module('getUpdates', []);\n\t\n\t  var utils = function () {\n\t    var rip = function rip(obj, level) {\n\t      if (level < 1) return {};\n\t\n\t      return _underscore2.default.reduce(obj, function (clone, v, k) {\n\t        v = _underscore2.default.isObject(v) ? rip(v, --level) : v;\n\t        clone[k] = v;\n\t        return clone;\n\t      }, {});\n\t    };\n\t\n\t    var toPaths = function toPaths(obj) {\n\t      var keys = getKeyPaths(obj);\n\t      var values = getDeepValues(obj);\n\t      return _underscore2.default.object(keys, values);\n\t    };\n\t\n\t    var getKeyPaths = function getKeyPaths(obj) {\n\t      var keys = _underscore2.default.keys(obj).map(function (k) {\n\t        var v = obj[k];\n\t        if (!_underscore2.default.isObject(v) || _underscore2.default.isEmpty(v) || _underscore2.default.isArray(v)) return k;\n\t\n\t        return getKeyPaths(v).map(function (subKey) {\n\t          return k + '.' + subKey;\n\t        });\n\t      });\n\t\n\t      return _underscore2.default.flatten(keys);\n\t    };\n\t\n\t    var getDeepValues = function getDeepValues(obj, arr) {\n\t      arr = arr || [];\n\t\n\t      _underscore2.default.values(obj).forEach(function (v) {\n\t        if (!_underscore2.default.isObject(v) || _underscore2.default.isEmpty(v) || _underscore2.default.isArray(v)) arr.push(v);else getDeepValues(v, arr);\n\t      });\n\t\n\t      return arr;\n\t    };\n\t\n\t    var flatten = function flatten(arr) {\n\t      return arr.reduce(function (flattened, v, i) {\n\t        if (_underscore2.default.isArray(v) && !_underscore2.default.isEmpty(v)) flattened.push.apply(flattened, flatten(v));else flattened.push(v);\n\t\n\t        return flattened;\n\t      }, []);\n\t    };\n\t\n\t    var setFilled = function setFilled(obj, k, v) {\n\t      if (!_underscore2.default.isEmpty(v)) obj[k] = v;\n\t    };\n\t\n\t    var assert = function assert(result, msg) {\n\t      if (!result) throwErr(msg);\n\t    };\n\t\n\t    var throwErr = function throwErr(msg) {\n\t      throw Error('get-updates error - ' + msg);\n\t    };\n\t\n\t    return {\n\t      rip: rip,\n\t      toPaths: toPaths,\n\t      getKeyPaths: getKeyPaths,\n\t      getDeepValues: getDeepValues,\n\t      setFilled: setFilled,\n\t      assert: assert,\n\t      throwErr: throwErr\n\t    };\n\t  }();\n\t\n\t  var getDifference = function () {\n\t    var getDifference = function getDifference(src, dst, isShallow) {\n\t      var level;\n\t\n\t      if (isShallow > 1) level = isShallow;else if (isShallow) level = 1;\n\t\n\t      if (level) {\n\t        src = utils.rip(src, level);\n\t        dst = utils.rip(dst, level);\n\t      }\n\t\n\t      return compare(src, dst);\n\t    };\n\t\n\t    var compare = function compare(src, dst) {\n\t      var srcKeys = _underscore2.default.keys(src);\n\t      var dstKeys = _underscore2.default.keys(dst);\n\t\n\t      var keys = _underscore2.default.chain([]).concat(srcKeys).concat(dstKeys).uniq().without('$$hashKey').value();\n\t\n\t      return keys.reduce(function (diff, k) {\n\t        var srcValue = src[k];\n\t        var dstValue = dst[k];\n\t\n\t        if (_underscore2.default.isDate(srcValue) && _underscore2.default.isDate(dstValue)) {\n\t          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n\t        }\n\t\n\t        if (_underscore2.default.isObject(srcValue) && _underscore2.default.isObject(dstValue)) {\n\t          var valueDiff = getDifference(srcValue, dstValue);\n\t          utils.setFilled(diff, k, valueDiff);\n\t        } else if (srcValue !== dstValue) {\n\t          diff[k] = dstValue;\n\t        }\n\t\n\t        return diff;\n\t      }, {});\n\t    };\n\t\n\t    return getDifference;\n\t  }();\n\t\n\t  var getUpdates = function () {\n\t    var getUpdates = function getUpdates(src, dst, isShallow) {\n\t      utils.assert(_underscore2.default.isObject(src), 'first argument must be an object');\n\t      utils.assert(_underscore2.default.isObject(dst), 'second argument must be an object');\n\t\n\t      var diff = getDifference(src, dst, isShallow);\n\t      var paths = utils.toPaths(diff);\n\t\n\t      var set = createSet(paths);\n\t      var unset = createUnset(paths);\n\t      var pull = createPull(unset);\n\t\n\t      var updates = {};\n\t      utils.setFilled(updates, '$set', set);\n\t      utils.setFilled(updates, '$unset', unset);\n\t      utils.setFilled(updates, '$pull', pull);\n\t\n\t      return updates;\n\t    };\n\t\n\t    var createSet = function createSet(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      return _underscore2.default.omit(paths, undefinedKeys);\n\t    };\n\t\n\t    var createUnset = function createUnset(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      var unset = _underscore2.default.pick(paths, undefinedKeys);\n\t\n\t      return _underscore2.default.reduce(unset, function (result, v, k) {\n\t        result[k] = true;\n\t        return result;\n\t      }, {});\n\t    };\n\t\n\t    var createPull = function createPull(unset) {\n\t      var arrKeyPaths = _underscore2.default.keys(unset).map(function (k) {\n\t        var split = k.match(/(.*)\\.\\d+$/);\n\t        return split && split[1];\n\t      });\n\t\n\t      return _underscore2.default.compact(arrKeyPaths).reduce(function (pull, k) {\n\t        pull[k] = null;\n\t        return pull;\n\t      }, {});\n\t    };\n\t\n\t    var getUndefinedKeys = function getUndefinedKeys(obj) {\n\t      return _underscore2.default.keys(obj).filter(function (k) {\n\t        var v = obj[k];\n\t        return _underscore2.default.isUndefined(v);\n\t      });\n\t    };\n\t\n\t    return getUpdates;\n\t  }();\n\t\n\t  module.value('getUpdates', getUpdates);\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _underscore = __webpack_require__(3);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tif (typeof _underscore2.default === 'undefined') {\n\t  if (typeof Package.underscore === 'undefined') {\n\t    throw new Error('underscore is missing');\n\t  }\n\t}\n\t\n\texports.default = _underscore2.default || Package.underscore._;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t'use strict'; /*global\n\t               angular, _, Package\n\t               */\n\t\n\tvar _module = angular.module('diffArray', ['getUpdates']);\n\t\n\t_module.factory('diffArray', ['getUpdates', function (getUpdates) {\n\t  var LocalCollection = Package.minimongo.LocalCollection;\n\t  var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n\t  var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\t\n\t  // Calculates the differences between `lastSeqArray` and\n\t  // `seqArray` and calls appropriate functions from `callbacks`.\n\t  // Reuses Minimongo's diff algorithm implementation.\n\t  // XXX Should be replaced with the original diffArray function here:\n\t  // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n\t  // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n\t  function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n\t    preventNestedDiff = !!preventNestedDiff;\n\t\n\t    var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges || Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\t\n\t    var oldObjIds = [];\n\t    var newObjIds = [];\n\t    var posOld = {}; // maps from idStringify'd ids\n\t    var posNew = {}; // ditto\n\t    var posCur = {};\n\t    var lengthCur = lastSeqArray.length;\n\t\n\t    _underscore2.default.each(seqArray, function (doc, i) {\n\t      newObjIds.push({ _id: doc._id });\n\t      posNew[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    _underscore2.default.each(lastSeqArray, function (doc, i) {\n\t      oldObjIds.push({ _id: doc._id });\n\t      posOld[idStringify(doc._id)] = i;\n\t      posCur[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    // Arrays can contain arbitrary objects. We don't diff the\n\t    // objects. Instead we always fire 'changedAt' callback on every\n\t    // object. The consumer of `observe-sequence` should deal with\n\t    // it appropriately.\n\t    diffFn(oldObjIds, newObjIds, {\n\t      addedBefore: function addedBefore(id, doc, before) {\n\t        var position = before ? posCur[idStringify(before)] : lengthCur;\n\t\n\t        _underscore2.default.each(posCur, function (pos, id) {\n\t          if (pos >= position) posCur[id]++;\n\t        });\n\t\n\t        lengthCur++;\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.addedAt(id, seqArray[posNew[idStringify(id)]], position, before);\n\t      },\n\t\n\t      movedBefore: function movedBefore(id, before) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t        var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\t\n\t        _underscore2.default.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition && pos <= position) posCur[id]--;else if (pos <= prevPosition && pos >= position) posCur[id]++;\n\t        });\n\t\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.movedTo(id, seqArray[posNew[idStringify(id)]], prevPosition, position, before);\n\t      },\n\t      removed: function removed(id) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t\n\t        _underscore2.default.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition) posCur[id]--;\n\t        });\n\t\n\t        delete posCur[idStringify(id)];\n\t        lengthCur--;\n\t\n\t        callbacks.removedAt(id, lastSeqArray[posOld[idStringify(id)]], prevPosition);\n\t      }\n\t    });\n\t\n\t    _underscore2.default.each(posNew, function (pos, idString) {\n\t      if (!_underscore2.default.has(posOld, idString)) return;\n\t\n\t      var id = idParse(idString);\n\t      var newItem = seqArray[pos] || {};\n\t      var oldItem = lastSeqArray[posOld[idString]];\n\t      var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n\t\n\t      if (!_underscore2.default.isEmpty(updates)) callbacks.changedAt(id, updates, pos, oldItem);\n\t    });\n\t  }\n\t\n\t  diffArray.shallow = function (lastSeqArray, seqArray, callbacks) {\n\t    return diffArray(lastSeqArray, seqArray, callbacks, true);\n\t  };\n\t\n\t  diffArray.deepCopyChanges = function (oldItem, newItem) {\n\t    var setDiff = getUpdates(oldItem, newItem).$set;\n\t\n\t    _underscore2.default.each(setDiff, function (v, deepKey) {\n\t      setDeep(oldItem, deepKey, v);\n\t    });\n\t  };\n\t\n\t  diffArray.deepCopyRemovals = function (oldItem, newItem) {\n\t    var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\t\n\t    _underscore2.default.each(unsetDiff, function (v, deepKey) {\n\t      unsetDeep(oldItem, deepKey);\n\t    });\n\t  };\n\t\n\t  // Finds changes between two collections\n\t  diffArray.getChanges = function (newCollection, oldCollection, diffMethod) {\n\t    var changes = { added: [], removed: [], changed: [] };\n\t\n\t    diffMethod(oldCollection, newCollection, {\n\t      addedAt: function addedAt(id, item, index) {\n\t        changes.added.push({ item: item, index: index });\n\t      },\n\t\n\t      removedAt: function removedAt(id, item, index) {\n\t        changes.removed.push({ item: item, index: index });\n\t      },\n\t\n\t      changedAt: function changedAt(id, updates, index, oldItem) {\n\t        changes.changed.push({ selector: id, modifier: updates });\n\t      },\n\t\n\t      movedTo: function movedTo(id, item, fromIndex, toIndex) {\n\t        // XXX do we need this?\n\t      }\n\t    });\n\t\n\t    return changes;\n\t  };\n\t\n\t  var setDeep = function setDeep(obj, deepKey, v) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _underscore2.default.initial(split);\n\t    var lastKey = _underscore2.default.last(split);\n\t\n\t    initialKeys.reduce(function (subObj, k, i) {\n\t      var nextKey = split[i + 1];\n\t\n\t      if (isNumStr(nextKey)) {\n\t        if (subObj[k] === null) subObj[k] = [];\n\t        if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n\t      } else if (subObj[k] === null || !isHash(subObj[k])) {\n\t        subObj[k] = {};\n\t      }\n\t\n\t      return subObj[k];\n\t    }, obj);\n\t\n\t    var deepObj = getDeep(obj, initialKeys);\n\t    deepObj[lastKey] = v;\n\t    return v;\n\t  };\n\t\n\t  var unsetDeep = function unsetDeep(obj, deepKey) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _underscore2.default.initial(split);\n\t    var lastKey = _underscore2.default.last(split);\n\t    var deepObj = getDeep(obj, initialKeys);\n\t\n\t    if (_underscore2.default.isArray(deepObj) && isNumStr(lastKey)) return !!deepObj.splice(lastKey, 1);else return delete deepObj[lastKey];\n\t  };\n\t\n\t  var getDeep = function getDeep(obj, keys) {\n\t    return keys.reduce(function (subObj, k) {\n\t      return subObj[k];\n\t    }, obj);\n\t  };\n\t\n\t  var isHash = function isHash(obj) {\n\t    return _underscore2.default.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n\t  };\n\t\n\t  var isNumStr = function isNumStr(str) {\n\t    return str.match(/^\\d+$/);\n\t  };\n\t\n\t  return diffArray;\n\t}]);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tangular.module('angular-meteor.settings', []).constant('$angularMeteorSettings', {\n\t  suppressWarnings: true\n\t});\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tangular.module('angular-meteor.ironrouter', []).run(['$compile', '$document', '$rootScope', function ($compile, $document, $rootScope) {\n\t  var Router = (Package['iron:router'] || {}).Router;\n\t  if (!Router) return;\n\t\n\t  var isLoaded = false;\n\t\n\t  // Recompile after iron:router builds page\n\t  Router.onAfterAction(function (req, res, next) {\n\t    Tracker.afterFlush(function () {\n\t      if (isLoaded) return;\n\t      $compile($document)($rootScope);\n\t      if (!$rootScope.$$phase) $rootScope.$apply();\n\t      isLoaded = true;\n\t    });\n\t  });\n\t}]);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; /*global\n\t                                                                                                                                                                                                                                                   angular, _, Tracker, EJSON, FS, Mongo\n\t                                                                                                                                                                                                                                                   */\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t'use strict';\n\t\n\tvar angularMeteorUtils = angular.module('angular-meteor.utils', ['angular-meteor.settings']);\n\t\n\tangularMeteorUtils.service('$meteorUtils', ['$q', '$timeout', '$angularMeteorSettings', function ($q, $timeout, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this.autorun = function (scope, fn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    // wrapping around Deps.autorun\n\t    var comp = Tracker.autorun(function (c) {\n\t      fn(c);\n\t      // this is run immediately for the first call\n\t      // but after that, we need to $apply to start Angular digest\n\t      if (!c.firstRun) $timeout(angular.noop, 0);\n\t    });\n\t\n\t    // stop autorun when scope is destroyed\n\t    scope.$on('$destroy', function () {\n\t      comp.stop();\n\t    });\n\t\n\t    // return autorun object so that it can be stopped manually\n\t    return comp;\n\t  };\n\t\n\t  // Borrowed from angularFire\n\t  // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n\t  this.stripDollarPrefixedKeys = function (data) {\n\t    if (!_underscore2.default.isObject(data) || data instanceof Date || data instanceof File || EJSON.toJSONValue(data).$type === 'oid' || (typeof FS === 'undefined' ? 'undefined' : _typeof(FS)) === 'object' && data instanceof FS.File) return data;\n\t\n\t    var out = _underscore2.default.isArray(data) ? [] : {};\n\t\n\t    _underscore2.default.each(data, function (v, k) {\n\t      if (typeof k !== 'string' || k.charAt(0) !== '$') out[k] = self.stripDollarPrefixedKeys(v);\n\t    });\n\t\n\t    return out;\n\t  };\n\t\n\t  // Returns a callback which fulfills promise\n\t  this.fulfill = function (deferred, boundError, boundResult) {\n\t    return function (err, result) {\n\t      if (err) deferred.reject(boundError == null ? err : boundError);else if (typeof boundResult == \"function\") deferred.resolve(boundResult == null ? result : boundResult(result));else deferred.resolve(boundResult == null ? result : boundResult);\n\t    };\n\t  };\n\t\n\t  // creates a function which invokes method with the given arguments and returns a promise\n\t  this.promissor = function (obj, method) {\n\t    return function () {\n\t      var deferred = $q.defer();\n\t      var fulfill = self.fulfill(deferred);\n\t      var args = _underscore2.default.toArray(arguments).concat(fulfill);\n\t      obj[method].apply(obj, args);\n\t      return deferred.promise;\n\t    };\n\t  };\n\t\n\t  // creates a $q.all() promise and call digestion loop on fulfillment\n\t  this.promiseAll = function (promises) {\n\t    var allPromise = $q.all(promises);\n\t\n\t    allPromise.finally(function () {\n\t      // calls digestion loop with no conflicts\n\t      $timeout(angular.noop);\n\t    });\n\t\n\t    return allPromise;\n\t  };\n\t\n\t  this.getCollectionByName = function (string) {\n\t    return Mongo.Collection.get(string);\n\t  };\n\t\n\t  this.findIndexById = function (collection, doc) {\n\t    var foundDoc = _underscore2.default.find(collection, function (colDoc) {\n\t      // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n\t      return EJSON.equals(colDoc._id, doc._id);\n\t    });\n\t\n\t    return _underscore2.default.indexOf(collection, foundDoc);\n\t  };\n\t}]);\n\t\n\tangularMeteorUtils.run(['$rootScope', '$meteorUtils', function ($rootScope, $meteorUtils) {\n\t  Object.getPrototypeOf($rootScope).$meteorAutorun = function (fn) {\n\t    return $meteorUtils.autorun(this, fn);\n\t  };\n\t}]);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Meteor\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', ['angular-meteor.settings']);\n\t\n\tangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings', function ($q, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this._subscribe = function (scope, deferred, args) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var subscription = null;\n\t    var lastArg = args[args.length - 1];\n\t\n\t    // User supplied onStop callback\n\t    // save it for later use and remove\n\t    // from subscription arguments\n\t    if (angular.isObject(lastArg) && angular.isFunction(lastArg.onStop)) {\n\t      var _onStop = lastArg.onStop;\n\t\n\t      args.pop();\n\t    }\n\t\n\t    args.push({\n\t      onReady: function onReady() {\n\t        deferred.resolve(subscription);\n\t      },\n\t      onStop: function onStop(err) {\n\t        if (!deferred.promise.$$state.status) {\n\t          if (err) deferred.reject(err);else deferred.reject(new Meteor.Error(\"Subscription Stopped\", \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n\t        } else if (_onStop)\n\t          // After promise was resolved or rejected\n\t          // call user supplied onStop callback.\n\t          _onStop.apply(this, Array.prototype.slice.call(arguments));\n\t      }\n\t    });\n\t\n\t    subscription = Meteor.subscribe.apply(scope, args);\n\t\n\t    return subscription;\n\t  };\n\t\n\t  this.subscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var subscription = null;\n\t\n\t    self._subscribe(this, deferred, args);\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\t\n\tangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe', function ($rootScope, $q, $meteorSubscribe) {\n\t  Object.getPrototypeOf($rootScope).$meteorSubscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\t\n\t    this.$on('$destroy', function () {\n\t      subscription.stop();\n\t    });\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t'use strict'; /*global\n\t               angular, _, Tracker, check, Match, Mongo\n\t               */\n\t\n\tvar angularMeteorCollection = angular.module('angular-meteor.collection', ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray', 'angular-meteor.settings']);\n\t\n\t// The reason angular meteor collection is a factory function and not something\n\t// that inherit from array comes from here:\n\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n\t// We went with the direct extensions approach.\n\tangularMeteorCollection.factory('AngularMeteorCollection', ['$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\n\t\n\t  function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var data = [];\n\t    // Server backup data to evaluate what changes come from client\n\t    // after each server update.\n\t    data._serverBackup = [];\n\t    // Array differ function.\n\t    data._diffArrayFunc = diffArrayFunc;\n\t    // Handler of the cursor observer.\n\t    data._hObserve = null;\n\t    // On new cursor autorun handler\n\t    // (autorun for reactive variables).\n\t    data._hNewCurAutorun = null;\n\t    // On new data autorun handler\n\t    // (autorun for cursor.fetch).\n\t    data._hDataAutorun = null;\n\t\n\t    if (angular.isDefined(collection)) {\n\t      data.$$collection = collection;\n\t    } else {\n\t      var cursor = curDefFunc();\n\t      data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n\t    }\n\t\n\t    _underscore2.default.extend(data, AngularMeteorCollection);\n\t    data._startCurAutorun(curDefFunc, autoClientSave);\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorCollection._startCurAutorun = function (curDefFunc, autoClientSave) {\n\t    var self = this;\n\t\n\t    self._hNewCurAutorun = Tracker.autorun(function () {\n\t      // When the reactive func gets recomputated we need to stop any previous\n\t      // observeChanges.\n\t      Tracker.onInvalidate(function () {\n\t        self._stopCursor();\n\t      });\n\t\n\t      if (autoClientSave) self._setAutoClientSave();\n\t      self._updateCursor(curDefFunc(), autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorCollection.save = function (docs, useUnsetModifier) {\n\t    // save whole collection\n\t    if (!docs) docs = this;\n\t    // save single doc\n\t    docs = [].concat(docs);\n\t\n\t    var promises = docs.map(function (doc) {\n\t      return this._upsertDoc(doc, useUnsetModifier);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._upsertDoc = function (doc, useUnsetModifier) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _underscore2.default.partial($meteorUtils.fulfill, deferred, null);\n\t\n\t    // delete $$hashkey\n\t    doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n\t    var docId = doc._id;\n\t    var isExist = collection.findOne(docId);\n\t\n\t    // update\n\t    if (isExist) {\n\t      // Deletes _id property (from the copy) so that\n\t      // it can be $set using update.\n\t      delete doc._id;\n\t      var modifier = useUnsetModifier ? { $unset: doc } : { $set: doc };\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      collection.update(docId, modifier, createFulfill(function () {\n\t        return { _id: docId, action: 'updated' };\n\t      }));\n\t    }\n\t    // insert\n\t    else {\n\t        collection.insert(doc, createFulfill(function (id) {\n\t          return { _id: id, action: 'inserted' };\n\t        }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  // performs $pull operations parallely.\n\t  // used for handling splice operations returned from getUpdates() to prevent conflicts.\n\t  // see issue: https://github.com/Urigo/angular-meteor/issues/793\n\t  AngularMeteorCollection._updateDiff = function (selector, update, callback) {\n\t    callback = callback || angular.noop;\n\t    var setters = _underscore2.default.omit(update, '$pull');\n\t    var updates = [setters];\n\t\n\t    _underscore2.default.each(update.$pull, function (pull, prop) {\n\t      var puller = {};\n\t      puller[prop] = pull;\n\t      updates.push({ $pull: puller });\n\t    });\n\t\n\t    this._updateParallel(selector, updates, callback);\n\t  };\n\t\n\t  // performs each update operation parallely\n\t  AngularMeteorCollection._updateParallel = function (selector, updates, callback) {\n\t    var self = this;\n\t    var done = _underscore2.default.after(updates.length, callback);\n\t\n\t    var next = function next(err, affectedDocsNum) {\n\t      if (err) return callback(err);\n\t      done(null, affectedDocsNum);\n\t    };\n\t\n\t    _underscore2.default.each(updates, function (update) {\n\t      self.$$collection.update(selector, update, next);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.remove = function (keyOrDocs) {\n\t    var keys;\n\t\n\t    // remove whole collection\n\t    if (!keyOrDocs) {\n\t      keys = _underscore2.default.pluck(this, '_id');\n\t    }\n\t    // remove docs\n\t    else {\n\t        keyOrDocs = [].concat(keyOrDocs);\n\t\n\t        keys = _underscore2.default.map(keyOrDocs, function (keyOrDoc) {\n\t          return keyOrDoc._id || keyOrDoc;\n\t        });\n\t      }\n\t\n\t    // Checks if all keys are correct.\n\t    check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\t\n\t    var promises = keys.map(function (key) {\n\t      return this._removeDoc(key);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._removeDoc = function (id) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n\t    collection.remove(id, fulfill);\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorCollection._updateCursor = function (cursor, autoClientSave) {\n\t    var self = this;\n\t    // XXX - consider adding an option for a non-orderd result for faster performance\n\t    if (self._hObserve) self._stopObserving();\n\t\n\t    self._hObserve = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        self.splice(atIndex, 0, doc);\n\t        self._serverBackup.splice(atIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        diffArray.deepCopyChanges(self[atIndex], doc);\n\t        diffArray.deepCopyRemovals(self[atIndex], doc);\n\t        self._serverBackup[atIndex] = self[atIndex];\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        self.splice(fromIndex, 1);\n\t        self.splice(toIndex, 0, doc);\n\t        self._serverBackup.splice(fromIndex, 1);\n\t        self._serverBackup.splice(toIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      removedAt: function removedAt(oldDoc) {\n\t        var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\n\t\n\t        if (removedIndex != -1) {\n\t          self.splice(removedIndex, 1);\n\t          self._serverBackup.splice(removedIndex, 1);\n\t          self._setServerUpdateMode();\n\t        } else {\n\t          // If it's been removed on client then it's already not in collection\n\t          // itself but still is in the _serverBackup.\n\t          removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\n\t\n\t          if (removedIndex != -1) {\n\t            self._serverBackup.splice(removedIndex, 1);\n\t          }\n\t        }\n\t      }\n\t    });\n\t\n\t    self._hDataAutorun = Tracker.autorun(function () {\n\t      cursor.fetch();\n\t      if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection._stopObserving = function () {\n\t    this._hObserve.stop();\n\t    this._hDataAutorun.stop();\n\t    delete this._serverMode;\n\t    delete this._hUnsetTimeout;\n\t  };\n\t\n\t  AngularMeteorCollection._setServerUpdateMode = function (name) {\n\t    this._serverMode = true;\n\t    // To simplify server update logic, we don't follow\n\t    // updates from the client at the same time.\n\t    this._unsetAutoClientSave();\n\t  };\n\t\n\t  // Here we use $timeout to combine multiple updates that go\n\t  // each one after another.\n\t  AngularMeteorCollection._unsetServerUpdateMode = function (autoClientSave) {\n\t    var self = this;\n\t\n\t    if (self._hUnsetTimeout) {\n\t      $timeout.cancel(self._hUnsetTimeout);\n\t      self._hUnsetTimeout = null;\n\t    }\n\t\n\t    self._hUnsetTimeout = $timeout(function () {\n\t      self._serverMode = false;\n\t      // Finds updates that was potentially done from the client side\n\t      // and saves them.\n\t      var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\n\t      self._saveChanges(changes);\n\t      // After, continues following client updates.\n\t      if (autoClientSave) self._setAutoClientSave();\n\t    }, 0);\n\t  };\n\t\n\t  AngularMeteorCollection.stop = function () {\n\t    this._stopCursor();\n\t    this._hNewCurAutorun.stop();\n\t  };\n\t\n\t  AngularMeteorCollection._stopCursor = function () {\n\t    this._unsetAutoClientSave();\n\t\n\t    if (this._hObserve) {\n\t      this._hObserve.stop();\n\t      this._hDataAutorun.stop();\n\t    }\n\t\n\t    this.splice(0);\n\t    this._serverBackup.splice(0);\n\t  };\n\t\n\t  AngularMeteorCollection._unsetAutoClientSave = function (name) {\n\t    if (this._hRegAutoBind) {\n\t      this._hRegAutoBind();\n\t      this._hRegAutoBind = null;\n\t    }\n\t  };\n\t\n\t  AngularMeteorCollection._setAutoClientSave = function () {\n\t    var self = this;\n\t\n\t    // Always unsets auto save to keep only one $watch handler.\n\t    self._unsetAutoClientSave();\n\t\n\t    self._hRegAutoBind = $rootScope.$watch(function () {\n\t      return self;\n\t    }, function (nItems, oItems) {\n\t      if (nItems === oItems) return;\n\t\n\t      var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\n\t      self._unsetAutoClientSave();\n\t      self._saveChanges(changes);\n\t      self._setAutoClientSave();\n\t    }, true);\n\t  };\n\t\n\t  AngularMeteorCollection._saveChanges = function (changes) {\n\t    var self = this;\n\t\n\t    // Saves added documents\n\t    // Using reversed iteration to prevent indexes from changing during splice\n\t    var addedDocs = changes.added.reverse().map(function (descriptor) {\n\t      self.splice(descriptor.index, 1);\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (addedDocs.length) self.save(addedDocs);\n\t\n\t    // Removes deleted documents\n\t    var removedDocs = changes.removed.map(function (descriptor) {\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (removedDocs.length) self.remove(removedDocs);\n\t\n\t    // Updates changed documents\n\t    changes.changed.forEach(function (descriptor) {\n\t      self._updateDiff(descriptor.selector, descriptor.modifier);\n\t    });\n\t  };\n\t\n\t  return AngularMeteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollectionFS', ['$meteorCollection', 'diffArray', '$angularMeteorSettings', function ($meteorCollection, diffArray, $angularMeteorSettings) {\n\t  function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n\t\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\n\t  }\n\t\n\t  return $meteorCollectionFS;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollection', ['AngularMeteorCollection', '$rootScope', 'diffArray', function (AngularMeteorCollection, $rootScope, diffArray) {\n\t  function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\n\t    // Validate parameters\n\t    if (!reactiveFunc) {\n\t      throw new TypeError('The first argument of $meteorCollection is undefined.');\n\t    }\n\t\n\t    if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n\t      throw new TypeError('The first argument of $meteorCollection must be a function or ' + 'a have a find function property.');\n\t    }\n\t\n\t    if (!angular.isFunction(reactiveFunc)) {\n\t      collection = angular.isDefined(collection) ? collection : reactiveFunc;\n\t      reactiveFunc = _underscore2.default.bind(reactiveFunc.find, reactiveFunc);\n\t    }\n\t\n\t    // By default auto save - true.\n\t    autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n\t    diffFn = diffFn || diffArray;\n\t    return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\n\t  }\n\t\n\t  return $meteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.run(['$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper', function ($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n\t  scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n\t}]);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t'use strict'; /*global\n\t                angular, _, Mongo\n\t              */\n\t\n\tvar angularMeteorObject = angular.module('angular-meteor.object', ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray', 'angular-meteor.settings']);\n\t\n\tangularMeteorObject.factory('AngularMeteorObject', ['$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\n\t\n\t  // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n\t  AngularMeteorObject.$$internalProps = ['$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope', 'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject', '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'];\n\t\n\t  function AngularMeteorObject(collection, selector, options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    // Make data not be an object so we can extend it to preserve\n\t    // Collection Helpers and the like\n\t    var helpers = collection._helpers;\n\t    var data = _underscore2.default.isFunction(helpers) ? Object.create(helpers.prototype) : {};\n\t    var doc = collection.findOne(selector, options);\n\t    var collectionExtension = _underscore2.default.pick(AngularMeteorCollection, '_updateParallel');\n\t    _underscore2.default.extend(data, doc);\n\t    _underscore2.default.extend(data, AngularMeteorObject);\n\t    _underscore2.default.extend(data, collectionExtension);\n\t\n\t    // Omit options that may spoil document finding\n\t    data.$$options = _underscore2.default.omit(options, 'skip', 'limit');\n\t    data.$$collection = collection;\n\t    data.$$id = data._getId(selector);\n\t    data._serverBackup = doc || {};\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorObject.getRawObject = function () {\n\t    return angular.copy(_underscore2.default.omit(this, this.$$internalProps));\n\t  };\n\t\n\t  AngularMeteorObject.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorObject.save = function (custom) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _underscore2.default.partial($meteorUtils.fulfill, deferred, null);\n\t    var oldDoc = collection.findOne(this.$$id);\n\t    var mods;\n\t\n\t    // update\n\t    if (oldDoc) {\n\t      if (custom) mods = { $set: custom };else {\n\t        mods = getUpdates(oldDoc, this.getRawObject());\n\t        // If there are no updates, there is nothing to do here, returning\n\t        if (_underscore2.default.isEmpty(mods)) {\n\t          return $q.when({ action: 'updated' });\n\t        }\n\t      }\n\t\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      this._updateDiff(mods, createFulfill({ action: 'updated' }));\n\t    }\n\t    // insert\n\t    else {\n\t        if (custom) mods = _underscore2.default.clone(custom);else mods = this.getRawObject();\n\t\n\t        mods._id = mods._id || this.$$id;\n\t        collection.insert(mods, createFulfill({ action: 'inserted' }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorObject._updateDiff = function (update, callback) {\n\t    var selector = this.$$id;\n\t    AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\n\t  };\n\t\n\t  AngularMeteorObject.reset = function (keepClientProps) {\n\t    var self = this;\n\t    var options = this.$$options;\n\t    var id = this.$$id;\n\t    var doc = this.$$collection.findOne(id, options);\n\t\n\t    if (doc) {\n\t      // extend SubObject\n\t      var docKeys = _underscore2.default.keys(doc);\n\t      var docExtension = _underscore2.default.pick(doc, docKeys);\n\t      var clientProps;\n\t\n\t      _underscore2.default.extend(self, docExtension);\n\t      _underscore2.default.extend(self._serverBackup, docExtension);\n\t\n\t      if (keepClientProps) {\n\t        clientProps = _underscore2.default.intersection(_underscore2.default.keys(self), _underscore2.default.keys(self._serverBackup));\n\t      } else {\n\t        clientProps = _underscore2.default.keys(self);\n\t      }\n\t\n\t      var serverProps = _underscore2.default.keys(doc);\n\t      var removedKeys = _underscore2.default.difference(clientProps, serverProps, self.$$internalProps);\n\t\n\t      removedKeys.forEach(function (prop) {\n\t        delete self[prop];\n\t        delete self._serverBackup[prop];\n\t      });\n\t    } else {\n\t      _underscore2.default.keys(this.getRawObject()).forEach(function (prop) {\n\t        delete self[prop];\n\t      });\n\t\n\t      self._serverBackup = {};\n\t    }\n\t  };\n\t\n\t  AngularMeteorObject.stop = function () {\n\t    if (this.unregisterAutoDestroy) this.unregisterAutoDestroy();\n\t\n\t    if (this.unregisterAutoBind) this.unregisterAutoBind();\n\t\n\t    if (this.autorunComputation && this.autorunComputation.stop) this.autorunComputation.stop();\n\t  };\n\t\n\t  AngularMeteorObject._getId = function (selector) {\n\t    var options = _underscore2.default.extend({}, this.$$options, {\n\t      fields: { _id: 1 },\n\t      reactive: false,\n\t      transform: null\n\t    });\n\t\n\t    var doc = this.$$collection.findOne(selector, options);\n\t\n\t    if (doc) return doc._id;\n\t    if (selector instanceof Mongo.ObjectID) return selector;\n\t    if (_underscore2.default.isString(selector)) return selector;\n\t    return new Mongo.ObjectID();\n\t  };\n\t\n\t  return AngularMeteorObject;\n\t}]);\n\t\n\tangularMeteorObject.factory('$meteorObject', ['$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject', function ($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n\t  function $meteorObject(collection, id, auto, options) {\n\t    // Validate parameters\n\t    if (!collection) {\n\t      throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n\t    }\n\t\n\t    if (!angular.isFunction(collection.findOne)) {\n\t      throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n\t    }\n\t\n\t    var data = new AngularMeteorObject(collection, id, options);\n\t    // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n\t    data._auto = auto !== false;\n\t    _underscore2.default.extend(data, $meteorObject);\n\t    data._setAutos();\n\t    return data;\n\t  }\n\t\n\t  $meteorObject._setAutos = function () {\n\t    var self = this;\n\t\n\t    this.autorunComputation = $meteorUtils.autorun($rootScope, function () {\n\t      self.reset(true);\n\t    });\n\t\n\t    // Deep watches the model and performs autobind\n\t    this.unregisterAutoBind = this._auto && $rootScope.$watch(function () {\n\t      return self.getRawObject();\n\t    }, function (item, oldItem) {\n\t      if (item !== oldItem) self.save();\n\t    }, true);\n\t\n\t    this.unregisterAutoDestroy = $rootScope.$on('$destroy', function () {\n\t      if (self && self.stop) self.pop();\n\t    });\n\t  };\n\t\n\t  return $meteorObject;\n\t}]);\n\t\n\tangularMeteorObject.run(['$rootScope', '$meteorObject', '$meteorStopper', function ($rootScope, $meteorObject, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorObject = $meteorStopper($meteorObject);\n\t}]);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t'use strict'; /*global\n\t               angular, _, Package, Meteor\n\t               */\n\t\n\tvar angularMeteorUser = angular.module('angular-meteor.user', ['angular-meteor.utils', 'angular-meteor.core', 'angular-meteor.settings']);\n\t\n\t// requires package 'accounts-password'\n\tangularMeteorUser.service('$meteorUser', ['$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings', function ($rootScope, $meteorUtils, $q, $angularMeteorSettings) {\n\t\n\t  var pack = Package['accounts-base'];\n\t  if (!pack) return;\n\t\n\t  var self = this;\n\t  var Accounts = pack.Accounts;\n\t\n\t  this.waitForUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) deferred.resolve(Meteor.user());\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) {\n\t      console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    }\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) {\n\t        if (Meteor.user() === null) deferred.reject(\"AUTH_REQUIRED\");else deferred.resolve(Meteor.user());\n\t      }\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireValidUser = function (validatorFn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    return self.requireUser(true).then(function (user) {\n\t      var valid = validatorFn(user);\n\t\n\t      if (valid === true) return user;else if (typeof valid === \"string\") return $q.reject(valid);else return $q.reject(\"FORBIDDEN\");\n\t    });\n\t  };\n\t\n\t  this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n\t  this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n\t  this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n\t  this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n\t  this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n\t  this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n\t  this.logout = $meteorUtils.promissor(Meteor, 'logout');\n\t  this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n\t  this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n\t  this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n\t  this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n\t  this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n\t  this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n\t  this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n\t  this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n\t}]);\n\t\n\tangularMeteorUser.run(['$rootScope', '$angularMeteorSettings', '$$Core', function ($rootScope, $angularMeteorSettings, $$Core) {\n\t\n\t  var ScopeProto = Object.getPrototypeOf($rootScope);\n\t  _underscore2.default.extend(ScopeProto, $$Core);\n\t\n\t  $rootScope.autorun(function () {\n\t    if (!Meteor.user) return;\n\t    $rootScope.currentUser = Meteor.user();\n\t    $rootScope.loggingIn = Meteor.loggingIn();\n\t  });\n\t}]);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t'use strict'; /*global\n\t               angular, _, Meteor\n\t               */\n\t\n\tvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils', 'angular-meteor.settings']);\n\t\n\tangularMeteorMethods.service('$meteorMethods', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  this.call = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t    var fulfill = $meteorUtils.fulfill(deferred);\n\t    var args = _underscore2.default.toArray(arguments).concat(fulfill);\n\t    Meteor.call.apply(this, args);\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Session\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils', 'angular-meteor.settings']);\n\t\n\tangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings', function ($meteorUtils, $parse, $angularMeteorSettings) {\n\t  return function (session) {\n\t\n\t    return {\n\t\n\t      bind: function bind(scope, model) {\n\t        if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t        var getter = $parse(model);\n\t        var setter = getter.assign;\n\t        $meteorUtils.autorun(scope, function () {\n\t          setter(scope, Session.get(session));\n\t        });\n\t\n\t        scope.$watch(model, function (newItem, oldItem) {\n\t          Session.set(session, getter(scope));\n\t        }, true);\n\t      }\n\t    };\n\t  };\n\t}]);\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Package\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils', 'angular-meteor.settings']);\n\t\n\t// requires package 'mdg:camera'\n\tangularMeteorCamera.service('$meteorCamera', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t  var pack = Package['mdg:camera'];\n\t  if (!pack) return;\n\t\n\t  var MeteorCamera = pack.MeteorCamera;\n\t\n\t  this.getPicture = function (options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    options = options || {};\n\t    var deferred = $q.defer();\n\t    MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorStopper = angular.module('angular-meteor.stopper', ['angular-meteor.subscribe']);\n\t\n\tangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe', function ($q, $meteorSubscribe) {\n\t  function $meteorStopper($meteorEntity) {\n\t    return function () {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var meteorEntity = $meteorEntity.apply(this, args);\n\t\n\t      angular.extend(meteorEntity, $meteorStopper);\n\t      meteorEntity.$$scope = this;\n\t\n\t      this.$on('$destroy', function () {\n\t        meteorEntity.stop();\n\t        if (meteorEntity.subscription) meteorEntity.subscription.stop();\n\t      });\n\t\n\t      return meteorEntity;\n\t    };\n\t  }\n\t\n\t  $meteorStopper.subscribe = function () {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\n\t    return this;\n\t  };\n\t\n\t  return $meteorStopper;\n\t}]);\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.utils = exports.name = undefined;\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar name = exports.name = 'angular-meteor.utilities';\n\tvar utils = exports.utils = '$$utils';\n\t\n\tangular.module(name, [])\n\t\n\t/*\n\t  A utility service which is provided with general utility functions\n\t */\n\t.service(utils, ['$rootScope', function ($rootScope) {\n\t  var self = this;\n\t\n\t  // Checks if an object is a cursor\n\t  this.isCursor = function (obj) {\n\t    return obj instanceof Meteor.Collection.Cursor;\n\t  };\n\t\n\t  // Cheecks if an object is a scope\n\t  this.isScope = function (obj) {\n\t    return obj instanceof $rootScope.constructor;\n\t  };\n\t\n\t  // Checks if an object is a view model\n\t  this.isViewModel = function (obj) {\n\t    return _underscore2.default.isObject(obj) && obj.$$dependencies;\n\t  };\n\t\n\t  // Checks if two objects are siblings\n\t  this.areSiblings = function (obj1, obj2) {\n\t    return _underscore2.default.isObject(obj1) && _underscore2.default.isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t  };\n\t\n\t  // Binds function into a scpecified context. If an object is provided, will bind every\n\t  // value in the object which is a function. If a tap function is provided, it will be\n\t  // called right after the function has been invoked.\n\t  this.bind = function (fn, context, tap) {\n\t    tap = _underscore2.default.isFunction(tap) ? tap : angular.noop;\n\t    if (_underscore2.default.isFunction(fn)) return bindFn(fn, context, tap);\n\t    if (_underscore2.default.isObject(fn)) return bindObj(fn, context, tap);\n\t    return fn;\n\t  };\n\t\n\t  function bindFn(fn, context, tap) {\n\t    return function () {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      var result = fn.apply(context, args);\n\t      tap.call(context, {\n\t        result: result,\n\t        args: args\n\t      });\n\t      return result;\n\t    };\n\t  }\n\t\n\t  function bindObj(obj, context, tap) {\n\t    return _underscore2.default.keys(obj).reduce(function (bound, k) {\n\t      bound[k] = self.bind(obj[k], context, tap);\n\t      return bound;\n\t    }, {});\n\t  }\n\t}]);\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Mixer = exports.name = undefined;\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar name = exports.name = 'angular-meteor.mixer';\n\tvar Mixer = exports.Mixer = '$Mixer';\n\t\n\tangular.module(name, [])\n\t\n\t/*\n\t  A service which lets us apply mixins into Scope.prototype.\n\t  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n\t  and any time a `ChildScope` prototype is created\n\t  it will be extended by the `$Mixer`.\n\t  This concept is good because it keeps our code\n\t  clean and simple, and easy to extend.\n\t  So any time we would like to define a new behaviour to our scope,\n\t  we will just use the `$Mixer` service.\n\t */\n\t.service(Mixer, function () {\n\t  var _this = this;\n\t\n\t  // Used to store method's caller\n\t  var caller = undefined;\n\t\n\t  this._mixins = [];\n\t  // Apply mixins automatically on specified contexts\n\t  this._autoExtend = [];\n\t  this._autoConstruct = [];\n\t\n\t  // Adds a new mixin\n\t  this.mixin = function (mixin) {\n\t    if (!_underscore2.default.isObject(mixin)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    _this._mixins = _underscore2.default.union(_this._mixins, [mixin]);\n\t    // Apply mixins to stored contexts\n\t    _this._autoExtend.forEach(function (context) {\n\t      return _this._extend(context);\n\t    });\n\t    _this._autoConstruct.forEach(function (context) {\n\t      return _this._construct(context);\n\t    });\n\t    return _this;\n\t  };\n\t\n\t  // Removes a mixin. Useful mainly for test purposes\n\t  this._mixout = function (mixin) {\n\t    _this._mixins = _underscore2.default.without(_this._mixins, mixin);\n\t    return _this;\n\t  };\n\t\n\t  // Invoke function mixins with the provided context and arguments\n\t  this._construct = function (context) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    _this._mixins.filter(_underscore2.default.isFunction).forEach(function (mixin) {\n\t      mixin.call.apply(mixin, [context].concat(args));\n\t    });\n\t\n\t    return context;\n\t  };\n\t\n\t  // Extend prototype with the defined mixins\n\t  this._extend = function (obj, options) {\n\t    var _$defaults = _underscore2.default.defaults({}, options, {\n\t      pattern: /.*/ });\n\t\n\t    var pattern = _$defaults.pattern;\n\t    var context = _$defaults.context;\n\t    // The patterns of the keys which will be filtered\n\t\n\t\n\t    var mixins = _this._mixins.map(function (mixin) {\n\t      // Filtering the keys by the specified pattern\n\t      var keys = _underscore2.default.keys(mixin).filter(function (k) {\n\t        return k.match(pattern);\n\t      }).filter(function (k) {\n\t        return _underscore2.default.isFunction(mixin[k]);\n\t      });\n\t\n\t      return keys.reduce(function (boundMixin, methodName) {\n\t        var methodHandler = mixin[methodName];\n\t\n\t        // Note that this is not an arrow function so we can conserve the conetxt\n\t        boundMixin[methodName] = function () {\n\t          // Storing original caller so we will know who actually called the\n\t          // method event though it is bound to another context\n\t          var methodContext = context || this;\n\t          var recentCaller = caller;\n\t          caller = this;\n\t\n\t          try {\n\t            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t              args[_key2] = arguments[_key2];\n\t            }\n\t\n\t            return methodHandler.apply(methodContext, args);\n\t          } finally {\n\t            // No matter what happens, restore variable to the previous one\n\t            caller = recentCaller;\n\t          }\n\t        };\n\t\n\t        return boundMixin;\n\t      }, {});\n\t    });\n\t\n\t    return _underscore2.default.extend.apply(_underscore2.default, [obj].concat(_toConsumableArray(mixins)));\n\t  };\n\t\n\t  // Caller property can not be set\n\t  Object.defineProperty(this, 'caller', {\n\t    configurable: true,\n\t    enumerable: true,\n\t\n\t    get: function get() {\n\t      return caller;\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.name = undefined;\n\t\n\tvar _mixer = __webpack_require__(17);\n\t\n\tvar name = exports.name = 'angular-meteor.scope';\n\t\n\tangular.module(name, [_mixer.name]).run(['$rootScope', _mixer.Mixer, function ($rootScope, $Mixer) {\n\t  var Scope = $rootScope.constructor;\n\t  var $new = $rootScope.$new;\n\t\n\t  // Apply extensions whether a mixin in defined.\n\t  // Note that this way mixins which are initialized later\n\t  // can be applied on rootScope.\n\t  $Mixer._autoExtend.push(Scope.prototype);\n\t  $Mixer._autoConstruct.push($rootScope);\n\t\n\t  Scope.prototype.$new = function () {\n\t    var scope = $new.apply(this, arguments);\n\t    // Apply constructors to newly created scopes\n\t    return $Mixer._construct(scope);\n\t  };\n\t}]);\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Core = exports.name = undefined;\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tvar _utils = __webpack_require__(16);\n\t\n\tvar _mixer = __webpack_require__(17);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar name = exports.name = 'angular-meteor.core';\n\tvar Core = exports.Core = '$$Core';\n\t\n\tangular.module(name, [_utils.name, _mixer.name])\n\t\n\t/*\n\t  A mixin which provides us with core Meteor functions.\n\t */\n\t.factory(Core, ['$q', _utils.utils, _mixer.Mixer, function ($q, $$utils, $Mixer) {\n\t  function $$Core() {}\n\t\n\t  // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n\t  $$Core.autorun = function (fn) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    fn = this.$bindToContext($Mixer.caller, fn);\n\t\n\t    if (!_underscore2.default.isFunction(fn)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t    if (!_underscore2.default.isObject(options)) {\n\t      throw Error('argument 2 must be an object');\n\t    }\n\t\n\t    var computation = Tracker.autorun(fn, options);\n\t    // Reset to a function that will also stop the listener we just added\n\t    computation.stop = this.$$autoStop(computation);\n\t    return computation;\n\t  };\n\t\n\t  // Calls Meteor.subscribe() which will be digested after each invokation\n\t  // and automatically destroyed\n\t  $$Core.subscribe = function (subName, fn, cb) {\n\t    fn = this.$bindToContext($Mixer.caller, fn || angular.noop);\n\t    cb = cb ? this.$bindToContext($Mixer.caller, cb) : angular.noop;\n\t\n\t    // Additional callbacks specific for this library\n\t    // onStart - right after Meteor.subscribe()\n\t    var hooks = {\n\t      onStart: angular.noop\n\t    };\n\t\n\t    if (!_underscore2.default.isString(subName)) {\n\t      throw Error('argument 1 must be a string');\n\t    }\n\t    if (!_underscore2.default.isFunction(fn)) {\n\t      throw Error('argument 2 must be a function');\n\t    }\n\t    if (!_underscore2.default.isFunction(cb) && !_underscore2.default.isObject(cb)) {\n\t      throw Error('argument 3 must be a function or an object');\n\t    }\n\t\n\t    if (_underscore2.default.isObject(cb)) {\n\t      for (var hook in hooks) {\n\t        if (hooks.hasOwnProperty(hook) && cb[hook]) {\n\t          // Don't use any of additional callbacks in Meteor.subscribe\n\t          hooks[hook] = cb[hook];\n\t          delete cb[hook];\n\t        }\n\t      }\n\t    }\n\t\n\t    var result = {};\n\t\n\t    var computation = this.autorun(function () {\n\t      var _Meteor;\n\t\n\t      var args = fn();\n\t      if (angular.isUndefined(args)) args = [];\n\t\n\t      if (!_underscore2.default.isArray(args)) {\n\t        throw Error('reactive function\\'s return value must be an array');\n\t      }\n\t\n\t      var subscription = (_Meteor = Meteor).subscribe.apply(_Meteor, [subName].concat(_toConsumableArray(args), [cb]));\n\t\n\t      hooks.onStart();\n\t\n\t      result.ready = subscription.ready.bind(subscription);\n\t      result.subscriptionId = subscription.subscriptionId;\n\t    });\n\t\n\t    // Once the computation has been stopped,\n\t    // any subscriptions made inside will be stopped as well\n\t    result.stop = computation.stop.bind(computation);\n\t    return result;\n\t  };\n\t\n\t  // Calls Meteor.call() wrapped by a digestion cycle\n\t  $$Core.callMethod = function () {\n\t    var _Meteor2;\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_underscore2.default.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n\t    return (_Meteor2 = Meteor).call.apply(_Meteor2, args.concat([fn]));\n\t  };\n\t\n\t  // Calls Meteor.apply() wrapped by a digestion cycle\n\t  $$Core.applyMethod = function () {\n\t    var _Meteor3;\n\t\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_underscore2.default.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n\t    return (_Meteor3 = Meteor).apply.apply(_Meteor3, args.concat([fn]));\n\t  };\n\t\n\t  // Stops a process once the scope has been destroyed\n\t  $$Core.$$autoStop = function (stoppable) {\n\t    var removeListener = undefined;\n\t    var baseStop = stoppable.stop.bind(stoppable);\n\t\n\t    // Once the process has been stopped the destroy event listener will be removed\n\t    // to avoid memory leaks and unexpected behaviours\n\t    var stop = function stop() {\n\t      removeListener();\n\t      return baseStop.apply(undefined, arguments);\n\t    };\n\t\n\t    removeListener = this.$on('$destroy', stop);\n\t    return stop;\n\t  };\n\t\n\t  // Digests scope only if there is no phase at the moment\n\t  $$Core.$$throttledDigest = function () {\n\t    var isDigestable = !this.$$destroyed && !this.$$phase && !this.$root.$$phase;\n\t\n\t    if (isDigestable) this.$digest();\n\t  };\n\t\n\t  // Creates a promise only that the digestion cycle will be called at its fulfillment\n\t  $$Core.$$defer = function () {\n\t    var deferred = $q.defer();\n\t    // Once promise has been fulfilled, digest\n\t    deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n\t    return deferred;\n\t  };\n\t\n\t  // Binds an object or a function to the provided context and digest it once it is invoked\n\t  $$Core.$bindToContext = function (context, fn) {\n\t    if (_underscore2.default.isFunction(context)) {\n\t      fn = context;\n\t      context = this;\n\t    }\n\t\n\t    return $$utils.bind(fn, context, this.$$throttledDigest.bind(this));\n\t  };\n\t\n\t  return $$Core;\n\t}]);\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.reactive = exports.ViewModel = exports.name = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tvar _utils = __webpack_require__(16);\n\t\n\tvar _mixer = __webpack_require__(17);\n\t\n\tvar _core = __webpack_require__(19);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar name = exports.name = 'angular-meteor.view-model';\n\tvar ViewModel = exports.ViewModel = '$$ViewModel';\n\tvar reactive = exports.reactive = '$reactive';\n\t\n\tangular.module(name, [_utils.name, _mixer.name, _core.name])\n\t\n\t/*\n\t  A mixin which lets us bind a view model into a scope.\n\t  Note that only a single view model can be bound,\n\t  otherwise the scope might behave unexpectedly.\n\t  Mainly used to define the controller as the view model,\n\t  and very useful when wanting to use Angular's `controllerAs` syntax.\n\t */\n\t.factory(ViewModel, [_utils.utils, _mixer.Mixer, function ($$utils, $Mixer) {\n\t  function $$ViewModel() {}\n\t\n\t  // Gets an object, wraps it with scope functions and returns it\n\t  $$ViewModel.viewModel = function (vm) {\n\t    if (!_underscore2.default.isObject(vm)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    // Extend view model with mixin functions\n\t    $Mixer._extend(vm, {\n\t      pattern: /^(?!\\$\\$).*$/, // Omitting methods which start with a $$ notation\n\t      context: this // Binding methods to scope\n\t    });\n\t\n\t    // Apply mixin constructors on scope with view model\n\t    $Mixer._construct(this, vm);\n\t    return vm;\n\t  };\n\t\n\t  return $$ViewModel;\n\t}])\n\t\n\t/*\n\t  Illustrates the old API where a view model is created using $reactive service\n\t */\n\t.service(reactive, [_utils.utils, function ($$utils) {\n\t  var Reactive = function () {\n\t    function Reactive(vm) {\n\t      var _this = this;\n\t\n\t      _classCallCheck(this, Reactive);\n\t\n\t      if (!_underscore2.default.isObject(vm)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\t\n\t      _underscore2.default.defer(function () {\n\t        if (!_this._attached) {\n\t          console.warn('view model was not attached to any scope');\n\t        }\n\t      });\n\t\n\t      this._vm = vm;\n\t    }\n\t\n\t    _createClass(Reactive, [{\n\t      key: 'attach',\n\t      value: function attach(scope) {\n\t        this._attached = true;\n\t\n\t        if (!$$utils.isScope(scope)) {\n\t          throw Error('argument 1 must be a scope');\n\t        }\n\t\n\t        var viewModel = scope.viewModel(this._vm);\n\t\n\t        // Similar to the old/Meteor API\n\t        viewModel.call = viewModel.callMethod;\n\t        viewModel.apply = viewModel.applyMethod;\n\t\n\t        return viewModel;\n\t      }\n\t    }]);\n\t\n\t    return Reactive;\n\t  }();\n\t\n\t  return function (vm) {\n\t    return new Reactive(vm);\n\t  };\n\t}]);\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Reactive = exports.name = undefined;\n\t\n\tvar _jsondiffpatch = __webpack_require__(22);\n\t\n\tvar _jsondiffpatch2 = _interopRequireDefault(_jsondiffpatch);\n\t\n\tvar _underscore = __webpack_require__(2);\n\t\n\tvar _underscore2 = _interopRequireDefault(_underscore);\n\t\n\tvar _utils = __webpack_require__(16);\n\t\n\tvar _mixer = __webpack_require__(17);\n\t\n\tvar _core = __webpack_require__(19);\n\t\n\tvar _viewModel = __webpack_require__(20);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar name = exports.name = 'angular-meteor.reactive';\n\tvar Reactive = exports.Reactive = '$$Reactive';\n\t\n\tangular.module(name, [_utils.name, _mixer.name, _core.name, _viewModel.name])\n\t\n\t/*\n\t  A mixin which enhance our reactive abilities by providing methods\n\t  that are capable of updating our scope reactively.\n\t */\n\t.factory(Reactive, ['$parse', _utils.utils, _mixer.Mixer, function ($parse, $$utils, $Mixer) {\n\t  function $$Reactive() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // Helps us track changes made in the view model\n\t    vm.$$dependencies = {};\n\t  }\n\t\n\t  // Gets an object containing functions and define their results as reactive properties.\n\t  // Once a return value has been changed the property will be reset.\n\t  $$Reactive.helpers = function (vm, props) {\n\t    var _this = this;\n\t\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (!_underscore2.default.isObject(props)) {\n\t        throw Error('argument 2 must be an object');\n\t      }\n\t    } else {\n\t      props = vm;\n\t      vm = $Mixer.caller;\n\t\n\t      if (!_underscore2.default.isObject(props)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\t    }\n\t\n\t    _underscore2.default.each(props, function (v, k) {\n\t      if (!_underscore2.default.isFunction(v)) {\n\t        throw Error('helper \\'' + k + '\\' must be a function');\n\t      }\n\t    });\n\t\n\t    _underscore2.default.each(props, function (v, k) {\n\t      if (!vm.$$dependencies[k]) {\n\t        // Registers a new dependency to the specified helper\n\t        vm.$$dependencies[k] = new Tracker.Dependency();\n\t      }\n\t\n\t      _this.$$setFnHelper(vm, k, v);\n\t    });\n\t  };\n\t\n\t  // Gets a model reactively\n\t  $$Reactive.getReactively = function (vm, k, isDeep) {\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (angular.isUndefined(isDeep)) isDeep = false;\n\t\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 2 must be a string');\n\t      }\n\t      if (!_underscore2.default.isBoolean(isDeep)) {\n\t        throw Error('argument 3 must be a boolean');\n\t      }\n\t    } else {\n\t      isDeep = angular.isDefined(k) ? k : false;\n\t      k = vm;\n\t      vm = $Mixer.caller;\n\t\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 1 must be a string');\n\t      }\n\t      if (!_underscore2.default.isBoolean(isDeep)) {\n\t        throw Error('argument 2 must be a boolean');\n\t      }\n\t    }\n\t\n\t    return this.$$reactivateEntity(vm, k, this.$watch, isDeep);\n\t  };\n\t\n\t  // Gets a collection reactively\n\t  $$Reactive.getCollectionReactively = function (vm, k) {\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 2 must be a string');\n\t      }\n\t    } else {\n\t      k = vm;\n\t      vm = $Mixer.caller;\n\t\n\t      if (!_underscore2.default.isString(k)) {\n\t        throw Error('argument 1 must be a string');\n\t      }\n\t    }\n\t\n\t    return this.$$reactivateEntity(vm, k, this.$watchCollection);\n\t  };\n\t\n\t  // Gets an entity reactively, and once it has been changed the computation will be recomputed\n\t  $$Reactive.$$reactivateEntity = function (vm, k, watcher) {\n\t    if (!vm.$$dependencies[k]) {\n\t      vm.$$dependencies[k] = new Tracker.Dependency();\n\t\n\t      for (var _len = arguments.length, watcherArgs = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n\t        watcherArgs[_key - 3] = arguments[_key];\n\t      }\n\t\n\t      this.$$watchEntity.apply(this, [vm, k, watcher].concat(watcherArgs));\n\t    }\n\t\n\t    vm.$$dependencies[k].depend();\n\t    return $parse(k)(vm);\n\t  };\n\t\n\t  // Watches for changes in the view model, and if so will notify a change\n\t  $$Reactive.$$watchEntity = function (vm, k, watcher) {\n\t    var _this2 = this;\n\t\n\t    // Gets a deep property from the caller\n\t    var getVal = _underscore2.default.partial($parse(k), vm);\n\t    var initialVal = getVal();\n\t\n\t    // Watches for changes in the view model\n\t\n\t    for (var _len2 = arguments.length, watcherArgs = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t      watcherArgs[_key2 - 3] = arguments[_key2];\n\t    }\n\t\n\t    watcher.call.apply(watcher, [this, getVal, function (val, oldVal) {\n\t      var hasChanged = val !== initialVal || val !== oldVal;\n\t\n\t      // Notify if a change has been detected\n\t      if (hasChanged) _this2.$$changed(vm, k);\n\t    }].concat(watcherArgs));\n\t  };\n\t\n\t  // Invokes a function and sets the return value as a property\n\t  $$Reactive.$$setFnHelper = function (vm, k, fn) {\n\t    var _this3 = this;\n\t\n\t    var activeObservation = null;\n\t    var lastModel = null;\n\t    var lastModelData = [];\n\t\n\t    this.autorun(function () /* computation */{\n\t      // Invokes the reactive functon\n\t      var model = fn.apply(vm);\n\t\n\t      // Ignore notifications made by the following handler\n\t      Tracker.nonreactive(function () {\n\t        // If a cursor, observe its changes and update acoordingly\n\t        if ($$utils.isCursor(model)) {\n\t          var modelData = undefined;\n\t\n\t          if (angular.isUndefined(vm[k])) {\n\t            _this3.$$setValHelper(vm, k, [], false);\n\t          }\n\t\n\t          if (activeObservation) {\n\t            lastModelData = lastModel.fetch();\n\t            activeObservation.stop();\n\t            activeObservation = null;\n\t          }\n\t\n\t          var handle = _this3.$$handleCursor(vm, k, model);\n\t\n\t          activeObservation = handle.observation;\n\t          modelData = handle.data;\n\t\n\t          if (lastModelData.length !== 0) {\n\t            var diff = _jsondiffpatch2.default.diff(lastModelData, modelData);\n\t            vm[k] = _jsondiffpatch2.default.patch(lastModelData, diff);\n\t          } else {\n\t            vm[k] = modelData;\n\t          }\n\t\n\t          lastModel = model;\n\t          lastModelData = modelData;\n\t\n\t          /* computation.onInvalidate(() => {\n\t            activeObservation.stop();\n\t          });*/\n\t        } else {\n\t            _this3.$$handleNonCursor(vm, k, model);\n\t          }\n\t\n\t        // Notify change and update the view model\n\t        _this3.$$changed(vm, k);\n\t      });\n\t    });\n\t  };\n\t\n\t  // Sets a value helper as a setter and a getter which will notify computations once used\n\t  $$Reactive.$$setValHelper = function (vm, k, v) {\n\t    var _this4 = this;\n\t\n\t    var watch = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\t\n\t    // If set, reactives property\n\t    if (watch) {\n\t      var isDeep = _underscore2.default.isObject(v);\n\t      this.getReactively(vm, k, isDeep);\n\t    }\n\t\n\t    Object.defineProperty(vm, k, {\n\t      configurable: true,\n\t      enumerable: true,\n\t\n\t      get: function get() {\n\t        return v;\n\t      },\n\t      set: function set(newVal) {\n\t        v = newVal;\n\t        _this4.$$changed(vm, k);\n\t      }\n\t    });\n\t  };\n\t\n\t  // Fetching a cursor and updates properties once the result set has been changed\n\t  $$Reactive.$$handleCursor = function (vm, k, cursor) {\n\t    var _this5 = this;\n\t\n\t    var data = [];\n\t    // Observe changes made in the result set\n\t    var observation = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        if (!observation) {\n\t          data.push(doc);\n\t          return;\n\t        }\n\t        vm[k].splice(atIndex, 0, doc);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        var diff = _jsondiffpatch2.default.diff(vm[k][atIndex], doc);\n\t        _jsondiffpatch2.default.patch(vm[k][atIndex], diff);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        vm[k].splice(fromIndex, 1);\n\t        vm[k].splice(toIndex, 0, doc);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      removedAt: function removedAt(oldDoc, atIndex) {\n\t        vm[k].splice(atIndex, 1);\n\t        _this5.$$changed(vm, k);\n\t      }\n\t    });\n\t\n\t    return {\n\t      observation: observation,\n\t      data: data\n\t    };\n\t  };\n\t\n\t  $$Reactive.$$handleNonCursor = function (vm, k, data) {\n\t    var v = vm[k];\n\t\n\t    if (angular.isDefined(v)) {\n\t      delete vm[k];\n\t      v = null;\n\t    }\n\t\n\t    if (angular.isUndefined(v)) {\n\t      this.$$setValHelper(vm, k, data);\n\t    }\n\t    // Update property if the new value is from the same type\n\t    else if ($$utils.areSiblings(v, data)) {\n\t        var diff = _jsondiffpatch2.default.diff(v, data);\n\t        _jsondiffpatch2.default.patch(v, diff);\n\t        this.$$changed(vm, k);\n\t      } else {\n\t        vm[k] = data;\n\t      }\n\t  };\n\t\n\t  // Notifies dependency in view model\n\t  $$Reactive.$$depend = function (vm, k) {\n\t    vm.$$dependencies[k].depend();\n\t  };\n\t\n\t  // Notifies change in view model\n\t  $$Reactive.$$changed = function (vm, k) {\n\t    this.$$throttledDigest();\n\t    vm.$$dependencies[k].changed();\n\t  };\n\t\n\t  return $$Reactive;\n\t}]);\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar name = exports.name = 'angular-templates';\n\t\n\ttry {\n\t  angular.module(name);\n\t} catch (e) {\n\t  angular.module(name, []);\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-meteor.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 92defbad9aebff27e73c\n **/","// lib\nimport './lib/get-updates';\nimport './lib/diff-array';\n// legacy\nimport './modules/angular-meteor-settings';\nimport './modules/angular-meteor-ironrouter';\nimport './modules/angular-meteor-utils';\nimport './modules/angular-meteor-subscribe';\nimport './modules/angular-meteor-collection';\nimport './modules/angular-meteor-object';\nimport './modules/angular-meteor-user';\nimport './modules/angular-meteor-methods';\nimport './modules/angular-meteor-session';\nimport './modules/angular-meteor-camera';\nimport './modules/angular-meteor-stopper';\n\n// new\nimport { name as utilsName } from './modules/utils';\nimport { name as mixerName, Mixer } from './modules/mixer';\nimport { name as scopeName } from './modules/scope';\nimport { name as coreName, Core } from './modules/core';\nimport { name as viewModelName, ViewModel } from './modules/view-model';\nimport { name as reactiveName, Reactive } from './modules/reactive';\nimport { name as templatesName } from './modules/templates';\n\nconst name = 'angular-meteor';\nexport default name;\n\nangular.module(name, [\n  // new\n  utilsName,\n  mixerName,\n  scopeName,\n  coreName,\n  viewModelName,\n  reactiveName,\n  templatesName,\n\n  // legacy\n  'angular-meteor.ironrouter',\n  'angular-meteor.utils',\n  'angular-meteor.subscribe',\n  'angular-meteor.collection',\n  'angular-meteor.object',\n  'angular-meteor.user',\n  'angular-meteor.methods',\n  'angular-meteor.session',\n  'angular-meteor.camera'\n\n])\n\n.run([\n  Mixer,\n  Core,\n  ViewModel,\n  Reactive,\n\n  function($Mixer, $$Core, $$ViewModel, $$Reactive) {\n    // Load all mixins\n    $Mixer\n      .mixin($$Core)\n      .mixin($$ViewModel)\n      .mixin($$Reactive);\n  }\n])\n\n// legacy\n// Putting all services under $meteor service for syntactic sugar\n.service('$meteor', [\n  '$meteorCollection',\n  '$meteorCollectionFS',\n  '$meteorObject',\n  '$meteorMethods',\n  '$meteorSession',\n  '$meteorSubscribe',\n  '$meteorUtils',\n  '$meteorCamera',\n  '$meteorUser',\n  function($meteorCollection, $meteorCollectionFS, $meteorObject,\n    $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils,\n    $meteorCamera, $meteorUser) {\n    this.collection = $meteorCollection;\n    this.collectionFS = $meteorCollectionFS;\n    this.object = $meteorObject;\n    this.subscribe = $meteorSubscribe.subscribe;\n    this.call = $meteorMethods.call;\n    this.session = $meteorSession;\n    this.autorun = $meteorUtils.autorun;\n    this.getCollectionByName = $meteorUtils.getCollectionByName;\n    this.getPicture = $meteorCamera.getPicture;\n\n    // $meteorUser\n    [\n      'loginWithPassword',\n      'requireUser',\n      'requireValidUser',\n      'waitForUser',\n      'createUser',\n      'changePassword',\n      'forgotPassword',\n      'resetPassword',\n      'verifyEmail',\n      'loginWithMeteorDeveloperAccount',\n      'loginWithFacebook',\n      'loginWithGithub',\n      'loginWithGoogle',\n      'loginWithMeetup',\n      'loginWithTwitter',\n      'loginWithWeibo',\n      'logout',\n      'logoutOtherClients'\n    ].forEach((method) => {\n      this[method] = $meteorUser[method];\n    });\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/angular-meteor.js\n **/","/*global\n angular, _\n */\n\nimport _ from './underscore';\n\n'use strict';\n\n// https://github.com/DAB0mB/get-updates\n(function() {\n  var module = angular.module('getUpdates', []);\n\n  var utils = (function() {\n    var rip = function(obj, level) {\n      if (level < 1) return {};\n\n      return _.reduce(obj, function(clone, v, k) {\n        v = _.isObject(v) ? rip(v, --level) : v;\n        clone[k] = v;\n        return clone;\n      }, {});\n    };\n\n    var toPaths = function(obj) {\n      var keys = getKeyPaths(obj);\n      var values = getDeepValues(obj);\n      return _.object(keys, values);\n    };\n\n    var getKeyPaths = function(obj) {\n      var keys = _.keys(obj).map(function(k) {\n        var v = obj[k];\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\n\n        return getKeyPaths(v).map(function(subKey) {\n          return k + '.' + subKey;\n        });\n      });\n\n      return _.flatten(keys);\n    };\n\n    var getDeepValues = function(obj,arr) {\n      arr = arr || [];\n\n      _.values(obj).forEach(function(v) {\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v))\n          arr.push(v);\n        else\n          getDeepValues(v, arr);\n      });\n\n      return arr;\n    };\n\n    var flatten = function(arr) {\n      return arr.reduce(function(flattened, v, i) {\n        if (_.isArray(v) && !_.isEmpty(v))\n          flattened.push.apply(flattened, flatten(v));\n        else\n          flattened.push(v);\n\n        return flattened;\n      }, []);\n    };\n\n    var setFilled = function(obj, k, v) {\n      if (!_.isEmpty(v)) obj[k] = v;\n    };\n\n    var assert = function(result, msg) {\n      if (!result) throwErr(msg);\n    };\n\n    var throwErr = function(msg) {\n      throw Error('get-updates error - ' + msg);\n    };\n\n    return {\n      rip: rip,\n      toPaths: toPaths,\n      getKeyPaths: getKeyPaths,\n      getDeepValues: getDeepValues,\n      setFilled: setFilled,\n      assert: assert,\n      throwErr: throwErr\n    };\n  })();\n\n  var getDifference = (function() {\n    var getDifference = function(src, dst, isShallow) {\n      var level;\n\n      if (isShallow > 1)\n        level = isShallow;\n      else if (isShallow)\n        level = 1;\n\n      if (level) {\n        src = utils.rip(src, level);\n        dst = utils.rip(dst, level);\n      }\n\n      return compare(src, dst);\n    };\n\n    var compare = function(src, dst) {\n      var srcKeys = _.keys(src);\n      var dstKeys = _.keys(dst);\n\n      var keys = _.chain([])\n        .concat(srcKeys)\n        .concat(dstKeys)\n        .uniq()\n        .without('$$hashKey')\n        .value();\n\n      return keys.reduce(function(diff, k) {\n        var srcValue = src[k];\n        var dstValue = dst[k];\n\n        if (_.isDate(srcValue) && _.isDate(dstValue)) {\n          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n        }\n\n        if (_.isObject(srcValue) && _.isObject(dstValue)) {\n          var valueDiff = getDifference(srcValue, dstValue);\n          utils.setFilled(diff, k, valueDiff);\n        }\n\n        else if (srcValue !== dstValue) {\n          diff[k] = dstValue;\n        }\n\n        return diff;\n      }, {});\n    };\n\n    return getDifference;\n  })();\n\n  var getUpdates = (function() {\n    var getUpdates = function(src, dst, isShallow) {\n      utils.assert(_.isObject(src), 'first argument must be an object');\n      utils.assert(_.isObject(dst), 'second argument must be an object');\n\n      var diff = getDifference(src, dst, isShallow);\n      var paths = utils.toPaths(diff);\n\n      var set = createSet(paths);\n      var unset = createUnset(paths);\n      var pull = createPull(unset);\n\n      var updates = {};\n      utils.setFilled(updates, '$set', set);\n      utils.setFilled(updates, '$unset', unset);\n      utils.setFilled(updates, '$pull', pull);\n\n      return updates;\n    };\n\n    var createSet = function(paths) {\n      var undefinedKeys = getUndefinedKeys(paths);\n      return _.omit(paths, undefinedKeys);\n    };\n\n    var createUnset = function(paths) {\n      var undefinedKeys = getUndefinedKeys(paths);\n      var unset = _.pick(paths, undefinedKeys);\n\n      return _.reduce(unset, function(result, v, k) {\n        result[k] = true;\n        return result;\n      }, {});\n    };\n\n    var createPull = function(unset) {\n      var arrKeyPaths = _.keys(unset).map(function(k) {\n        var split = k.match(/(.*)\\.\\d+$/);\n        return split && split[1];\n      });\n\n      return _.compact(arrKeyPaths).reduce(function(pull, k) {\n        pull[k] = null;\n        return pull;\n      }, {});\n    };\n\n    var getUndefinedKeys = function(obj) {\n      return _.keys(obj).filter(function (k) {\n        var v = obj[k];\n        return _.isUndefined(v);\n      });\n    };\n\n    return getUpdates;\n  })();\n\n  module.value('getUpdates', getUpdates);\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/get-updates.js\n **/","import _ from 'underscore';\n\nif (typeof _ === 'undefined') {\n  if (typeof Package.underscore === 'undefined') {\n    throw new Error('underscore is missing');\n  }\n}\n\nexport default _ || Package.underscore._;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/underscore.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"_\",\"amd\":\"underscore\",\"commonjs2\":\"underscore\",\"commonjs\":\"underscore\"}\n ** module id = 3\n ** module chunks = 0\n **/","/*global\n angular, _, Package\n */\n\nimport _ from './underscore';\n\n'use strict';\n\nvar _module = angular.module('diffArray', ['getUpdates']);\n\n_module.factory('diffArray', ['getUpdates',\n  function(getUpdates) {\n    var LocalCollection = Package.minimongo.LocalCollection;\n    var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n    var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\n    // Calculates the differences between `lastSeqArray` and\n    // `seqArray` and calls appropriate functions from `callbacks`.\n    // Reuses Minimongo's diff algorithm implementation.\n    // XXX Should be replaced with the original diffArray function here:\n    // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n    // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n    function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n      preventNestedDiff = !!preventNestedDiff;\n\n      var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges ||\n        Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\n      var oldObjIds = [];\n      var newObjIds = [];\n      var posOld = {}; // maps from idStringify'd ids\n      var posNew = {}; // ditto\n      var posCur = {};\n      var lengthCur = lastSeqArray.length;\n\n      _.each(seqArray, function (doc, i) {\n        newObjIds.push({_id: doc._id});\n        posNew[idStringify(doc._id)] = i;\n      });\n\n      _.each(lastSeqArray, function (doc, i) {\n        oldObjIds.push({_id: doc._id});\n        posOld[idStringify(doc._id)] = i;\n        posCur[idStringify(doc._id)] = i;\n      });\n\n      // Arrays can contain arbitrary objects. We don't diff the\n      // objects. Instead we always fire 'changedAt' callback on every\n      // object. The consumer of `observe-sequence` should deal with\n      // it appropriately.\n      diffFn(oldObjIds, newObjIds, {\n        addedBefore: function (id, doc, before) {\n          var position = before ? posCur[idStringify(before)] : lengthCur;\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= position) posCur[id]++;\n          });\n\n          lengthCur++;\n          posCur[idStringify(id)] = position;\n\n          callbacks.addedAt(\n            id,\n            seqArray[posNew[idStringify(id)]],\n            position,\n            before\n          );\n        },\n\n        movedBefore: function (id, before) {\n          var prevPosition = posCur[idStringify(id)];\n          var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= prevPosition && pos <= position)\n              posCur[id]--;\n            else if (pos <= prevPosition && pos >= position)\n              posCur[id]++;\n          });\n\n          posCur[idStringify(id)] = position;\n\n          callbacks.movedTo(\n            id,\n            seqArray[posNew[idStringify(id)]],\n            prevPosition,\n            position,\n            before\n          );\n        },\n        removed: function (id) {\n          var prevPosition = posCur[idStringify(id)];\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= prevPosition) posCur[id]--;\n          });\n\n          delete posCur[idStringify(id)];\n          lengthCur--;\n\n          callbacks.removedAt(\n            id,\n            lastSeqArray[posOld[idStringify(id)]],\n            prevPosition\n          );\n        }\n      });\n\n      _.each(posNew, function (pos, idString) {\n        if (!_.has(posOld, idString)) return;\n\n        var id = idParse(idString);\n        var newItem = seqArray[pos] || {};\n        var oldItem = lastSeqArray[posOld[idString]];\n        var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n\n        if (!_.isEmpty(updates))\n          callbacks.changedAt(id, updates, pos, oldItem);\n      });\n    }\n\n    diffArray.shallow = function(lastSeqArray, seqArray, callbacks) {\n      return diffArray(lastSeqArray, seqArray, callbacks, true);\n    };\n\n    diffArray.deepCopyChanges = function (oldItem, newItem) {\n      var setDiff = getUpdates(oldItem, newItem).$set;\n\n      _.each(setDiff, function(v, deepKey) {\n        setDeep(oldItem, deepKey, v);\n      });\n    };\n\n    diffArray.deepCopyRemovals = function (oldItem, newItem) {\n      var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\n      _.each(unsetDiff, function(v, deepKey) {\n        unsetDeep(oldItem, deepKey);\n      });\n    };\n\n    // Finds changes between two collections\n    diffArray.getChanges = function(newCollection, oldCollection, diffMethod) {\n      var changes = {added: [], removed: [], changed: []};\n\n      diffMethod(oldCollection, newCollection, {\n        addedAt: function(id, item, index) {\n          changes.added.push({item: item, index: index});\n        },\n\n        removedAt: function(id, item, index) {\n          changes.removed.push({item: item, index: index});\n        },\n\n        changedAt: function(id, updates, index, oldItem) {\n          changes.changed.push({selector: id, modifier: updates});\n        },\n\n        movedTo: function(id, item, fromIndex, toIndex) {\n          // XXX do we need this?\n        }\n      });\n\n      return changes;\n    };\n\n    var setDeep = function(obj, deepKey, v) {\n      var split = deepKey.split('.');\n      var initialKeys = _.initial(split);\n      var lastKey = _.last(split);\n\n      initialKeys.reduce(function(subObj, k, i) {\n        var nextKey = split[i + 1];\n\n        if (isNumStr(nextKey)) {\n          if (subObj[k] === null) subObj[k] = [];\n          if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n        }\n\n        else if (subObj[k] === null || !isHash(subObj[k])) {\n          subObj[k] = {};\n        }\n\n        return subObj[k];\n      }, obj);\n\n      var deepObj = getDeep(obj, initialKeys);\n      deepObj[lastKey] = v;\n      return v;\n    };\n\n    var unsetDeep = function(obj, deepKey) {\n      var split = deepKey.split('.');\n      var initialKeys = _.initial(split);\n      var lastKey = _.last(split);\n      var deepObj = getDeep(obj, initialKeys);\n\n      if (_.isArray(deepObj) && isNumStr(lastKey))\n        return !!deepObj.splice(lastKey, 1);\n      else\n        return delete deepObj[lastKey];\n    };\n\n    var getDeep = function(obj, keys) {\n      return keys.reduce(function(subObj, k) {\n        return subObj[k];\n      }, obj);\n    };\n\n    var isHash = function(obj) {\n      return _.isObject(obj) &&\n             Object.getPrototypeOf(obj) === Object.prototype;\n    };\n\n    var isNumStr = function(str) {\n      return str.match(/^\\d+$/);\n    };\n\n    return diffArray;\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/diff-array.js\n **/","angular.module('angular-meteor.settings', [])\n  .constant('$angularMeteorSettings', {\n    suppressWarnings: true\n  });\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-settings.js\n **/","angular.module('angular-meteor.ironrouter', [])\n\n\n.run([\n  '$compile',\n  '$document',\n  '$rootScope',\n\nfunction ($compile, $document, $rootScope) {\n  const Router = (Package['iron:router'] || {}).Router;\n  if (!Router) return;\n\n  let isLoaded = false;\n\n  // Recompile after iron:router builds page\n  Router.onAfterAction((req, res, next) => {\n    Tracker.afterFlush(() => {\n      if (isLoaded) return;\n      $compile($document)($rootScope);\n      if (!$rootScope.$$phase) $rootScope.$apply();\n      isLoaded = true;\n    });\n  });\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-ironrouter.js\n **/","/*global\n angular, _, Tracker, EJSON, FS, Mongo\n */\n\nimport _ from '../lib/underscore';\n\n'use strict';\n\nvar angularMeteorUtils = angular.module('angular-meteor.utils', ['angular-meteor.settings']);\n\nangularMeteorUtils.service('$meteorUtils', [\n  '$q', '$timeout', '$angularMeteorSettings',\n  function ($q, $timeout, $angularMeteorSettings) {\n\n    var self = this;\n\n    this.autorun = function(scope, fn) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\n      // wrapping around Deps.autorun\n      var comp = Tracker.autorun(function(c) {\n        fn(c);\n        // this is run immediately for the first call\n        // but after that, we need to $apply to start Angular digest\n        if (!c.firstRun) $timeout(angular.noop, 0);\n      });\n\n      // stop autorun when scope is destroyed\n      scope.$on('$destroy', function() {\n        comp.stop();\n      });\n\n      // return autorun object so that it can be stopped manually\n      return comp;\n    };\n\n    // Borrowed from angularFire\n    // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n    this.stripDollarPrefixedKeys = function (data) {\n      if (!_.isObject(data) ||\n          data instanceof Date ||\n          data instanceof File ||\n          EJSON.toJSONValue(data).$type === 'oid' ||\n          (typeof FS === 'object' && data instanceof FS.File))\n        return data;\n\n      var out = _.isArray(data) ? [] : {};\n\n      _.each(data, function(v,k) {\n        if(typeof k !== 'string' || k.charAt(0) !== '$')\n          out[k] = self.stripDollarPrefixedKeys(v);\n      });\n\n      return out;\n    };\n\n    // Returns a callback which fulfills promise\n    this.fulfill = function(deferred, boundError, boundResult) {\n      return function(err, result) {\n        if (err)\n          deferred.reject(boundError == null ? err : boundError);\n        else if (typeof boundResult == \"function\")\n          deferred.resolve(boundResult == null ? result : boundResult(result));\n        else\n          deferred.resolve(boundResult == null ? result : boundResult);\n      };\n    };\n\n    // creates a function which invokes method with the given arguments and returns a promise\n    this.promissor = function(obj, method) {\n      return function() {\n        var deferred = $q.defer();\n        var fulfill = self.fulfill(deferred);\n        var args = _.toArray(arguments).concat(fulfill);\n        obj[method].apply(obj, args);\n        return deferred.promise;\n      };\n    };\n\n    // creates a $q.all() promise and call digestion loop on fulfillment\n    this.promiseAll = function(promises) {\n      var allPromise = $q.all(promises);\n\n      allPromise.finally(function() {\n        // calls digestion loop with no conflicts\n        $timeout(angular.noop);\n      });\n\n      return allPromise;\n    };\n\n    this.getCollectionByName = function(string){\n      return Mongo.Collection.get(string);\n    };\n\n    this.findIndexById = function(collection, doc) {\n      var foundDoc = _.find(collection, function(colDoc) {\n        // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n        return EJSON.equals(colDoc._id, doc._id);\n      });\n\n      return _.indexOf(collection, foundDoc);\n    };\n  }\n]);\n\nangularMeteorUtils.run([\n  '$rootScope', '$meteorUtils',\n  function($rootScope, $meteorUtils) {\n    Object.getPrototypeOf($rootScope).$meteorAutorun = function(fn) {\n      return $meteorUtils.autorun(this, fn);\n    };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-utils.js\n **/","/*global\n angular, Meteor\n */\n\n'use strict';\nvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', ['angular-meteor.settings']);\n\nangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings',\n  function ($q, $angularMeteorSettings) {\n\n    var self = this;\n\n    this._subscribe = function(scope, deferred, args) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var subscription = null;\n      var lastArg = args[args.length - 1];\n\n      // User supplied onStop callback\n      // save it for later use and remove\n      // from subscription arguments\n      if (angular.isObject(lastArg) &&\n          angular.isFunction(lastArg.onStop)) {\n        var onStop = lastArg.onStop;\n\n        args.pop();\n      }\n\n      args.push({\n        onReady: function() {\n          deferred.resolve(subscription);\n        },\n        onStop: function(err) {\n          if (!deferred.promise.$$state.status) {\n            if (err)\n              deferred.reject(err);\n            else\n              deferred.reject(new Meteor.Error(\"Subscription Stopped\",\n                \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n          } else if (onStop)\n            // After promise was resolved or rejected\n            // call user supplied onStop callback.\n            onStop.apply(this, Array.prototype.slice.call(arguments));\n\n        }\n      });\n\n      subscription =  Meteor.subscribe.apply(scope, args);\n\n      return subscription;\n    };\n\n    this.subscribe = function(){\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n      var subscription = null;\n\n      self._subscribe(this, deferred, args);\n\n      return deferred.promise;\n    };\n  }]);\n\nangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe',\n  function($rootScope, $q, $meteorSubscribe) {\n    Object.getPrototypeOf($rootScope).$meteorSubscribe = function() {\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n\n      var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\n      this.$on('$destroy', function() {\n        subscription.stop();\n      });\n\n      return deferred.promise;\n    };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-subscribe.js\n **/","/*global\n angular, _, Tracker, check, Match, Mongo\n */\n\nimport _ from '../lib/underscore';\n\n'use strict';\n\nvar angularMeteorCollection = angular.module('angular-meteor.collection',\n  ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray', 'angular-meteor.settings']);\n\n// The reason angular meteor collection is a factory function and not something\n// that inherit from array comes from here:\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n// We went with the direct extensions approach.\nangularMeteorCollection.factory('AngularMeteorCollection', [\n  '$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings',\n  function($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\n\n    function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var data = [];\n      // Server backup data to evaluate what changes come from client\n      // after each server update.\n      data._serverBackup = [];\n      // Array differ function.\n      data._diffArrayFunc = diffArrayFunc;\n      // Handler of the cursor observer.\n      data._hObserve = null;\n      // On new cursor autorun handler\n      // (autorun for reactive variables).\n      data._hNewCurAutorun = null;\n      // On new data autorun handler\n      // (autorun for cursor.fetch).\n      data._hDataAutorun = null;\n\n      if (angular.isDefined(collection)) {\n        data.$$collection = collection;\n      } else {\n        var cursor = curDefFunc();\n        data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n      }\n\n      _.extend(data, AngularMeteorCollection);\n      data._startCurAutorun(curDefFunc, autoClientSave);\n\n      return data;\n    }\n\n    AngularMeteorCollection._startCurAutorun = function(curDefFunc, autoClientSave) {\n      var self = this;\n\n      self._hNewCurAutorun = Tracker.autorun(function() {\n        // When the reactive func gets recomputated we need to stop any previous\n        // observeChanges.\n        Tracker.onInvalidate(function() {\n          self._stopCursor();\n        });\n\n        if (autoClientSave) self._setAutoClientSave();\n        self._updateCursor(curDefFunc(), autoClientSave);\n      });\n    };\n\n    AngularMeteorCollection.subscribe = function() {\n      $meteorSubscribe.subscribe.apply(this, arguments);\n      return this;\n    };\n\n    AngularMeteorCollection.save = function(docs, useUnsetModifier) {\n      // save whole collection\n      if (!docs) docs = this;\n      // save single doc\n      docs = [].concat(docs);\n\n      var promises = docs.map(function(doc) {\n        return this._upsertDoc(doc, useUnsetModifier);\n      }, this);\n\n      return $meteorUtils.promiseAll(promises);\n    };\n\n    AngularMeteorCollection._upsertDoc = function(doc, useUnsetModifier) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\n      // delete $$hashkey\n      doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n      var docId = doc._id;\n      var isExist = collection.findOne(docId);\n\n      // update\n      if (isExist) {\n        // Deletes _id property (from the copy) so that\n        // it can be $set using update.\n        delete doc._id;\n        var modifier = useUnsetModifier ? {$unset: doc} : {$set: doc};\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\n        collection.update(docId, modifier, createFulfill(function() {\n          return {_id: docId, action: 'updated'};\n        }));\n      }\n      // insert\n      else {\n        collection.insert(doc, createFulfill(function(id) {\n          return {_id: id, action: 'inserted'};\n        }));\n      }\n\n      return deferred.promise;\n    };\n\n    // performs $pull operations parallely.\n    // used for handling splice operations returned from getUpdates() to prevent conflicts.\n    // see issue: https://github.com/Urigo/angular-meteor/issues/793\n    AngularMeteorCollection._updateDiff = function(selector, update, callback) {\n      callback = callback || angular.noop;\n      var setters = _.omit(update, '$pull');\n      var updates = [setters];\n\n      _.each(update.$pull, function(pull, prop) {\n        var puller = {};\n        puller[prop] = pull;\n        updates.push({ $pull: puller });\n      });\n\n      this._updateParallel(selector, updates, callback);\n    };\n\n    // performs each update operation parallely\n    AngularMeteorCollection._updateParallel = function(selector, updates, callback) {\n      var self = this;\n      var done = _.after(updates.length, callback);\n\n      var next = function(err, affectedDocsNum) {\n        if (err) return callback(err);\n        done(null, affectedDocsNum);\n      };\n\n      _.each(updates, function(update) {\n        self.$$collection.update(selector, update, next);\n      });\n    };\n\n    AngularMeteorCollection.remove = function(keyOrDocs) {\n      var keys;\n\n      // remove whole collection\n      if (!keyOrDocs) {\n        keys = _.pluck(this, '_id');\n      }\n      // remove docs\n      else {\n        keyOrDocs = [].concat(keyOrDocs);\n\n        keys = _.map(keyOrDocs, function(keyOrDoc) {\n          return keyOrDoc._id || keyOrDoc;\n        });\n      }\n\n      // Checks if all keys are correct.\n      check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\n      var promises = keys.map(function(key) {\n        return this._removeDoc(key);\n      }, this);\n\n      return $meteorUtils.promiseAll(promises);\n    };\n\n    AngularMeteorCollection._removeDoc = function(id) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n      collection.remove(id, fulfill);\n      return deferred.promise;\n    };\n\n    AngularMeteorCollection._updateCursor = function(cursor, autoClientSave) {\n      var self = this;\n      // XXX - consider adding an option for a non-orderd result for faster performance\n      if (self._hObserve) self._stopObserving();\n\n\n      self._hObserve = cursor.observe({\n        addedAt: function(doc, atIndex) {\n          self.splice(atIndex, 0, doc);\n          self._serverBackup.splice(atIndex, 0, doc);\n          self._setServerUpdateMode();\n        },\n\n        changedAt: function(doc, oldDoc, atIndex) {\n          diffArray.deepCopyChanges(self[atIndex], doc);\n          diffArray.deepCopyRemovals(self[atIndex], doc);\n          self._serverBackup[atIndex] = self[atIndex];\n          self._setServerUpdateMode();\n        },\n\n        movedTo: function(doc, fromIndex, toIndex) {\n          self.splice(fromIndex, 1);\n          self.splice(toIndex, 0, doc);\n          self._serverBackup.splice(fromIndex, 1);\n          self._serverBackup.splice(toIndex, 0, doc);\n          self._setServerUpdateMode();\n        },\n\n        removedAt: function(oldDoc) {\n          var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\n\n          if (removedIndex != -1) {\n            self.splice(removedIndex, 1);\n            self._serverBackup.splice(removedIndex, 1);\n            self._setServerUpdateMode();\n          } else {\n            // If it's been removed on client then it's already not in collection\n            // itself but still is in the _serverBackup.\n            removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\n\n            if (removedIndex != -1) {\n              self._serverBackup.splice(removedIndex, 1);\n            }\n          }\n        }\n      });\n\n      self._hDataAutorun = Tracker.autorun(function() {\n        cursor.fetch();\n        if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\n      });\n    };\n\n    AngularMeteorCollection._stopObserving = function() {\n      this._hObserve.stop();\n      this._hDataAutorun.stop();\n      delete this._serverMode;\n      delete this._hUnsetTimeout;\n    };\n\n    AngularMeteorCollection._setServerUpdateMode = function(name) {\n      this._serverMode = true;\n      // To simplify server update logic, we don't follow\n      // updates from the client at the same time.\n      this._unsetAutoClientSave();\n    };\n\n    // Here we use $timeout to combine multiple updates that go\n    // each one after another.\n    AngularMeteorCollection._unsetServerUpdateMode = function(autoClientSave) {\n      var self = this;\n\n      if (self._hUnsetTimeout) {\n        $timeout.cancel(self._hUnsetTimeout);\n        self._hUnsetTimeout = null;\n      }\n\n      self._hUnsetTimeout = $timeout(function() {\n        self._serverMode = false;\n        // Finds updates that was potentially done from the client side\n        // and saves them.\n        var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\n        self._saveChanges(changes);\n        // After, continues following client updates.\n        if (autoClientSave) self._setAutoClientSave();\n      }, 0);\n    };\n\n    AngularMeteorCollection.stop = function() {\n      this._stopCursor();\n      this._hNewCurAutorun.stop();\n    };\n\n    AngularMeteorCollection._stopCursor = function() {\n      this._unsetAutoClientSave();\n\n      if (this._hObserve) {\n        this._hObserve.stop();\n        this._hDataAutorun.stop();\n      }\n\n      this.splice(0);\n      this._serverBackup.splice(0);\n    };\n\n    AngularMeteorCollection._unsetAutoClientSave = function(name) {\n      if (this._hRegAutoBind) {\n        this._hRegAutoBind();\n        this._hRegAutoBind = null;\n      }\n    };\n\n    AngularMeteorCollection._setAutoClientSave = function() {\n      var self = this;\n\n      // Always unsets auto save to keep only one $watch handler.\n      self._unsetAutoClientSave();\n\n      self._hRegAutoBind = $rootScope.$watch(function() {\n        return self;\n      }, function(nItems, oItems) {\n        if (nItems === oItems) return;\n\n        var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\n        self._unsetAutoClientSave();\n        self._saveChanges(changes);\n        self._setAutoClientSave();\n      }, true);\n    };\n\n    AngularMeteorCollection._saveChanges = function(changes) {\n      var self = this;\n\n      // Saves added documents\n      // Using reversed iteration to prevent indexes from changing during splice\n      var addedDocs = changes.added.reverse().map(function(descriptor) {\n        self.splice(descriptor.index, 1);\n        return descriptor.item;\n      });\n\n      if (addedDocs.length) self.save(addedDocs);\n\n      // Removes deleted documents\n      var removedDocs = changes.removed.map(function(descriptor) {\n        return descriptor.item;\n      });\n\n      if (removedDocs.length) self.remove(removedDocs);\n\n      // Updates changed documents\n      changes.changed.forEach(function(descriptor) {\n        self._updateDiff(descriptor.selector, descriptor.modifier);\n      });\n    };\n\n    return AngularMeteorCollection;\n}]);\n\nangularMeteorCollection.factory('$meteorCollectionFS', [\n  '$meteorCollection', 'diffArray', '$angularMeteorSettings',\n  function($meteorCollection, diffArray, $angularMeteorSettings) {\n    function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n      return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\n    }\n\n    return $meteorCollectionFS;\n}]);\n\nangularMeteorCollection.factory('$meteorCollection', [\n  'AngularMeteorCollection', '$rootScope', 'diffArray',\n  function(AngularMeteorCollection, $rootScope, diffArray) {\n    function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\n      // Validate parameters\n      if (!reactiveFunc) {\n        throw new TypeError('The first argument of $meteorCollection is undefined.');\n      }\n\n      if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n        throw new TypeError(\n          'The first argument of $meteorCollection must be a function or ' +\n            'a have a find function property.');\n      }\n\n      if (!angular.isFunction(reactiveFunc)) {\n        collection = angular.isDefined(collection) ? collection : reactiveFunc;\n        reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\n      }\n\n      // By default auto save - true.\n      autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n      diffFn = diffFn || diffArray;\n      return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\n    }\n\n    return $meteorCollection;\n}]);\n\nangularMeteorCollection.run([\n  '$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper',\n  function($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n    var scopeProto = Object.getPrototypeOf($rootScope);\n    scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n    scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-collection.js\n **/","/*global\n  angular, _, Mongo\n*/\n\nimport _ from '../lib/underscore';\n\n'use strict';\n\nvar angularMeteorObject = angular.module('angular-meteor.object',\n  ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray', 'angular-meteor.settings']);\n\nangularMeteorObject.factory('AngularMeteorObject', [\n  '$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings',\n  function($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\n\n    // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n    AngularMeteorObject.$$internalProps = [\n      '$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope',\n      'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject',\n      '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'\n    ];\n\n    function AngularMeteorObject (collection, selector, options){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n      // Make data not be an object so we can extend it to preserve\n      // Collection Helpers and the like\n      var helpers = collection._helpers;\n      var data = _.isFunction(helpers) ? Object.create(helpers.prototype) : {};\n      var doc = collection.findOne(selector, options);\n      var collectionExtension = _.pick(AngularMeteorCollection, '_updateParallel');\n      _.extend(data, doc);\n      _.extend(data, AngularMeteorObject);\n      _.extend(data, collectionExtension);\n\n      // Omit options that may spoil document finding\n      data.$$options = _.omit(options, 'skip', 'limit');\n      data.$$collection = collection;\n      data.$$id = data._getId(selector);\n      data._serverBackup = doc || {};\n\n      return data;\n    }\n\n    AngularMeteorObject.getRawObject = function () {\n      return angular.copy(_.omit(this, this.$$internalProps));\n    };\n\n    AngularMeteorObject.subscribe = function () {\n      $meteorSubscribe.subscribe.apply(this, arguments);\n      return this;\n    };\n\n    AngularMeteorObject.save = function(custom) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n      var oldDoc = collection.findOne(this.$$id);\n      var mods;\n\n      // update\n      if (oldDoc) {\n        if (custom)\n          mods = { $set: custom };\n        else {\n          mods = getUpdates(oldDoc, this.getRawObject());\n          // If there are no updates, there is nothing to do here, returning\n          if (_.isEmpty(mods)) {\n            return $q.when({ action: 'updated' });\n          }\n        }\n\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\n        this._updateDiff(mods, createFulfill({ action: 'updated' }));\n      }\n      // insert\n      else {\n        if (custom)\n          mods = _.clone(custom);\n        else\n          mods = this.getRawObject();\n\n        mods._id = mods._id || this.$$id;\n        collection.insert(mods, createFulfill({ action: 'inserted' }));\n      }\n\n      return deferred.promise;\n    };\n\n    AngularMeteorObject._updateDiff = function(update, callback) {\n      var selector = this.$$id;\n      AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\n    };\n\n    AngularMeteorObject.reset = function(keepClientProps) {\n      var self = this;\n      var options = this.$$options;\n      var id = this.$$id;\n      var doc = this.$$collection.findOne(id, options);\n\n      if (doc) {\n        // extend SubObject\n        var docKeys = _.keys(doc);\n        var docExtension = _.pick(doc, docKeys);\n        var clientProps;\n\n        _.extend(self, docExtension);\n        _.extend(self._serverBackup, docExtension);\n\n        if (keepClientProps) {\n          clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\n        } else {\n          clientProps = _.keys(self);\n        }\n\n        var serverProps = _.keys(doc);\n        var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\n\n        removedKeys.forEach(function (prop) {\n          delete self[prop];\n          delete self._serverBackup[prop];\n        });\n      }\n\n      else {\n        _.keys(this.getRawObject()).forEach(function(prop) {\n          delete self[prop];\n        });\n\n        self._serverBackup = {};\n      }\n    };\n\n    AngularMeteorObject.stop = function () {\n      if (this.unregisterAutoDestroy)\n        this.unregisterAutoDestroy();\n\n      if (this.unregisterAutoBind)\n        this.unregisterAutoBind();\n\n      if (this.autorunComputation && this.autorunComputation.stop)\n        this.autorunComputation.stop();\n    };\n\n    AngularMeteorObject._getId = function(selector) {\n      var options = _.extend({}, this.$$options, {\n        fields: { _id: 1 },\n        reactive: false,\n        transform: null\n      });\n\n      var doc = this.$$collection.findOne(selector, options);\n\n      if (doc) return doc._id;\n      if (selector instanceof Mongo.ObjectID) return selector;\n      if (_.isString(selector)) return selector;\n      return new Mongo.ObjectID();\n    };\n\n    return AngularMeteorObject;\n}]);\n\n\nangularMeteorObject.factory('$meteorObject', [\n  '$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject',\n  function($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n    function $meteorObject(collection, id, auto, options) {\n      // Validate parameters\n      if (!collection) {\n        throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n      }\n\n      if (!angular.isFunction(collection.findOne)) {\n        throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n      }\n\n      var data = new AngularMeteorObject(collection, id, options);\n      // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n      data._auto = auto !== false;\n      _.extend(data, $meteorObject);\n      data._setAutos();\n      return data;\n    }\n\n    $meteorObject._setAutos = function() {\n      var self = this;\n\n      this.autorunComputation = $meteorUtils.autorun($rootScope, function() {\n        self.reset(true);\n      });\n\n      // Deep watches the model and performs autobind\n      this.unregisterAutoBind = this._auto && $rootScope.$watch(function(){\n        return self.getRawObject();\n      }, function (item, oldItem) {\n        if (item !== oldItem) self.save();\n      }, true);\n\n      this.unregisterAutoDestroy = $rootScope.$on('$destroy', function() {\n        if (self && self.stop) self.pop();\n      });\n    };\n\n    return $meteorObject;\n}]);\n\nangularMeteorObject.run([\n  '$rootScope', '$meteorObject', '$meteorStopper',\n  function ($rootScope, $meteorObject, $meteorStopper) {\n    var scopeProto = Object.getPrototypeOf($rootScope);\n    scopeProto.$meteorObject = $meteorStopper($meteorObject);\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-object.js\n **/","/*global\n angular, _, Package, Meteor\n */\n\nimport _ from '../lib/underscore';\n\n'use strict';\n\nvar angularMeteorUser = angular.module('angular-meteor.user', [\n  'angular-meteor.utils',\n  'angular-meteor.core',\n  'angular-meteor.settings'\n]);\n\n// requires package 'accounts-password'\nangularMeteorUser.service('$meteorUser', [\n  '$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings',\n  function($rootScope, $meteorUtils, $q, $angularMeteorSettings){\n\n    var pack = Package['accounts-base'];\n    if (!pack) return;\n\n    var self = this;\n    var Accounts = pack.Accounts;\n\n    this.waitForUser = function(){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() )\n          deferred.resolve( Meteor.user() );\n      }, true);\n\n      return deferred.promise;\n    };\n\n    this.requireUser = function(){\n      if (!$angularMeteorSettings.suppressWarnings) {\n        console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n      }\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() ) {\n          if ( Meteor.user() === null)\n            deferred.reject(\"AUTH_REQUIRED\");\n          else\n            deferred.resolve( Meteor.user() );\n        }\n      }, true);\n\n      return deferred.promise;\n    };\n\n    this.requireValidUser = function(validatorFn) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      return self.requireUser(true).then(function(user){\n        var valid = validatorFn( user );\n\n        if ( valid === true )\n          return user;\n        else if ( typeof valid === \"string\" )\n          return $q.reject( valid );\n        else\n          return $q.reject( \"FORBIDDEN\" );\n\t    });\n\t  };\n\n    this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n    this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n    this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n    this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n    this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n    this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n    this.logout = $meteorUtils.promissor(Meteor, 'logout');\n    this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n    this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n    this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n    this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n    this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n    this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n    this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n    this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n  }\n]);\n\nangularMeteorUser.run([\n  '$rootScope', '$angularMeteorSettings', '$$Core',\n  function($rootScope, $angularMeteorSettings, $$Core){\n\n    let ScopeProto = Object.getPrototypeOf($rootScope);\n    _.extend(ScopeProto, $$Core);\n\n    $rootScope.autorun(function(){\n      if (!Meteor.user) return;\n      $rootScope.currentUser = Meteor.user();\n      $rootScope.loggingIn = Meteor.loggingIn();\n    });\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-user.js\n **/","/*global\n angular, _, Meteor\n */\n\nimport _ from '../lib/underscore';\n\n'use strict';\n\nvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils', 'angular-meteor.settings']);\n\nangularMeteorMethods.service('$meteorMethods', [\n  '$q', '$meteorUtils', '$angularMeteorSettings',\n  function($q, $meteorUtils, $angularMeteorSettings) {\n    this.call = function(){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var deferred = $q.defer();\n      var fulfill = $meteorUtils.fulfill(deferred);\n      var args = _.toArray(arguments).concat(fulfill);\n      Meteor.call.apply(this, args);\n      return deferred.promise;\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-methods.js\n **/","/*global\n angular, Session\n */\n\n'use strict';\nvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils', 'angular-meteor.settings']);\n\nangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings',\n  function ($meteorUtils, $parse, $angularMeteorSettings) {\n    return function (session) {\n\n      return {\n\n        bind: function(scope, model) {\n          if (!$angularMeteorSettings.suppressWarnings)\n            console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n          var getter = $parse(model);\n          var setter = getter.assign;\n          $meteorUtils.autorun(scope, function() {\n            setter(scope, Session.get(session));\n          });\n\n          scope.$watch(model, function(newItem, oldItem) {\n            Session.set(session, getter(scope));\n          }, true);\n\n        }\n      };\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-session.js\n **/","/*global\n angular, Package\n */\n\n'use strict';\n\nvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils', 'angular-meteor.settings']);\n\n// requires package 'mdg:camera'\nangularMeteorCamera.service('$meteorCamera', [\n  '$q', '$meteorUtils', '$angularMeteorSettings',\n  function ($q, $meteorUtils, $angularMeteorSettings) {\n    if (!$angularMeteorSettings.suppressWarnings)\n      console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n    var pack = Package['mdg:camera'];\n    if (!pack) return;\n\n    var MeteorCamera = pack.MeteorCamera;\n\n    this.getPicture = function(options){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      options = options || {};\n      var deferred = $q.defer();\n      MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n      return deferred.promise;\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-camera.js\n **/","/*global\n angular\n */\n\n'use strict';\n\nvar angularMeteorStopper = angular.module('angular-meteor.stopper',\n  ['angular-meteor.subscribe']);\n\nangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe',\n  function($q, $meteorSubscribe) {\n    function $meteorStopper($meteorEntity) {\n      return function() {\n        var args = Array.prototype.slice.call(arguments);\n        var meteorEntity = $meteorEntity.apply(this, args);\n\n        angular.extend(meteorEntity, $meteorStopper);\n        meteorEntity.$$scope = this;\n\n        this.$on('$destroy', function () {\n          meteorEntity.stop();\n          if (meteorEntity.subscription) meteorEntity.subscription.stop();\n        });\n\n        return meteorEntity;\n      };\n    }\n\n    $meteorStopper.subscribe = function() {\n      var args = Array.prototype.slice.call(arguments);\n      this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\n      return this;\n    };\n\n    return $meteorStopper;\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-stopper.js\n **/","import _ from '../lib/underscore';\n\nexport const name = 'angular-meteor.utilities';\nexport const utils = '$$utils';\n\nangular.module(name, [])\n\n/*\n  A utility service which is provided with general utility functions\n */\n.service(utils, [\n  '$rootScope',\n\n  function($rootScope) {\n    const self = this;\n\n    // Checks if an object is a cursor\n    this.isCursor = (obj) => {\n      return obj instanceof Meteor.Collection.Cursor;\n    };\n\n    // Cheecks if an object is a scope\n    this.isScope = (obj) => {\n      return obj instanceof $rootScope.constructor;\n    };\n\n    // Checks if an object is a view model\n    this.isViewModel = (obj) => {\n      return _.isObject(obj) && obj.$$dependencies;\n    };\n\n    // Checks if two objects are siblings\n    this.areSiblings = (obj1, obj2) => {\n      return _.isObject(obj1) && _.isObject(obj2) &&\n        Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n    };\n\n    // Binds function into a scpecified context. If an object is provided, will bind every\n    // value in the object which is a function. If a tap function is provided, it will be\n    // called right after the function has been invoked.\n    this.bind = (fn, context, tap) => {\n      tap = _.isFunction(tap) ? tap : angular.noop;\n      if (_.isFunction(fn)) return bindFn(fn, context, tap);\n      if (_.isObject(fn)) return bindObj(fn, context, tap);\n      return fn;\n    };\n\n    function bindFn(fn, context, tap) {\n      return (...args) => {\n        const result = fn.apply(context, args);\n        tap.call(context, {\n          result,\n          args\n        });\n        return result;\n      };\n    }\n\n    function bindObj(obj, context, tap) {\n      return _.keys(obj).reduce((bound, k) => {\n        bound[k] = self.bind(obj[k], context, tap);\n        return bound;\n      }, {});\n    }\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/utils.js\n **/","import _ from '../lib/underscore';\n\nexport const name = 'angular-meteor.mixer';\nexport const Mixer = '$Mixer';\n\nangular.module(name, [])\n\n/*\n  A service which lets us apply mixins into Scope.prototype.\n  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n  and any time a `ChildScope` prototype is created\n  it will be extended by the `$Mixer`.\n  This concept is good because it keeps our code\n  clean and simple, and easy to extend.\n  So any time we would like to define a new behaviour to our scope,\n  we will just use the `$Mixer` service.\n */\n.service(Mixer, function() {\n  // Used to store method's caller\n  let caller;\n\n  this._mixins = [];\n  // Apply mixins automatically on specified contexts\n  this._autoExtend = [];\n  this._autoConstruct = [];\n\n  // Adds a new mixin\n  this.mixin = (mixin) => {\n    if (!_.isObject(mixin)) {\n      throw Error('argument 1 must be an object');\n    }\n\n    this._mixins = _.union(this._mixins, [mixin]);\n    // Apply mixins to stored contexts\n    this._autoExtend.forEach(context => this._extend(context));\n    this._autoConstruct.forEach(context => this._construct(context));\n    return this;\n  };\n\n  // Removes a mixin. Useful mainly for test purposes\n  this._mixout = (mixin) => {\n    this._mixins = _.without(this._mixins, mixin);\n    return this;\n  };\n\n  // Invoke function mixins with the provided context and arguments\n  this._construct = (context, ...args) => {\n    this._mixins.filter(_.isFunction).forEach((mixin) => {\n      mixin.call(context, ...args);\n    });\n\n    return context;\n  };\n\n  // Extend prototype with the defined mixins\n  this._extend = (obj, options) => {\n    const { pattern, context } = _.defaults({}, options, {\n      pattern: /.*/, // The patterns of the keys which will be filtered\n    });\n\n    const mixins = this._mixins.map((mixin) => {\n      // Filtering the keys by the specified pattern\n      const keys = _.keys(mixin)\n        .filter(k => k.match(pattern))\n        .filter(k => _.isFunction(mixin[k]));\n\n      return keys.reduce((boundMixin, methodName) => {\n        const methodHandler = mixin[methodName];\n\n        // Note that this is not an arrow function so we can conserve the conetxt\n        boundMixin[methodName] = function(...args) {\n          // Storing original caller so we will know who actually called the\n          // method event though it is bound to another context\n          const methodContext = context || this;\n          const recentCaller = caller;\n          caller = this;\n\n          try {\n            return methodHandler.apply(methodContext, args);\n          }\n          finally {\n            // No matter what happens, restore variable to the previous one\n            caller = recentCaller;\n          }\n        };\n\n        return boundMixin;\n      }, {});\n    });\n\n    return _.extend(obj, ...mixins);\n  };\n\n  // Caller property can not be set\n  Object.defineProperty(this, 'caller', {\n    configurable: true,\n    enumerable: true,\n\n    get: () => {\n      return caller;\n    }\n  });\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/mixer.js\n **/","import { name as mixerName, Mixer } from './mixer';\n\nexport const name = 'angular-meteor.scope';\n\nangular.module(name, [\n  mixerName\n])\n\n.run([\n  '$rootScope',\n  Mixer,\n  function($rootScope, $Mixer) {\n    const Scope = $rootScope.constructor;\n    const $new = $rootScope.$new;\n\n    // Apply extensions whether a mixin in defined.\n    // Note that this way mixins which are initialized later\n    // can be applied on rootScope.\n    $Mixer._autoExtend.push(Scope.prototype);\n    $Mixer._autoConstruct.push($rootScope);\n\n    Scope.prototype.$new = function() {\n      const scope = $new.apply(this, arguments);\n      // Apply constructors to newly created scopes\n      return $Mixer._construct(scope);\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/scope.js\n **/","import _ from '../lib/underscore';\nimport { name as utilsName, utils } from './utils';\nimport { name as mixerName, Mixer } from './mixer';\n\nexport const name = 'angular-meteor.core';\nexport const Core = '$$Core';\n\nangular.module(name, [\n  utilsName,\n  mixerName\n])\n\n\n/*\n  A mixin which provides us with core Meteor functions.\n */\n.factory(Core, [\n  '$q',\n  utils,\n  Mixer,\n\n  function($q, $$utils, $Mixer) {\n    function $$Core() {}\n\n    // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n    $$Core.autorun = function(fn, options = {}) {\n      fn = this.$bindToContext($Mixer.caller, fn);\n\n      if (!_.isFunction(fn)) {\n        throw Error('argument 1 must be a function');\n      }\n      if (!_.isObject(options)) {\n        throw Error('argument 2 must be an object');\n      }\n\n      const computation = Tracker.autorun(fn, options);\n      // Reset to a function that will also stop the listener we just added\n      computation.stop = this.$$autoStop(computation);\n      return computation;\n    };\n\n    // Calls Meteor.subscribe() which will be digested after each invokation\n    // and automatically destroyed\n    $$Core.subscribe = function(subName, fn, cb) {\n      fn = this.$bindToContext($Mixer.caller, fn || angular.noop);\n      cb = cb ? this.$bindToContext($Mixer.caller, cb) : angular.noop;\n\n      // Additional callbacks specific for this library\n      // onStart - right after Meteor.subscribe()\n      const hooks = {\n        onStart: angular.noop\n      };\n\n      if (!_.isString(subName)) {\n        throw Error('argument 1 must be a string');\n      }\n      if (!_.isFunction(fn)) {\n        throw Error('argument 2 must be a function');\n      }\n      if (!_.isFunction(cb) && !_.isObject(cb)) {\n        throw Error('argument 3 must be a function or an object');\n      }\n\n      if (_.isObject(cb)) {\n        for (const hook in hooks) {\n          if (hooks.hasOwnProperty(hook) && cb[hook]) {\n            // Don't use any of additional callbacks in Meteor.subscribe\n            hooks[hook] = cb[hook];\n            delete cb[hook];\n          }\n        }\n      }\n\n      const result = {};\n\n      const computation = this.autorun(() => {\n        let args = fn();\n        if (angular.isUndefined(args)) args = [];\n\n        if (!_.isArray(args)) {\n          throw Error(`reactive function's return value must be an array`);\n        }\n\n        const subscription = Meteor.subscribe(subName, ...args, cb);\n\n        hooks.onStart();\n\n        result.ready = subscription.ready.bind(subscription);\n        result.subscriptionId = subscription.subscriptionId;\n      });\n\n      // Once the computation has been stopped,\n      // any subscriptions made inside will be stopped as well\n      result.stop = computation.stop.bind(computation);\n      return result;\n    };\n\n    // Calls Meteor.call() wrapped by a digestion cycle\n    $$Core.callMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n      return Meteor.call(...args, fn);\n    };\n\n    // Calls Meteor.apply() wrapped by a digestion cycle\n    $$Core.applyMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n      return Meteor.apply(...args, fn);\n    };\n\n    // Stops a process once the scope has been destroyed\n    $$Core.$$autoStop = function(stoppable) {\n      let removeListener;\n      const baseStop = stoppable.stop.bind(stoppable);\n\n      // Once the process has been stopped the destroy event listener will be removed\n      // to avoid memory leaks and unexpected behaviours\n      const stop = (...args) => {\n        removeListener();\n        return baseStop(...args);\n      };\n\n      removeListener = this.$on('$destroy', stop);\n      return stop;\n    };\n\n    // Digests scope only if there is no phase at the moment\n    $$Core.$$throttledDigest = function() {\n      const isDigestable = !this.$$destroyed &&\n        !this.$$phase &&\n        !this.$root.$$phase;\n\n      if (isDigestable) this.$digest();\n    };\n\n    // Creates a promise only that the digestion cycle will be called at its fulfillment\n    $$Core.$$defer = function() {\n      const deferred = $q.defer();\n      // Once promise has been fulfilled, digest\n      deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n      return deferred;\n    };\n\n    // Binds an object or a function to the provided context and digest it once it is invoked\n    $$Core.$bindToContext = function(context, fn) {\n      if (_.isFunction(context)) {\n        fn = context;\n        context = this;\n      }\n\n      return $$utils.bind(fn, context, this.$$throttledDigest.bind(this));\n    };\n\n    return $$Core;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/core.js\n **/","import _ from '../lib/underscore';\nimport { name as utilsName, utils } from './utils';\nimport { name as mixerName, Mixer } from './mixer';\nimport { name as coreName } from './core';\n\nexport const name = 'angular-meteor.view-model';\nexport const ViewModel = '$$ViewModel';\nexport const reactive = '$reactive';\n\nangular.module(name, [\n  utilsName,\n  mixerName,\n  coreName\n])\n\n/*\n  A mixin which lets us bind a view model into a scope.\n  Note that only a single view model can be bound,\n  otherwise the scope might behave unexpectedly.\n  Mainly used to define the controller as the view model,\n  and very useful when wanting to use Angular's `controllerAs` syntax.\n */\n.factory(ViewModel, [\n  utils,\n  Mixer,\n\n  function($$utils, $Mixer) {\n    function $$ViewModel() {}\n\n    // Gets an object, wraps it with scope functions and returns it\n    $$ViewModel.viewModel = function(vm) {\n      if (!_.isObject(vm)) {\n        throw Error('argument 1 must be an object');\n      }\n\n      // Extend view model with mixin functions\n      $Mixer._extend(vm, {\n        pattern: /^(?!\\$\\$).*$/, // Omitting methods which start with a $$ notation\n        context: this // Binding methods to scope\n      });\n\n      // Apply mixin constructors on scope with view model\n      $Mixer._construct(this, vm);\n      return vm;\n    };\n\n    return $$ViewModel;\n  }\n])\n\n\n/*\n  Illustrates the old API where a view model is created using $reactive service\n */\n.service(reactive, [\n  utils,\n\n  function($$utils) {\n    class Reactive {\n      constructor(vm) {\n        if (!_.isObject(vm)) {\n          throw Error('argument 1 must be an object');\n        }\n\n        _.defer(() => {\n          if (!this._attached) {\n            console.warn('view model was not attached to any scope');\n          }\n        });\n\n        this._vm = vm;\n      }\n\n      attach(scope) {\n        this._attached = true;\n\n        if (!$$utils.isScope(scope)) {\n          throw Error('argument 1 must be a scope');\n        }\n\n        const viewModel = scope.viewModel(this._vm);\n\n        // Similar to the old/Meteor API\n        viewModel.call = viewModel.callMethod;\n        viewModel.apply = viewModel.applyMethod;\n\n        return viewModel;\n      }\n    }\n\n    return (vm) => new Reactive(vm);\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/view-model.js\n **/","import jsondiffpatch from 'jsondiffpatch';\nimport _ from '../lib/underscore';\nimport { name as utilsName, utils } from './utils';\nimport { name as mixerName, Mixer } from './mixer';\nimport { name as coreName } from './core';\nimport { name as viewModelName } from './view-model';\n\nexport const name = 'angular-meteor.reactive';\nexport const Reactive = '$$Reactive';\n\nangular.module(name, [\n  utilsName,\n  mixerName,\n  coreName,\n  viewModelName\n])\n\n\n/*\n  A mixin which enhance our reactive abilities by providing methods\n  that are capable of updating our scope reactively.\n */\n.factory(Reactive, [\n  '$parse',\n  utils,\n  Mixer,\n\n  function($parse, $$utils, $Mixer) {\n    function $$Reactive(vm = this) {\n      // Helps us track changes made in the view model\n      vm.$$dependencies = {};\n    }\n\n    // Gets an object containing functions and define their results as reactive properties.\n    // Once a return value has been changed the property will be reset.\n    $$Reactive.helpers = function(vm, props) {\n      if ($$utils.isViewModel(vm)) {\n        if (!_.isObject(props)) {\n          throw Error('argument 2 must be an object');\n        }\n      } else {\n        props = vm;\n        vm = $Mixer.caller;\n\n        if (!_.isObject(props)) {\n          throw Error('argument 1 must be an object');\n        }\n      }\n\n      _.each(props, (v, k) => {\n        if (!_.isFunction(v)) {\n          throw Error(`helper '${k}' must be a function`);\n        }\n      });\n\n      _.each(props, (v, k) => {\n        if (!vm.$$dependencies[k]) {\n          // Registers a new dependency to the specified helper\n          vm.$$dependencies[k] = new Tracker.Dependency();\n        }\n\n        this.$$setFnHelper(vm, k, v);\n      });\n    };\n\n    // Gets a model reactively\n    $$Reactive.getReactively = function(vm, k, isDeep) {\n      if ($$utils.isViewModel(vm)) {\n        if (angular.isUndefined(isDeep)) isDeep = false;\n\n        if (!_.isString(k)) {\n          throw Error('argument 2 must be a string');\n        }\n        if (!_.isBoolean(isDeep)) {\n          throw Error('argument 3 must be a boolean');\n        }\n      } else {\n        isDeep = angular.isDefined(k) ? k : false;\n        k = vm;\n        vm = $Mixer.caller;\n\n        if (!_.isString(k)) {\n          throw Error('argument 1 must be a string');\n        }\n        if (!_.isBoolean(isDeep)) {\n          throw Error('argument 2 must be a boolean');\n        }\n      }\n\n      return this.$$reactivateEntity(vm, k, this.$watch, isDeep);\n    };\n\n    // Gets a collection reactively\n    $$Reactive.getCollectionReactively = function(vm, k) {\n      if ($$utils.isViewModel(vm)) {\n        if (!_.isString(k)) {\n          throw Error('argument 2 must be a string');\n        }\n      } else {\n        k = vm;\n        vm = $Mixer.caller;\n\n        if (!_.isString(k)) {\n          throw Error('argument 1 must be a string');\n        }\n      }\n\n      return this.$$reactivateEntity(vm, k, this.$watchCollection);\n    };\n\n    // Gets an entity reactively, and once it has been changed the computation will be recomputed\n    $$Reactive.$$reactivateEntity = function(vm, k, watcher, ...watcherArgs) {\n      if (!vm.$$dependencies[k]) {\n        vm.$$dependencies[k] = new Tracker.Dependency();\n        this.$$watchEntity(vm, k, watcher, ...watcherArgs);\n      }\n\n      vm.$$dependencies[k].depend();\n      return $parse(k)(vm);\n    };\n\n    // Watches for changes in the view model, and if so will notify a change\n    $$Reactive.$$watchEntity = function(vm, k, watcher, ...watcherArgs) {\n      // Gets a deep property from the caller\n      const getVal = _.partial($parse(k), vm);\n      const initialVal = getVal();\n\n      // Watches for changes in the view model\n      watcher.call(this, getVal, (val, oldVal) => {\n        const hasChanged =\n          val !== initialVal ||\n          val !== oldVal;\n\n        // Notify if a change has been detected\n        if (hasChanged) this.$$changed(vm, k);\n      }, ...watcherArgs);\n    };\n\n    // Invokes a function and sets the return value as a property\n    $$Reactive.$$setFnHelper = function(vm, k, fn) {\n      let activeObservation = null;\n      let lastModel = null;\n      let lastModelData = [];\n\n      this.autorun((/* computation */) => {\n        // Invokes the reactive functon\n        const model = fn.apply(vm);\n\n        // Ignore notifications made by the following handler\n        Tracker.nonreactive(() => {\n          // If a cursor, observe its changes and update acoordingly\n          if ($$utils.isCursor(model)) {\n            let modelData;\n\n            if (angular.isUndefined(vm[k])) {\n              this.$$setValHelper(vm, k, [], false);\n            }\n\n            if (activeObservation) {\n              lastModelData = lastModel.fetch();\n              activeObservation.stop();\n              activeObservation = null;\n            }\n\n            const handle = this.$$handleCursor(vm, k, model);\n\n            activeObservation = handle.observation;\n            modelData = handle.data;\n\n            if (lastModelData.length !== 0) {\n              const diff = jsondiffpatch.diff(lastModelData, modelData);\n              vm[k] = jsondiffpatch.patch(lastModelData, diff);\n            } else {\n              vm[k] = modelData;\n            }\n\n            lastModel = model;\n            lastModelData = modelData;\n\n            /* computation.onInvalidate(() => {\n              activeObservation.stop();\n            });*/\n          } else {\n            this.$$handleNonCursor(vm, k, model);\n          }\n\n          // Notify change and update the view model\n          this.$$changed(vm, k);\n        });\n      });\n    };\n\n    // Sets a value helper as a setter and a getter which will notify computations once used\n    $$Reactive.$$setValHelper = function(vm, k, v, watch = true) {\n      // If set, reactives property\n      if (watch) {\n        const isDeep = _.isObject(v);\n        this.getReactively(vm, k, isDeep);\n      }\n\n      Object.defineProperty(vm, k, {\n        configurable: true,\n        enumerable: true,\n\n        get: () => {\n          return v;\n        },\n        set: (newVal) => {\n          v = newVal;\n          this.$$changed(vm, k);\n        }\n      });\n    };\n\n    // Fetching a cursor and updates properties once the result set has been changed\n    $$Reactive.$$handleCursor = function(vm, k, cursor) {\n      const data = [];\n      // Observe changes made in the result set\n      const observation = cursor.observe({\n        addedAt: (doc, atIndex) => {\n          if (!observation) {\n            data.push(doc);\n            return;\n          }\n          vm[k].splice(atIndex, 0, doc);\n          this.$$changed(vm, k);\n        },\n        changedAt: (doc, oldDoc, atIndex) => {\n          const diff = jsondiffpatch.diff(vm[k][atIndex], doc);\n          jsondiffpatch.patch(vm[k][atIndex], diff);\n          this.$$changed(vm, k);\n        },\n        movedTo: (doc, fromIndex, toIndex) => {\n          vm[k].splice(fromIndex, 1);\n          vm[k].splice(toIndex, 0, doc);\n          this.$$changed(vm, k);\n        },\n        removedAt: (oldDoc, atIndex) => {\n          vm[k].splice(atIndex, 1);\n          this.$$changed(vm, k);\n        }\n      });\n\n      return {\n        observation,\n        data\n      };\n    };\n\n    $$Reactive.$$handleNonCursor = function(vm, k, data) {\n      let v = vm[k];\n\n      if (angular.isDefined(v)) {\n        delete vm[k];\n        v = null;\n      }\n\n      if (angular.isUndefined(v)) {\n        this.$$setValHelper(vm, k, data);\n      }\n      // Update property if the new value is from the same type\n      else if ($$utils.areSiblings(v, data)) {\n        const diff = jsondiffpatch.diff(v, data);\n        jsondiffpatch.patch(v, diff);\n        this.$$changed(vm, k);\n      } else {\n        vm[k] = data;\n      }\n    };\n\n    // Notifies dependency in view model\n    $$Reactive.$$depend = function(vm, k) {\n      vm.$$dependencies[k].depend();\n    };\n\n    // Notifies change in view model\n    $$Reactive.$$changed = function(vm, k) {\n      this.$$throttledDigest();\n      vm.$$dependencies[k].changed();\n    };\n\n    return $$Reactive;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/reactive.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_22__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jsondiffpatch\"\n ** module id = 22\n ** module chunks = 0\n **/","export const name = 'angular-templates';\n\ntry {\n  angular.module(name);\n} catch (e) {\n  angular.module(name, []);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/templates.js\n **/"],"sourceRoot":""}